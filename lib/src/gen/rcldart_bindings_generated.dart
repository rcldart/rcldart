// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Regenerate bindings with `flutter pub run ffigen --config ffigen_rcl.yaml`.
///
class RcldartBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RcldartBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  RcldartBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Return a zero initialized allocator.
  /// /**
  ///  * Note that this is an invalid allocator and should only be used as a placeholder.
  ///  */
  rcutils_allocator_t rcutils_get_zero_initialized_allocator() {
    return _rcutils_get_zero_initialized_allocator();
  }

  late final _rcutils_get_zero_initialized_allocatorPtr =
      _lookup<ffi.NativeFunction<rcutils_allocator_t Function()>>(
          'rcutils_get_zero_initialized_allocator');
  late final _rcutils_get_zero_initialized_allocator =
      _rcutils_get_zero_initialized_allocatorPtr
          .asFunction<rcutils_allocator_t Function()>();

  /// Return a properly initialized rcutils_allocator_t with default values.
  /// /**
  ///  * This defaults to:
  ///  *
  ///  * - allocate = wraps malloc()
  ///  * - deallocate = wraps free()
  ///  * - reallocate = wraps realloc()
  ///  * - zero_allocate = wraps calloc()
  ///  * - state = `NULL`
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  */
  rcutils_allocator_t rcutils_get_default_allocator() {
    return _rcutils_get_default_allocator();
  }

  late final _rcutils_get_default_allocatorPtr =
      _lookup<ffi.NativeFunction<rcutils_allocator_t Function()>>(
          'rcutils_get_default_allocator');
  late final _rcutils_get_default_allocator = _rcutils_get_default_allocatorPtr
      .asFunction<rcutils_allocator_t Function()>();

  /// Return true if the given allocator has non-null function pointers.
  /// /**
  ///  * \param[in] allocator to be checked by the function
  ///  * \return `true` if the allocator is valid, `false` otherwise.
  ///  */
  bool rcutils_allocator_is_valid(
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_allocator_is_valid(
      allocator,
    );
  }

  late final _rcutils_allocator_is_validPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<rcutils_allocator_t>)>>(
      'rcutils_allocator_is_valid');
  late final _rcutils_allocator_is_valid = _rcutils_allocator_is_validPtr
      .asFunction<bool Function(ffi.Pointer<rcutils_allocator_t>)>();

  /// Emulate the behavior of [reallocf](https://linux.die.net/man/3/reallocf).
  /// /**
  ///  * This function will return `NULL` if the allocator is `NULL` or has `NULL` for
  ///  * function pointer fields.
  ///  * \param[inout] pointer to the memory which will be reallocated
  ///  * \param[in] size in bytes
  ///  * \param[in] allocator to be used to allocate and deallocate memory
  ///  */
  ffi.Pointer<ffi.Void> rcutils_reallocf(
    ffi.Pointer<ffi.Void> pointer,
    int size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_reallocf(
      pointer,
      size,
      allocator,
    );
  }

  late final _rcutils_reallocfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<rcutils_allocator_t>)>>('rcutils_reallocf');
  late final _rcutils_reallocf = _rcutils_reallocfPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<rcutils_allocator_t>)>();

  /// Get zero initialized security options.
  rmw_security_options_t rmw_get_zero_initialized_security_options() {
    return _rmw_get_zero_initialized_security_options();
  }

  late final _rmw_get_zero_initialized_security_optionsPtr =
      _lookup<ffi.NativeFunction<rmw_security_options_t Function()>>(
          'rmw_get_zero_initialized_security_options');
  late final _rmw_get_zero_initialized_security_options =
      _rmw_get_zero_initialized_security_optionsPtr
          .asFunction<rmw_security_options_t Function()>();

  /// Get default initialized security options.
  rmw_security_options_t rmw_get_default_security_options() {
    return _rmw_get_default_security_options();
  }

  late final _rmw_get_default_security_optionsPtr =
      _lookup<ffi.NativeFunction<rmw_security_options_t Function()>>(
          'rmw_get_default_security_options');
  late final _rmw_get_default_security_options =
      _rmw_get_default_security_optionsPtr
          .asFunction<rmw_security_options_t Function()>();

  /// Copy the given security options.
  /// /**
  ///  * \param[in] src security options to be copied.
  ///  * \param[in] allocator allocator used when copying data to the new security options.
  ///  * \param[out] dst security options to be set.
  ///  * \returns RMW_RET_BAD_ALLOC, or
  ///  * \returns RMW_RET_OK
  ///  */
  int rmw_security_options_copy(
    ffi.Pointer<rmw_security_options_t> src,
    ffi.Pointer<rcutils_allocator_t> allocator,
    ffi.Pointer<rmw_security_options_t> dst,
  ) {
    return _rmw_security_options_copy(
      src,
      allocator,
      dst,
    );
  }

  late final _rmw_security_options_copyPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_security_options_t>,
                  ffi.Pointer<rcutils_allocator_t>,
                  ffi.Pointer<rmw_security_options_t>)>>(
      'rmw_security_options_copy');
  late final _rmw_security_options_copy =
      _rmw_security_options_copyPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_security_options_t>,
              ffi.Pointer<rcutils_allocator_t>,
              ffi.Pointer<rmw_security_options_t>)>();

  /// Set the security root path for the given security options.
  /// /**
  ///  * The provided `security_root_path` will be copied into allocated memory.
  ///  *
  ///  * \param[in] security_root_path path to be set.
  ///  * \param[in] allocator allocator used to allocate the new path.
  ///  * \param[inout] security_options security options to be set.
  ///  * \returns RMW_RET_BAD_ALLOC, or
  ///  * \returns RMW_RET_OK
  ///  */
  int rmw_security_options_set_root_path(
    ffi.Pointer<ffi.Char> security_root_path,
    ffi.Pointer<rcutils_allocator_t> allocator,
    ffi.Pointer<rmw_security_options_t> security_options,
  ) {
    return _rmw_security_options_set_root_path(
      security_root_path,
      allocator,
      security_options,
    );
  }

  late final _rmw_security_options_set_root_pathPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<rcutils_allocator_t>,
                  ffi.Pointer<rmw_security_options_t>)>>(
      'rmw_security_options_set_root_path');
  late final _rmw_security_options_set_root_path =
      _rmw_security_options_set_root_pathPtr.asFunction<
          int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<rcutils_allocator_t>,
              ffi.Pointer<rmw_security_options_t>)>();

  /// Finalize the given security_options.
  /// /**
  ///  * \param[in] security_options security options to be finalized.
  ///  * \param[in] allocator allocator used to deallocate the root path.
  ///  * \returns RMW_RET_ERROR, or
  ///  * \returns RMW_RET_OK
  ///  */
  int rmw_security_options_fini(
    ffi.Pointer<rmw_security_options_t> security_options,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rmw_security_options_fini(
      security_options,
      allocator,
    );
  }

  late final _rmw_security_options_finiPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_security_options_t>,
              ffi.Pointer<rcutils_allocator_t>)>>('rmw_security_options_fini');
  late final _rmw_security_options_fini =
      _rmw_security_options_finiPtr.asFunction<
          int Function(ffi.Pointer<rmw_security_options_t>,
              ffi.Pointer<rcutils_allocator_t>)>();

  /// Return a zero initialized init options structure.
  rmw_init_options_t rmw_get_zero_initialized_init_options() {
    return _rmw_get_zero_initialized_init_options();
  }

  late final _rmw_get_zero_initialized_init_optionsPtr =
      _lookup<ffi.NativeFunction<rmw_init_options_t Function()>>(
          'rmw_get_zero_initialized_init_options');
  late final _rmw_get_zero_initialized_init_options =
      _rmw_get_zero_initialized_init_optionsPtr
          .asFunction<rmw_init_options_t Function()>();

  /// Initialize given init options with the default values and implementation specific values.
  /// /**
  ///  * The given allocator is used, if required, during setup of the init options,
  ///  * but is also used during initialization.
  ///  *
  ///  * In either case the given allocator is stored in the returned init options.
  ///  *
  ///  * The `impl` pointer should not be changed manually.
  ///  *
  ///  * \pre The given init options must be zero initialized.
  ///  *
  ///  * \post If initialization fails, init options will remain zero initialized.
  ///  *
  ///  * \remark Giving an already initialized init options will result
  ///  *   in a failure with return code `RMW_RET_INVALID_ARGUMENT`.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[inout] init_options object to be setup
  ///  * \param[in] allocator to be used during setup and during initialization
  ///  * \return `RMW_RET_OK` if setup is successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RMW_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_init_options_init(
    ffi.Pointer<rmw_init_options_t> init_options,
    rcutils_allocator_t allocator,
  ) {
    return _rmw_init_options_init(
      init_options,
      allocator,
    );
  }

  late final _rmw_init_options_initPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_init_options_t>,
              rcutils_allocator_t)>>('rmw_init_options_init');
  late final _rmw_init_options_init = _rmw_init_options_initPtr.asFunction<
      int Function(ffi.Pointer<rmw_init_options_t>, rcutils_allocator_t)>();

  /// Copy the given source init options to the destination init options.
  /// /**
  ///  * The allocator from the source is used for any allocations and stored in the
  ///  * destination.
  ///  *
  ///  * \pre The source init options must have been initialized
  ///  *   i.e. had `rmw_init_options_init()` called on.
  ///  * \pre The destination init options must be zero initialized.
  ///  *
  ///  * \post If copy fails, destination init options will remain zero initialized.
  ///  *
  ///  * \remark Giving an zero initialized init options as a source will result
  ///  *   in a failure with return code `RMW_RET_INVALID_ARGUMENT`.
  ///  * \remark Giving an already initialized init options for the destination will result
  ///  *   in a failure with return code `RMW_RET_INVALID_ARGUMENT`.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[in] src rcl_init_options_t object to be copied from
  ///  * \param[out] dst rcl_init_options_t object to be copied into
  ///  * \return `RMW_RET_OK` if the copy is successful, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  ///  *   identifier for src does not match the implementation of this function, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RMW_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_init_options_copy(
    ffi.Pointer<rmw_init_options_t> src,
    ffi.Pointer<rmw_init_options_t> dst,
  ) {
    return _rmw_init_options_copy(
      src,
      dst,
    );
  }

  late final _rmw_init_options_copyPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_init_options_t>,
              ffi.Pointer<rmw_init_options_t>)>>('rmw_init_options_copy');
  late final _rmw_init_options_copy = _rmw_init_options_copyPtr.asFunction<
      int Function(
          ffi.Pointer<rmw_init_options_t>, ffi.Pointer<rmw_init_options_t>)>();

  /// Finalize the given init options.
  /// /**
  ///  * This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  ///  * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given init options
  ///  * unchanged.
  ///  * Otherwise, it will proceed despite errors, freeing as much resources as it can and zero
  ///  * initializing the given init options.
  ///  *
  ///  * \pre The given init options must have been initialized
  ///  *   i.e. had `rmw_init_options_init()` called on.
  ///  *
  ///  * \remarks If init options are zero initialized,
  ///  *   then `RMW_RET_INVALID_ARGUMENT` is returned.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[inout] init_options object to finalized
  ///  * \return `RMW_RET_OK` if finalization is successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  ///  *   identifier does not match the implementation of this function, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_init_options_fini(
    ffi.Pointer<rmw_init_options_t> init_options,
  ) {
    return _rmw_init_options_fini(
      init_options,
    );
  }

  late final _rmw_init_options_finiPtr = _lookup<
          ffi
          .NativeFunction<rmw_ret_t Function(ffi.Pointer<rmw_init_options_t>)>>(
      'rmw_init_options_fini');
  late final _rmw_init_options_fini = _rmw_init_options_finiPtr
      .asFunction<int Function(ffi.Pointer<rmw_init_options_t>)>();

  /// Return a zero initialized context structure.
  rmw_context_t rmw_get_zero_initialized_context() {
    return _rmw_get_zero_initialized_context();
  }

  late final _rmw_get_zero_initialized_contextPtr =
      _lookup<ffi.NativeFunction<rmw_context_t Function()>>(
          'rmw_get_zero_initialized_context');
  late final _rmw_get_zero_initialized_context =
      _rmw_get_zero_initialized_contextPtr
          .asFunction<rmw_context_t Function()>();

  /// Initialize the middleware with the given options, and yielding an context.
  /// /**
  ///  * Context is filled with middleware specific data upon success of this function.
  ///  * The context is used when initializing some entities like nodes and
  ///  * guard conditions, and is also required to properly call `rmw_shutdown()`.
  ///  *
  ///  * \pre The given options must have been initialized
  ///  *   i.e. `rmw_init_options_init()` called on it and
  ///  *   an enclave set.
  ///  * \pre The given context must be zero initialized.
  ///  *
  ///  * \post If initialization fails, context will remain zero initialized.
  ///  * \post `context->actual_domain_id` will be set with the domain id the rmw implementation is using.
  ///  *  This matches `options->domain_id` if it is not RMW_DEFAULT_DOMAIN_ID.
  ///  *  In other case, the value is rmw implementation dependent.
  ///  *
  ///  * \remarks If options are zero-initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.
  ///  *   If options are initialized but no enclave is provided, then `RMW_RET_INVALID_ARGUMENT`
  ///  *   is returned.
  ///  *   If context has been already initialized (`rmw_init()` was called on it), then
  ///  *   `RMW_RET_INVALID_ARGUMENT` is returned.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[in] options initialization options to be used during initialization
  ///  * \param[out] context resulting context struct
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  ///  *   identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_init(
    ffi.Pointer<rmw_init_options_t> options,
    ffi.Pointer<rmw_context_t> context,
  ) {
    return _rmw_init(
      options,
      context,
    );
  }

  late final _rmw_initPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_init_options_t>,
              ffi.Pointer<rmw_context_t>)>>('rmw_init');
  late final _rmw_init = _rmw_initPtr.asFunction<
      int Function(
          ffi.Pointer<rmw_init_options_t>, ffi.Pointer<rmw_context_t>)>();

  /// Shutdown the middleware for a given context.
  /// /**
  ///  * \pre The given context must be a valid context which has been initialized with `rmw_init()`.
  ///  *
  ///  * \remarks If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.
  ///  *   If context has been already invalidated (`rmw_shutdown()` was called on it), then
  ///  *   this function is a no-op and `RMW_RET_OK` is returned.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[in] context resulting context struct
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any argument are invalid, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  ///  *   identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_shutdown(
    ffi.Pointer<rmw_context_t> context,
  ) {
    return _rmw_shutdown(
      context,
    );
  }

  late final _rmw_shutdownPtr = _lookup<
          ffi.NativeFunction<rmw_ret_t Function(ffi.Pointer<rmw_context_t>)>>(
      'rmw_shutdown');
  late final _rmw_shutdown =
      _rmw_shutdownPtr.asFunction<int Function(ffi.Pointer<rmw_context_t>)>();

  /// Finalize a context.
  /// /**
  ///  * This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  ///  * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given context unchanged.
  ///  * Otherwise, it will proceed despite errors, freeing as much resources as it can and zero
  ///  * initializing the given context.
  ///  *
  ///  * \pre The context to be finalized must have been previously initialized with
  ///  *   `rmw_init()`, and then later invalidated with `rmw_shutdown()`.
  ///  *
  ///  * \remarks If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.
  ///  *   If context is initialized and valid (`rmw_shutdown()` was not called on it), then
  ///  *   `RMW_RET_INVALID_ARGUMENT` is returned.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  ///  *   identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occur.
  ///  */
  int rmw_context_fini(
    ffi.Pointer<rmw_context_t> context,
  ) {
    return _rmw_context_fini(
      context,
    );
  }

  late final _rmw_context_finiPtr = _lookup<
          ffi.NativeFunction<rmw_ret_t Function(ffi.Pointer<rmw_context_t>)>>(
      'rmw_context_fini');
  late final _rmw_context_fini = _rmw_context_finiPtr
      .asFunction<int Function(ffi.Pointer<rmw_context_t>)>();

  late final ffi.Pointer<ffi.Pointer<FILE>> _stdin =
      _lookup<ffi.Pointer<FILE>>('stdin');

  ffi.Pointer<FILE> get stdin => _stdin.value;

  set stdin(ffi.Pointer<FILE> value) => _stdin.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> _stdout =
      _lookup<ffi.Pointer<FILE>>('stdout');

  ffi.Pointer<FILE> get stdout => _stdout.value;

  set stdout(ffi.Pointer<FILE> value) => _stdout.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> _stderr =
      _lookup<ffi.Pointer<FILE>>('stderr');

  ffi.Pointer<FILE> get stderr => _stderr.value;

  set stderr(ffi.Pointer<FILE> value) => _stderr.value = value;

  int remove(
    ffi.Pointer<ffi.Char> __filename,
  ) {
    return _remove(
      __filename,
    );
  }

  late final _removePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'remove');
  late final _remove =
      _removePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int rename(
    ffi.Pointer<ffi.Char> __old,
    ffi.Pointer<ffi.Char> __new,
  ) {
    return _rename(
      __old,
      __new,
    );
  }

  late final _renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('rename');
  late final _rename = _renamePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int renameat(
    int __oldfd,
    ffi.Pointer<ffi.Char> __old,
    int __newfd,
    ffi.Pointer<ffi.Char> __new,
  ) {
    return _renameat(
      __oldfd,
      __old,
      __newfd,
      __new,
    );
  }

  late final _renameatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('renameat');
  late final _renameat = _renameatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int fclose(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fclose(
      __stream,
    );
  }

  late final _fclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fclose');
  late final _fclose = _fclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> tmpfile() {
    return _tmpfile();
  }

  late final _tmpfilePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FILE> Function()>>('tmpfile');
  late final _tmpfile = _tmpfilePtr.asFunction<ffi.Pointer<FILE> Function()>();

  ffi.Pointer<ffi.Char> tmpnam(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _tmpnam(
      arg0,
    );
  }

  late final _tmpnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam');
  late final _tmpnam = _tmpnamPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> tmpnam_r(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _tmpnam_r(
      __s,
    );
  }

  late final _tmpnam_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam_r');
  late final _tmpnam_r = _tmpnam_rPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> tempnam(
    ffi.Pointer<ffi.Char> __dir,
    ffi.Pointer<ffi.Char> __pfx,
  ) {
    return _tempnam(
      __dir,
      __pfx,
    );
  }

  late final _tempnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('tempnam');
  late final _tempnam = _tempnamPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fflush(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fflush(
      __stream,
    );
  }

  late final _fflushPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush');
  late final _fflush = _fflushPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fflush_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fflush_unlocked(
      __stream,
    );
  }

  late final _fflush_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush_unlocked');
  late final _fflush_unlocked =
      _fflush_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fopen(
    ffi.Pointer<ffi.Char> __filename,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fopen(
      __filename,
      __modes,
    );
  }

  late final _fopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fopen');
  late final _fopen = _fopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> freopen(
    ffi.Pointer<ffi.Char> __filename,
    ffi.Pointer<ffi.Char> __modes,
    ffi.Pointer<FILE> __stream,
  ) {
    return _freopen(
      __filename,
      __modes,
      __stream,
    );
  }

  late final _freopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('freopen');
  late final _freopen = _freopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fdopen(
    int __fd,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fdopen(
      __fd,
      __modes,
    );
  }

  late final _fdopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('fdopen');
  late final _fdopen = _fdopenPtr
      .asFunction<ffi.Pointer<FILE> Function(int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> fmemopen(
    ffi.Pointer<ffi.Void> __s,
    int __len,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _fmemopen(
      __s,
      __len,
      __modes,
    );
  }

  late final _fmemopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('fmemopen');
  late final _fmemopen = _fmemopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> open_memstream(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __bufloc,
    ffi.Pointer<ffi.Size> __sizeloc,
  ) {
    return _open_memstream(
      __bufloc,
      __sizeloc,
    );
  }

  late final _open_memstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('open_memstream');
  late final _open_memstream = _open_memstreamPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>)>();

  void setbuf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _setbuf(
      __stream,
      __buf,
    );
  }

  late final _setbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('setbuf');
  late final _setbuf = _setbufPtr
      .asFunction<void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int setvbuf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
    int __modes,
    int __n,
  ) {
    return _setvbuf(
      __stream,
      __buf,
      __modes,
      __n,
    );
  }

  late final _setvbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Size)>>('setvbuf');
  late final _setvbuf = _setvbufPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int, int)>();

  void setbuffer(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __buf,
    int __size,
  ) {
    return _setbuffer(
      __stream,
      __buf,
      __size,
    );
  }

  late final _setbufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('setbuffer');
  late final _setbuffer = _setbufferPtr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int)>();

  void setlinebuf(
    ffi.Pointer<FILE> __stream,
  ) {
    return _setlinebuf(
      __stream,
    );
  }

  late final _setlinebufPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'setlinebuf');
  late final _setlinebuf =
      _setlinebufPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fprintf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _fprintf(
      __stream,
      __format,
    );
  }

  late final _fprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fprintf');
  late final _fprintf = _fprintfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int printf(
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _printf(
      __format,
    );
  }

  late final _printfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'printf');
  late final _printf =
      _printfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sprintf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _sprintf(
      __s,
      __format,
    );
  }

  late final _sprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sprintf');
  late final _sprintf = _sprintfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int vfprintf(
    ffi.Pointer<FILE> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vfprintf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vfprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vfprintf');
  late final _vfprintf = _vfprintfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int vprintf(
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vprintf(
      __format,
      __arg,
    );
  }

  late final _vprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>('vprintf');
  late final _vprintf = _vprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  int vsprintf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vsprintf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vsprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vsprintf');
  late final _vsprintf = _vsprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int snprintf(
    ffi.Pointer<ffi.Char> __s,
    int __maxlen,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _snprintf(
      __s,
      __maxlen,
      __format,
    );
  }

  late final _snprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('snprintf');
  late final _snprintf = _snprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int vsnprintf(
    ffi.Pointer<ffi.Char> __s,
    int __maxlen,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vsnprintf(
      __s,
      __maxlen,
      __format,
      __arg,
    );
  }

  late final _vsnprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>('vsnprintf');
  late final _vsnprintf = _vsnprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int vdprintf(
    int __fd,
    ffi.Pointer<ffi.Char> __fmt,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vdprintf(
      __fd,
      __fmt,
      __arg,
    );
  }

  late final _vdprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vdprintf');
  late final _vdprintf = _vdprintfPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  int dprintf(
    int __fd,
    ffi.Pointer<ffi.Char> __fmt,
  ) {
    return _dprintf(
      __fd,
      __fmt,
    );
  }

  late final _dprintfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'dprintf');
  late final _dprintf =
      _dprintfPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  int fscanf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _fscanf(
      __stream,
      __format,
    );
  }

  late final _fscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fscanf');
  late final _fscanf = _fscanfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int scanf(
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _scanf(
      __format,
    );
  }

  late final _scanfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'scanf');
  late final _scanf =
      _scanfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sscanf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _sscanf(
      __s,
      __format,
    );
  }

  late final _sscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sscanf');
  late final _sscanf = _sscanfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int vfscanf(
    ffi.Pointer<FILE> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vfscanf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vfscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vfscanf');
  late final _vfscanf = _vfscanfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int vscanf(
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vscanf(
      __format,
      __arg,
    );
  }

  late final _vscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>>('vscanf');
  late final _vscanf = _vscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<__va_list_tag>)>();

  int vsscanf(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<__va_list_tag> __arg,
  ) {
    return _vsscanf(
      __s,
      __format,
      __arg,
    );
  }

  late final _vsscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('vsscanf');
  late final _vsscanf = _vsscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  int fgetc(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgetc(
      __stream,
    );
  }

  late final _fgetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('fgetc');
  late final _fgetc = _fgetcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getc(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getc(
      __stream,
    );
  }

  late final _getcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getc');
  late final _getc = _getcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar() {
    return _getchar();
  }

  late final _getcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar');
  late final _getchar = _getcharPtr.asFunction<int Function()>();

  int getc_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getc_unlocked(
      __stream,
    );
  }

  late final _getc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'getc_unlocked');
  late final _getc_unlocked =
      _getc_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar_unlocked() {
    return _getchar_unlocked();
  }

  late final _getchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar_unlocked');
  late final _getchar_unlocked =
      _getchar_unlockedPtr.asFunction<int Function()>();

  int fgetc_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgetc_unlocked(
      __stream,
    );
  }

  late final _fgetc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fgetc_unlocked');
  late final _fgetc_unlocked =
      _fgetc_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fputc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputc(
      __c,
      __stream,
    );
  }

  late final _fputcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc');
  late final _fputc =
      _fputcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putc(
      __c,
      __stream,
    );
  }

  late final _putcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc');
  late final _putc =
      _putcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar(
    int __c,
  ) {
    return _putchar(
      __c,
    );
  }

  late final _putcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('putchar');
  late final _putchar = _putcharPtr.asFunction<int Function(int)>();

  int fputc_unlocked(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputc_unlocked(
      __c,
      __stream,
    );
  }

  late final _fputc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc_unlocked');
  late final _fputc_unlocked =
      _fputc_unlockedPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putc_unlocked(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putc_unlocked(
      __c,
      __stream,
    );
  }

  late final _putc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc_unlocked');
  late final _putc_unlocked =
      _putc_unlockedPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar_unlocked(
    int __c,
  ) {
    return _putchar_unlocked(
      __c,
    );
  }

  late final _putchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'putchar_unlocked');
  late final _putchar_unlocked =
      _putchar_unlockedPtr.asFunction<int Function(int)>();

  int getw(
    ffi.Pointer<FILE> __stream,
  ) {
    return _getw(
      __stream,
    );
  }

  late final _getwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getw');
  late final _getw = _getwPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int putw(
    int __w,
    ffi.Pointer<FILE> __stream,
  ) {
    return _putw(
      __w,
      __stream,
    );
  }

  late final _putwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putw');
  late final _putw =
      _putwPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  ffi.Pointer<ffi.Char> fgets(
    ffi.Pointer<ffi.Char> __s,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fgets(
      __s,
      __n,
      __stream,
    );
  }

  late final _fgetsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<FILE>)>>('fgets');
  late final _fgets = _fgetsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<FILE>)>();

  int __getdelim(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lineptr,
    ffi.Pointer<ffi.Size> __n,
    int __delimiter,
    ffi.Pointer<FILE> __stream,
  ) {
    return ___getdelim(
      __lineptr,
      __n,
      __delimiter,
      __stream,
    );
  }

  late final ___getdelimPtr = _lookup<
      ffi.NativeFunction<
          __ssize_t Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Int,
              ffi.Pointer<FILE>)>>('__getdelim');
  late final ___getdelim = ___getdelimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          int, ffi.Pointer<FILE>)>();

  int getdelim(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lineptr,
    ffi.Pointer<ffi.Size> __n,
    int __delimiter,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getdelim(
      __lineptr,
      __n,
      __delimiter,
      __stream,
    );
  }

  late final _getdelimPtr = _lookup<
      ffi.NativeFunction<
          __ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Int, ffi.Pointer<FILE>)>>('getdelim');
  late final _getdelim = _getdelimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          int, ffi.Pointer<FILE>)>();

  int getline(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lineptr,
    ffi.Pointer<ffi.Size> __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getline(
      __lineptr,
      __n,
      __stream,
    );
  }

  late final _getlinePtr = _lookup<
      ffi.NativeFunction<
          __ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Pointer<FILE>)>>('getline');
  late final _getline = _getlinePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          ffi.Pointer<FILE>)>();

  int fputs(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fputs(
      __s,
      __stream,
    );
  }

  late final _fputsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('fputs');
  late final _fputs = _fputsPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  int puts(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _puts(
      __s,
    );
  }

  late final _putsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'puts');
  late final _puts = _putsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int ungetc(
    int __c,
    ffi.Pointer<FILE> __stream,
  ) {
    return _ungetc(
      __c,
      __stream,
    );
  }

  late final _ungetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'ungetc');
  late final _ungetc =
      _ungetcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int fread(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fread(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _freadPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fread');
  late final _fread = _freadPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fwrite(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __s,
  ) {
    return _fwrite(
      __ptr,
      __size,
      __n,
      __s,
    );
  }

  late final _fwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fwrite');
  late final _fwrite = _fwritePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fread_unlocked(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fread_unlocked(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _fread_unlockedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fread_unlocked');
  late final _fread_unlocked = _fread_unlockedPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fwrite_unlocked(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __n,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fwrite_unlocked(
      __ptr,
      __size,
      __n,
      __stream,
    );
  }

  late final _fwrite_unlockedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fwrite_unlocked');
  late final _fwrite_unlocked = _fwrite_unlockedPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int fseek(
    ffi.Pointer<FILE> __stream,
    int __off,
    int __whence,
  ) {
    return _fseek(
      __stream,
      __off,
      __whence,
    );
  }

  late final _fseekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Long, ffi.Int)>>('fseek');
  late final _fseek =
      _fseekPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftell(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftell(
      __stream,
    );
  }

  late final _ftellPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<FILE>)>>(
          'ftell');
  late final _ftell = _ftellPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void rewind(
    ffi.Pointer<FILE> __stream,
  ) {
    return _rewind(
      __stream,
    );
  }

  late final _rewindPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'rewind');
  late final _rewind =
      _rewindPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fseeko(
    ffi.Pointer<FILE> __stream,
    int __off,
    int __whence,
  ) {
    return _fseeko(
      __stream,
      __off,
      __whence,
    );
  }

  late final _fseekoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, __off_t, ffi.Int)>>('fseeko');
  late final _fseeko =
      _fseekoPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftello(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftello(
      __stream,
    );
  }

  late final _ftelloPtr =
      _lookup<ffi.NativeFunction<__off_t Function(ffi.Pointer<FILE>)>>(
          'ftello');
  late final _ftello = _ftelloPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fgetpos(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<fpos_t> __pos,
  ) {
    return _fgetpos(
      __stream,
      __pos,
    );
  }

  late final _fgetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fgetpos');
  late final _fgetpos = _fgetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  int fsetpos(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<fpos_t> __pos,
  ) {
    return _fsetpos(
      __stream,
      __pos,
    );
  }

  late final _fsetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fsetpos');
  late final _fsetpos = _fsetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  void clearerr(
    ffi.Pointer<FILE> __stream,
  ) {
    return _clearerr(
      __stream,
    );
  }

  late final _clearerrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr');
  late final _clearerr =
      _clearerrPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int feof(
    ffi.Pointer<FILE> __stream,
  ) {
    return _feof(
      __stream,
    );
  }

  late final _feofPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('feof');
  late final _feof = _feofPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ferror(
      __stream,
    );
  }

  late final _ferrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror');
  late final _ferror = _ferrorPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void clearerr_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _clearerr_unlocked(
      __stream,
    );
  }

  late final _clearerr_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr_unlocked');
  late final _clearerr_unlocked =
      _clearerr_unlockedPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int feof_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _feof_unlocked(
      __stream,
    );
  }

  late final _feof_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'feof_unlocked');
  late final _feof_unlocked =
      _feof_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ferror_unlocked(
      __stream,
    );
  }

  late final _ferror_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror_unlocked');
  late final _ferror_unlocked =
      _ferror_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void perror(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _perror(
      __s,
    );
  }

  late final _perrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'perror');
  late final _perror =
      _perrorPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int fileno(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fileno(
      __stream,
    );
  }

  late final _filenoPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno');
  late final _fileno = _filenoPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fileno_unlocked(
    ffi.Pointer<FILE> __stream,
  ) {
    return _fileno_unlocked(
      __stream,
    );
  }

  late final _fileno_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno_unlocked');
  late final _fileno_unlocked =
      _fileno_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int pclose(
    ffi.Pointer<FILE> __stream,
  ) {
    return _pclose(
      __stream,
    );
  }

  late final _pclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'pclose');
  late final _pclose = _pclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> popen(
    ffi.Pointer<ffi.Char> __command,
    ffi.Pointer<ffi.Char> __modes,
  ) {
    return _popen(
      __command,
      __modes,
    );
  }

  late final _popenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('popen');
  late final _popen = _popenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctermid(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _ctermid(
      __s,
    );
  }

  late final _ctermidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('ctermid');
  late final _ctermid = _ctermidPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void flockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _flockfile(
      __stream,
    );
  }

  late final _flockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'flockfile');
  late final _flockfile =
      _flockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int ftrylockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftrylockfile(
      __stream,
    );
  }

  late final _ftrylockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ftrylockfile');
  late final _ftrylockfile =
      _ftrylockfilePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void funlockfile(
    ffi.Pointer<FILE> __stream,
  ) {
    return _funlockfile(
      __stream,
    );
  }

  late final _funlockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'funlockfile');
  late final _funlockfile =
      _funlockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int __uflow(
    ffi.Pointer<FILE> arg0,
  ) {
    return ___uflow(
      arg0,
    );
  }

  late final ___uflowPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '__uflow');
  late final ___uflow =
      ___uflowPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int __overflow(
    ffi.Pointer<FILE> arg0,
    int arg1,
  ) {
    return ___overflow(
      arg0,
      arg1,
    );
  }

  late final ___overflowPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>, ffi.Int)>>(
          '__overflow');
  late final ___overflow =
      ___overflowPtr.asFunction<int Function(ffi.Pointer<FILE>, int)>();

  void __assert_fail(
    ffi.Pointer<ffi.Char> __assertion,
    ffi.Pointer<ffi.Char> __file,
    int __line,
    ffi.Pointer<ffi.Char> __function,
  ) {
    return ___assert_fail(
      __assertion,
      __file,
      __line,
      __function,
    );
  }

  late final ___assert_failPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>)>>('__assert_fail');
  late final ___assert_fail = ___assert_failPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Char>)>();

  void __assert_perror_fail(
    int __errnum,
    ffi.Pointer<ffi.Char> __file,
    int __line,
    ffi.Pointer<ffi.Char> __function,
  ) {
    return ___assert_perror_fail(
      __errnum,
      __file,
      __line,
      __function,
    );
  }

  late final ___assert_perror_failPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('__assert_perror_fail');
  late final ___assert_perror_fail = ___assert_perror_failPtr.asFunction<
      void Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  void __assert(
    ffi.Pointer<ffi.Char> __assertion,
    ffi.Pointer<ffi.Char> __file,
    int __line,
  ) {
    return ___assert(
      __assertion,
      __file,
      __line,
    );
  }

  late final ___assertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('__assert');
  late final ___assert = ___assertPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int __ctype_get_mb_cur_max() {
    return ___ctype_get_mb_cur_max();
  }

  late final ___ctype_get_mb_cur_maxPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          '__ctype_get_mb_cur_max');
  late final ___ctype_get_mb_cur_max =
      ___ctype_get_mb_cur_maxPtr.asFunction<int Function()>();

  double atof(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atof(
      __nptr,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atoi(
      __nptr,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atol(
      __nptr,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atoll(
      __nptr,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double strtod(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  ) {
    return _strtod(
      __nptr,
      __endptr,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  ) {
    return _strtof(
      __nptr,
      __endptr,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  ffi.Pointer<ffi.Char> l64a(
    int __n,
  ) {
    return _l64a(
      __n,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _a64l(
      __s,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int select(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timeval> __timeout,
  ) {
    return _select(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
    );
  }

  late final _selectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>>('select');
  late final _select = _selectPtr.asFunction<
      int Function(int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>();

  int pselect(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timespec> __timeout,
    ffi.Pointer<__sigset_t> __sigmask,
  ) {
    return _pselect(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
      __sigmask,
    );
  }

  late final _pselectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<timespec>,
              ffi.Pointer<__sigset_t>)>>('pselect');
  late final _pselect = _pselectPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>,
          ffi.Pointer<timespec>,
          ffi.Pointer<__sigset_t>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  void srandom(
    int __seed,
  ) {
    return _srandom(
      __seed,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int __seed,
    ffi.Pointer<ffi.Char> __statebuf,
    int __statelen,
  ) {
    return _initstate(
      __seed,
      __statebuf,
      __statelen,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> __statebuf,
  ) {
    return _setstate(
      __statebuf,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int random_r(
    ffi.Pointer<random_data> __buf,
    ffi.Pointer<ffi.Int32> __result,
  ) {
    return _random_r(
      __buf,
      __result,
    );
  }

  late final _random_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<random_data>, ffi.Pointer<ffi.Int32>)>>('random_r');
  late final _random_r = _random_rPtr.asFunction<
      int Function(ffi.Pointer<random_data>, ffi.Pointer<ffi.Int32>)>();

  int srandom_r(
    int __seed,
    ffi.Pointer<random_data> __buf,
  ) {
    return _srandom_r(
      __seed,
      __buf,
    );
  }

  late final _srandom_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<random_data>)>>('srandom_r');
  late final _srandom_r =
      _srandom_rPtr.asFunction<int Function(int, ffi.Pointer<random_data>)>();

  int initstate_r(
    int __seed,
    ffi.Pointer<ffi.Char> __statebuf,
    int __statelen,
    ffi.Pointer<random_data> __buf,
  ) {
    return _initstate_r(
      __seed,
      __statebuf,
      __statelen,
      __buf,
    );
  }

  late final _initstate_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<random_data>)>>('initstate_r');
  late final _initstate_r = _initstate_rPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<random_data>)>();

  int setstate_r(
    ffi.Pointer<ffi.Char> __statebuf,
    ffi.Pointer<random_data> __buf,
  ) {
    return _setstate_r(
      __statebuf,
      __buf,
    );
  }

  late final _setstate_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<random_data>)>>('setstate_r');
  late final _setstate_r = _setstate_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<random_data>)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(
    int __seed,
  ) {
    return _srand(
      __seed,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> __seed,
  ) {
    return _rand_r(
      __seed,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _erand48(
      __xsubi,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _nrand48(
      __xsubi,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _jrand48(
      __xsubi,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  void srand48(
    int __seedval,
  ) {
    return _srand48(
      __seedval,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> __seed16v,
  ) {
    return _seed48(
      __seed16v,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> __param,
  ) {
    return _lcong48(
      __param,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int drand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _drand48_r(
      __buffer,
      __result,
    );
  }

  late final _drand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<drand48_data>,
              ffi.Pointer<ffi.Double>)>>('drand48_r');
  late final _drand48_r = _drand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Double>)>();

  int erand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _erand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _erand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>,
              ffi.Pointer<ffi.Double>)>>('erand48_r');
  late final _erand48_r = _erand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Double>)>();

  int lrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _lrand48_r(
      __buffer,
      __result,
    );
  }

  late final _lrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('lrand48_r');
  late final _lrand48_r = _lrand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>();

  int nrand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _nrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _nrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('nrand48_r');
  late final _nrand48_r = _nrand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Long>)>();

  int mrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _mrand48_r(
      __buffer,
      __result,
    );
  }

  late final _mrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('mrand48_r');
  late final _mrand48_r = _mrand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>();

  int jrand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _jrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _jrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('jrand48_r');
  late final _jrand48_r = _jrand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Long>)>();

  int srand48_r(
    int __seedval,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _srand48_r(
      __seedval,
      __buffer,
    );
  }

  late final _srand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Long, ffi.Pointer<drand48_data>)>>('srand48_r');
  late final _srand48_r =
      _srand48_rPtr.asFunction<int Function(int, ffi.Pointer<drand48_data>)>();

  int seed48_r(
    ffi.Pointer<ffi.UnsignedShort> __seed16v,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _seed48_r(
      __seed16v,
      __buffer,
    );
  }

  late final _seed48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>)>>('seed48_r');
  late final _seed48_r = _seed48_rPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>)>();

  int lcong48_r(
    ffi.Pointer<ffi.UnsignedShort> __param,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _lcong48_r(
      __param,
      __buffer,
    );
  }

  late final _lcong48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>)>>('lcong48_r');
  late final _lcong48_r = _lcong48_rPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __nmemb,
    int __size,
  ) {
    return _calloc(
      __nmemb,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void free(
    ffi.Pointer<ffi.Void> __ptr,
  ) {
    return _free(
      __ptr,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> reallocarray(
    ffi.Pointer<ffi.Void> __ptr,
    int __nmemb,
    int __size,
  ) {
    return _reallocarray(
      __ptr,
      __nmemb,
      __size,
    );
  }

  late final _reallocarrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>>('reallocarray');
  late final _reallocarray = _reallocarrayPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> alloca(
    int __size,
  ) {
    return _alloca(
      __size,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> __func,
  ) {
    return _atexit(
      __func,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> __func,
  ) {
    return _at_quick_exit(
      __func,
    );
  }

  late final _at_quick_exitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>(
      'at_quick_exit');
  late final _at_quick_exit = _at_quick_exitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int on_exit(
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Int __status, ffi.Pointer<ffi.Void> __arg)>>
        __func,
    ffi.Pointer<ffi.Void> __arg,
  ) {
    return _on_exit(
      __func,
      __arg,
    );
  }

  late final _on_exitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Int __status, ffi.Pointer<ffi.Void> __arg)>>,
              ffi.Pointer<ffi.Void>)>>('on_exit');
  late final _on_exit = _on_exitPtr.asFunction<
      int Function(
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Int __status, ffi.Pointer<ffi.Void> __arg)>>,
          ffi.Pointer<ffi.Void>)>();

  void exit(
    int __status,
  ) {
    return _exit(
      __status,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  void quick_exit(
    int __status,
  ) {
    return _quick_exit(
      __status,
    );
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  void _Exit(
    int __status,
  ) {
    return __Exit(
      __status,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _getenv(
      __name,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int putenv(
    ffi.Pointer<ffi.Char> __string,
  ) {
    return _putenv(
      __string,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __replace,
  ) {
    return _setenv(
      __name,
      __value,
      __replace,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _unsetenv(
      __name,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int clearenv() {
    return _clearenv();
  }

  late final _clearenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('clearenv');
  late final _clearenv = _clearenvPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mktemp(
      __template,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mkstemp(
      __template,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mkstemps(
    ffi.Pointer<ffi.Char> __template,
    int __suffixlen,
  ) {
    return _mkstemps(
      __template,
      __suffixlen,
    );
  }

  late final _mkstempsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'mkstemps');
  late final _mkstemps =
      _mkstempsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> mkdtemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mkdtemp(
      __template,
    );
  }

  late final _mkdtempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mkdtemp');
  late final _mkdtemp = _mkdtempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int system(
    ffi.Pointer<ffi.Char> __command,
  ) {
    return _system(
      __command,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __resolved,
  ) {
    return _realpath(
      __name,
      __resolved,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    __compar_fn_t __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              __compar_fn_t)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int, __compar_fn_t)>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    __compar_fn_t __compar,
  ) {
    return _qsort(
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              __compar_fn_t)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int, int, __compar_fn_t)>();

  int abs(
    int __x,
  ) {
    return _abs(
      __x,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int labs(
    int __x,
  ) {
    return _labs(
      __x,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  int llabs(
    int __x,
  ) {
    return _llabs(
      __x,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  div_t div(
    int __numer,
    int __denom,
  ) {
    return _div(
      __numer,
      __denom,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  ldiv_t ldiv(
    int __numer,
    int __denom,
  ) {
    return _ldiv(
      __numer,
      __denom,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  lldiv_t lldiv(
    int __numer,
    int __denom,
  ) {
    return _lldiv(
      __numer,
      __denom,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  ffi.Pointer<ffi.Char> ecvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
  ) {
    return _ecvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
  ) {
    return _fcvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _gcvt(
      __value,
      __ndigit,
      __buf,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int ecvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _ecvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _ecvt_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Double,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('ecvt_r');
  late final _ecvt_r = _ecvt_rPtr.asFunction<
      int Function(double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>, int)>();

  int fcvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _fcvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _fcvt_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Double,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('fcvt_r');
  late final _fcvt_r = _fcvt_rPtr.asFunction<
      int Function(double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>, int)>();

  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> __pwc,
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mbtowc(
      __pwc,
      __s,
      __n,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> __s,
    int __wchar,
  ) {
    return _wctomb(
      __s,
      __wchar,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> __pwcs,
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mbstowcs(
      __pwcs,
      __s,
      __n,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.WChar> __pwcs,
    int __n,
  ) {
    return _wcstombs(
      __s,
      __pwcs,
      __n,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> __response,
  ) {
    return _rpmatch(
      __response,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __optionp,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __tokens,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __valuep,
  ) {
    return _getsubopt(
      __optionp,
      __tokens,
      __valuep,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> __loadavg,
    int __nelem,
  ) {
    return _getloadavg(
      __loadavg,
      __nelem,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  ffi.Pointer<ffi.Void> memcpy(
    ffi.Pointer<ffi.Void> __dest,
    ffi.Pointer<ffi.Void> __src,
    int __n,
  ) {
    return _memcpy(
      __dest,
      __src,
      __n,
    );
  }

  late final _memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memcpy');
  late final _memcpy = _memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memmove(
    ffi.Pointer<ffi.Void> __dest,
    ffi.Pointer<ffi.Void> __src,
    int __n,
  ) {
    return _memmove(
      __dest,
      __src,
      __n,
    );
  }

  late final _memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmove');
  late final _memmove = _memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memccpy(
    ffi.Pointer<ffi.Void> __dest,
    ffi.Pointer<ffi.Void> __src,
    int __c,
    int __n,
  ) {
    return _memccpy(
      __dest,
      __src,
      __c,
      __n,
    );
  }

  late final _memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memccpy');
  late final _memccpy = _memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> memset(
    ffi.Pointer<ffi.Void> __s,
    int __c,
    int __n,
  ) {
    return _memset(
      __s,
      __c,
      __n,
    );
  }

  late final _memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memset');
  late final _memset = _memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  int memcmp(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return _memcmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memcmp');
  late final _memcmp = _memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int __memcmpeq(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return ___memcmpeq(
      __s1,
      __s2,
      __n,
    );
  }

  late final ___memcmpeqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('__memcmpeq');
  late final ___memcmpeq = ___memcmpeqPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memchr(
    ffi.Pointer<ffi.Void> __s,
    int __c,
    int __n,
  ) {
    return _memchr(
      __s,
      __c,
      __n,
    );
  }

  late final _memchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memchr');
  late final _memchr = _memchrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strcpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _strcpy(
      __dest,
      __src,
    );
  }

  late final _strcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcpy');
  late final _strcpy = _strcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strncpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strncpy(
      __dest,
      __src,
      __n,
    );
  }

  late final _strncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncpy');
  late final _strncpy = _strncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strcat(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _strcat(
      __dest,
      __src,
    );
  }

  late final _strcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcat');
  late final _strcat = _strcatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strncat(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strncat(
      __dest,
      __src,
      __n,
    );
  }

  late final _strncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncat');
  late final _strncat = _strncatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcmp(
      __s1,
      __s2,
    );
  }

  late final _strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmp');
  late final _strcmp = _strcmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strncmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncmp');
  late final _strncmp = _strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcoll(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcoll(
      __s1,
      __s2,
    );
  }

  late final _strcollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcoll');
  late final _strcoll = _strcollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strxfrm(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strxfrm(
      __dest,
      __src,
      __n,
    );
  }

  late final _strxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strxfrm');
  late final _strxfrm = _strxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcoll_l(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    locale_t __l,
  ) {
    return _strcoll_l(
      __s1,
      __s2,
      __l,
    );
  }

  late final _strcoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              locale_t)>>('strcoll_l');
  late final _strcoll_l = _strcoll_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, locale_t)>();

  int strxfrm_l(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
    locale_t __l,
  ) {
    return _strxfrm_l(
      __dest,
      __src,
      __n,
      __l,
    );
  }

  late final _strxfrm_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, locale_t)>>('strxfrm_l');
  late final _strxfrm_l = _strxfrm_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, locale_t)>();

  ffi.Pointer<ffi.Char> strdup(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _strdup(
      __s,
    );
  }

  late final _strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strdup');
  late final _strdup = _strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strndup(
    ffi.Pointer<ffi.Char> __string,
    int __n,
  ) {
    return _strndup(
      __string,
      __n,
    );
  }

  late final _strndupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strndup');
  late final _strndup = _strndupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strchr(
      __s,
      __c,
    );
  }

  late final _strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strchr');
  late final _strchr = _strchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strrchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strrchr(
      __s,
      __c,
    );
  }

  late final _strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strrchr');
  late final _strrchr = _strrchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strcspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __reject,
  ) {
    return _strcspn(
      __s,
      __reject,
    );
  }

  late final _strcspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcspn');
  late final _strcspn = _strcspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __accept,
  ) {
    return _strspn(
      __s,
      __accept,
    );
  }

  late final _strspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strspn');
  late final _strspn = _strspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strpbrk(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __accept,
  ) {
    return _strpbrk(
      __s,
      __accept,
    );
  }

  late final _strpbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strpbrk');
  late final _strpbrk = _strpbrkPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strstr(
    ffi.Pointer<ffi.Char> __haystack,
    ffi.Pointer<ffi.Char> __needle,
  ) {
    return _strstr(
      __haystack,
      __needle,
    );
  }

  late final _strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strstr');
  late final _strstr = _strstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strtok(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __delim,
  ) {
    return _strtok(
      __s,
      __delim,
    );
  }

  late final _strtokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strtok');
  late final _strtok = _strtokPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> __strtok_r(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __delim,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __save_ptr,
  ) {
    return ___strtok_r(
      __s,
      __delim,
      __save_ptr,
    );
  }

  late final ___strtok_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('__strtok_r');
  late final ___strtok_r = ___strtok_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  ffi.Pointer<ffi.Char> strtok_r(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __delim,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __save_ptr,
  ) {
    return _strtok_r(
      __s,
      __delim,
      __save_ptr,
    );
  }

  late final _strtok_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtok_r');
  late final _strtok_r = _strtok_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strlen(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _strlen(
      __s,
    );
  }

  late final _strlenPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>)>>(
      'strlen');
  late final _strlen =
      _strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int strnlen(
    ffi.Pointer<ffi.Char> __string,
    int __maxlen,
  ) {
    return _strnlen(
      __string,
      __maxlen,
    );
  }

  late final _strnlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('strnlen');
  late final _strnlen =
      _strnlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strerror(
    int __errnum,
  ) {
    return _strerror(
      __errnum,
    );
  }

  late final _strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strerror');
  late final _strerror =
      _strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int strerror_r(
    int __errnum,
    ffi.Pointer<ffi.Char> __buf,
    int __buflen,
  ) {
    return _strerror_r(
      __errnum,
      __buf,
      __buflen,
    );
  }

  late final _strerror_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strerror_r');
  late final _strerror_r = _strerror_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strerror_l(
    int __errnum,
    locale_t __l,
  ) {
    return _strerror_l(
      __errnum,
      __l,
    );
  }

  late final _strerror_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Int, locale_t)>>('strerror_l');
  late final _strerror_l = _strerror_lPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, locale_t)>();

  int bcmp(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return _bcmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Size)>>('bcmp');
  late final _bcmp = _bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bcopy(
    ffi.Pointer<ffi.Void> __src,
    ffi.Pointer<ffi.Void> __dest,
    int __n,
  ) {
    return _bcopy(
      __src,
      __dest,
      __n,
    );
  }

  late final _bcopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('bcopy');
  late final _bcopy = _bcopyPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bzero(
    ffi.Pointer<ffi.Void> __s,
    int __n,
  ) {
    return _bzero(
      __s,
      __n,
    );
  }

  late final _bzeroPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>('bzero');
  late final _bzero =
      _bzeroPtr.asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> index(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _index(
      __s,
      __c,
    );
  }

  late final _indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('index');
  late final _index = _indexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> rindex(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _rindex(
      __s,
      __c,
    );
  }

  late final _rindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('rindex');
  late final _rindex = _rindexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int ffs(
    int __i,
  ) {
    return _ffs(
      __i,
    );
  }

  late final _ffsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('ffs');
  late final _ffs = _ffsPtr.asFunction<int Function(int)>();

  int ffsl(
    int __l,
  ) {
    return _ffsl(
      __l,
    );
  }

  late final _ffslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('ffsl');
  late final _ffsl = _ffslPtr.asFunction<int Function(int)>();

  int ffsll(
    int __ll,
  ) {
    return _ffsll(
      __ll,
    );
  }

  late final _ffsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('ffsll');
  late final _ffsll = _ffsllPtr.asFunction<int Function(int)>();

  int strcasecmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcasecmp(
      __s1,
      __s2,
    );
  }

  late final _strcasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasecmp');
  late final _strcasecmp = _strcasecmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strncasecmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncasecmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncasecmp');
  late final _strncasecmp = _strncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strcasecmp_l(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    locale_t __loc,
  ) {
    return _strcasecmp_l(
      __s1,
      __s2,
      __loc,
    );
  }

  late final _strcasecmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              locale_t)>>('strcasecmp_l');
  late final _strcasecmp_l = _strcasecmp_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, locale_t)>();

  int strncasecmp_l(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
    locale_t __loc,
  ) {
    return _strncasecmp_l(
      __s1,
      __s2,
      __n,
      __loc,
    );
  }

  late final _strncasecmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, locale_t)>>('strncasecmp_l');
  late final _strncasecmp_l = _strncasecmp_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, locale_t)>();

  void explicit_bzero(
    ffi.Pointer<ffi.Void> __s,
    int __n,
  ) {
    return _explicit_bzero(
      __s,
      __n,
    );
  }

  late final _explicit_bzeroPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>(
      'explicit_bzero');
  late final _explicit_bzero = _explicit_bzeroPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> strsep(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __stringp,
    ffi.Pointer<ffi.Char> __delim,
  ) {
    return _strsep(
      __stringp,
      __delim,
    );
  }

  late final _strsepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('strsep');
  late final _strsep = _strsepPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strsignal(
    int __sig,
  ) {
    return _strsignal(
      __sig,
    );
  }

  late final _strsignalPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strsignal');
  late final _strsignal =
      _strsignalPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<ffi.Char> __stpcpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return ___stpcpy(
      __dest,
      __src,
    );
  }

  late final ___stpcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('__stpcpy');
  late final ___stpcpy = ___stpcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> stpcpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _stpcpy(
      __dest,
      __src,
    );
  }

  late final _stpcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('stpcpy');
  late final _stpcpy = _stpcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> __stpncpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return ___stpncpy(
      __dest,
      __src,
      __n,
    );
  }

  late final ___stpncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('__stpncpy');
  late final ___stpncpy = ___stpncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> stpncpy(
    ffi.Pointer<ffi.Char> __dest,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _stpncpy(
      __dest,
      __src,
      __n,
    );
  }

  late final _stpncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('stpncpy');
  late final _stpncpy = _stpncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Format a string.
  /// /**
  ///  * This function just wraps snprintf() as defined in C11 in a portable way.
  ///  *
  ///  * On Windows this defaults to the _TRUNCATE behavior of _snprintf_s(), but
  ///  * only returns -1 if errno is not 0.
  ///  * Unlike _snprintf_s() which returns -1 when truncation occurs, this function
  ///  * behaves like snprintf() (http://en.cppreference.com/w/cpp/io/c/fprintf):
  ///  *
  ///  * > Number of characters written if successful or negative value if an error
  ///  * > occurred.
  ///  * > If the resulting string gets truncated due to buf_size limit, function
  ///  * > returns the total number of characters (not including the terminating
  ///  * > null-byte) which would have been written, if the limit was not imposed.
  ///  *
  ///  * If `NULL` and `0` are given for buffer and buffer_size respectively, the
  ///  * size of the string that would be generated is returned.
  ///  * Either snprintf() or _vscprintf() is used to calculate this value.
  ///  *
  ///  * \see snprintf()
  ///  * \see _snprintf_s()
  ///  * \return the number of bytes that would have been written given enough space, or
  ///  * \return a negative number if there is an error, but unlike _snprintf_s(),
  ///  *   -1 is not returned if there is truncation.
  ///  */
  int rcutils_snprintf(
    ffi.Pointer<ffi.Char> buffer,
    int buffer_size,
    ffi.Pointer<ffi.Char> format,
  ) {
    return _rcutils_snprintf(
      buffer,
      buffer_size,
      format,
    );
  }

  late final _rcutils_snprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('rcutils_snprintf');
  late final _rcutils_snprintf = _rcutils_snprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Format a string with va_list for arguments, see rcutils_snprintf().
  int rcutils_vsnprintf(
    ffi.Pointer<ffi.Char> buffer,
    int buffer_size,
    ffi.Pointer<ffi.Char> format,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return _rcutils_vsnprintf(
      buffer,
      buffer_size,
      format,
      args,
    );
  }

  late final _rcutils_vsnprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('rcutils_vsnprintf');
  late final _rcutils_vsnprintf = _rcutils_vsnprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<__va_list_tag>)>();

  bool rcutils_fault_injection_is_test_complete() {
    return _rcutils_fault_injection_is_test_complete();
  }

  late final _rcutils_fault_injection_is_test_completePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'rcutils_fault_injection_is_test_complete');
  late final _rcutils_fault_injection_is_test_complete =
      _rcutils_fault_injection_is_test_completePtr
          .asFunction<bool Function()>();

  /// \brief Atomically set the fault injection counter.
  ///
  /// This is typically not the preferred method of interacting directly with the fault injection
  /// logic, instead use `RCUTILS_FAULT_INJECTION_TEST` instead.
  ///
  /// This function may also be used for pausing code inside of a `RCUTILS_FAULT_INJECTION_TEST` with
  /// something like the following:
  ///
  /// RCUTILS_FAULT_INJECTION_TEST({
  /// ...  // code to run with fault injection
  /// int64_t count = rcutils_fault_injection_get_count();
  /// rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL);
  /// ...  // code to run without fault injection
  /// rcutils_fault_injection_set_count(count);
  /// ...  // code to run with fault injection
  /// });
  ///
  /// \param count The count to set the fault injection counter to. If count is negative, then fault
  /// injection errors will be disabled. The counter is globally initialized to
  /// RCUTILS_FAULT_INJECTION_NEVER_FAIL.
  void rcutils_fault_injection_set_count(
    int count,
  ) {
    return _rcutils_fault_injection_set_count(
      count,
    );
  }

  late final _rcutils_fault_injection_set_countPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(int_least64_t)>>(
          'rcutils_fault_injection_set_count');
  late final _rcutils_fault_injection_set_count =
      _rcutils_fault_injection_set_countPtr.asFunction<void Function(int)>();

  /// \brief Atomically get the fault injection counter value
  ///
  /// This function is typically not used directly but instead indirectly inside an
  /// `RCUTILS_FAULT_INJECTION_TEST`
  int rcutils_fault_injection_get_count() {
    return _rcutils_fault_injection_get_count();
  }

  late final _rcutils_fault_injection_get_countPtr =
      _lookup<ffi.NativeFunction<int_least64_t Function()>>(
          'rcutils_fault_injection_get_count');
  late final _rcutils_fault_injection_get_count =
      _rcutils_fault_injection_get_countPtr.asFunction<int Function()>();

  /// \brief Implementation of fault injection decrementer
  ///
  /// This is included inside of macros, so it needs to be exported as a public function, but it
  /// should not be used directly.
  int _rcutils_fault_injection_maybe_fail() {
    return __rcutils_fault_injection_maybe_fail();
  }

  late final __rcutils_fault_injection_maybe_failPtr =
      _lookup<ffi.NativeFunction<int_least64_t Function()>>(
          '_rcutils_fault_injection_maybe_fail');
  late final __rcutils_fault_injection_maybe_fail =
      __rcutils_fault_injection_maybe_failPtr.asFunction<int Function()>();

  /// Forces initialization of thread-local storage if called in a newly created thread.
  /// /**
  ///  * If this function is not called beforehand, then the first time the error
  ///  * state is set or the first time the error message is retrieved, the default
  ///  * allocator will be used to allocate thread-local storage.
  ///  *
  ///  * This function may or may not allocate memory.
  ///  * The system's thread-local storage implementation may need to allocate
  ///  * memory, since it usually has no way of knowing how much storage is needed
  ///  * without knowing how many threads will be created.
  ///  * Most implementations (e.g. C11, C++11, and pthread) do not have ways to
  ///  * specify how this memory is allocated, but if the implementation allows, the
  ///  * given allocator to this function will be used, but is otherwise unused.
  ///  * This only occurs when creating and destroying threads, which can be avoided
  ///  * in the "steady" state by reusing pools of threads.
  ///  *
  ///  * It is worth considering that repeated thread creation and destruction will
  ///  * result in repeated memory allocations and could result in memory
  ///  * fragmentation.
  ///  * This is typically avoided anyways by using pools of threads.
  ///  *
  ///  * In case an error is indicated by the return code, no error message will have
  ///  * been set.
  ///  *
  ///  * If called more than once in a thread, or after implicitly initialized by
  ///  * setting the error state, it will still return `RCUTILS_RET_OK`, even
  ///  * if the given allocator is invalid.
  ///  * Essentially this function does nothing if thread-local storage has already
  ///  * been called.
  ///  * If already initialized, the given allocator is ignored, even if it does not
  ///  * match the allocator used originally to initialize the thread-local storage.
  ///  *
  ///  * \param[in] allocator to be used to allocate and deallocate memory
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if the allocator is invalid, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if allocating memory fails, or
  ///  * \return #RCUTILS_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcutils_initialize_error_handling_thread_local_storage(
    rcutils_allocator_t allocator,
  ) {
    return _rcutils_initialize_error_handling_thread_local_storage(
      allocator,
    );
  }

  late final _rcutils_initialize_error_handling_thread_local_storagePtr =
      _lookup<ffi.NativeFunction<rcutils_ret_t Function(rcutils_allocator_t)>>(
          'rcutils_initialize_error_handling_thread_local_storage');
  late final _rcutils_initialize_error_handling_thread_local_storage =
      _rcutils_initialize_error_handling_thread_local_storagePtr
          .asFunction<int Function(rcutils_allocator_t)>();

  /// Set the error message, as well as the file and line on which it occurred.
  /// /**
  ///  * This is not meant to be used directly, but instead via the
  ///  * RCUTILS_SET_ERROR_MSG(msg) macro.
  ///  *
  ///  * The error_msg parameter is copied into the internal error storage and must
  ///  * be null terminated.
  ///  * The file parameter is copied into the internal error storage and must
  ///  * be null terminated.
  ///  *
  ///  * \param[in] error_string The error message to set.
  ///  * \param[in] file The path to the file in which the error occurred.
  ///  * \param[in] line_number The line number on which the error occurred.
  ///  */
  void rcutils_set_error_state(
    ffi.Pointer<ffi.Char> error_string,
    ffi.Pointer<ffi.Char> file,
    int line_number,
  ) {
    return _rcutils_set_error_state(
      error_string,
      file,
      line_number,
    );
  }

  late final _rcutils_set_error_statePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('rcutils_set_error_state');
  late final _rcutils_set_error_state = _rcutils_set_error_statePtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Return `true` if the error is set, otherwise `false`.
  bool rcutils_error_is_set() {
    return _rcutils_error_is_set();
  }

  late final _rcutils_error_is_setPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('rcutils_error_is_set');
  late final _rcutils_error_is_set =
      _rcutils_error_is_setPtr.asFunction<bool Function()>();

  /// Return an rcutils_error_state_t which was set with rcutils_set_error_state().
  /// /**
  ///  * The returned pointer will be NULL if no error has been set in this thread.
  ///  *
  ///  * The returned pointer is valid until RCUTILS_SET_ERROR_MSG, rcutils_set_error_state,
  ///  * or rcutils_reset_error are called in the same thread.
  ///  *
  ///  * \return A pointer to the current error state struct.
  ///  */
  ffi.Pointer<rcutils_error_state_t> rcutils_get_error_state() {
    return _rcutils_get_error_state();
  }

  late final _rcutils_get_error_statePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<rcutils_error_state_t> Function()>>(
      'rcutils_get_error_state');
  late final _rcutils_get_error_state = _rcutils_get_error_statePtr
      .asFunction<ffi.Pointer<rcutils_error_state_t> Function()>();

  /// Return the error message followed by `, at <file>:<line>` if set, else "error not set".
  /// /**
  ///  * This function is "safe" because it returns a copy of the current error
  ///  * string or one containing the string "error not set" if no error was set.
  ///  * This ensures that the copy is owned by the calling thread and is therefore
  ///  * never invalidated by other error handling calls, and that the C string
  ///  * inside is always valid and null terminated.
  ///  *
  ///  * \return The current error string, with file and line number, or "error not set" if not set.
  ///  */
  rcutils_error_string_t rcutils_get_error_string() {
    return _rcutils_get_error_string();
  }

  late final _rcutils_get_error_stringPtr =
      _lookup<ffi.NativeFunction<rcutils_error_string_t Function()>>(
          'rcutils_get_error_string');
  late final _rcutils_get_error_string = _rcutils_get_error_stringPtr
      .asFunction<rcutils_error_string_t Function()>();

  /// Reset the error state by clearing any previously set error state.
  void rcutils_reset_error() {
    return _rcutils_reset_error();
  }

  late final _rcutils_reset_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('rcutils_reset_error');
  late final _rcutils_reset_error =
      _rcutils_reset_errorPtr.asFunction<void Function()>();

  /// Return an empty array_list struct.
  /// /**
  ///  * This function returns an empty and zero initialized array_list struct.
  ///  * Calling rcutils_array_list_fini() on any non-initialized instance leads
  ///  * to undefined behavior.
  ///  * Every instance of array_list_t has to either be zero_initialized with this
  ///  * function or manually allocated.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * rcutils_array_list_t foo;
  ///  * rcutils_array_list_fini(&foo); // undefined behavior!
  ///  *
  ///  * rcutils_array_list_t bar = rcutils_get_zero_initialized_array_list();
  ///  * rcutils_array_list_fini(&bar); // ok
  ///  * ```
  ///  */
  rcutils_array_list_t rcutils_get_zero_initialized_array_list() {
    return _rcutils_get_zero_initialized_array_list();
  }

  late final _rcutils_get_zero_initialized_array_listPtr =
      _lookup<ffi.NativeFunction<rcutils_array_list_t Function()>>(
          'rcutils_get_zero_initialized_array_list');
  late final _rcutils_get_zero_initialized_array_list =
      _rcutils_get_zero_initialized_array_listPtr
          .asFunction<rcutils_array_list_t Function()>();

  /// Initialize an array list with a given initial capacity.
  /// /**
  ///  * This function will initialize a given, zero initialized, array_list to
  ///  * a given size.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * rcutils_allocator_t allocator = rcutils_get_default_allocator();
  ///  * rcutils_array_list_t array_list = rcutils_get_zero_initialized_array_list();
  ///  * rcutils_ret_t ret = rcutils_array_list_init(&array_list, 2, sizeof(int), &allocator);
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... error handling
  ///  * }
  ///  * int data = 42;
  ///  * int out_data = 0;
  ///  * ret = rcutils_array_list_add(&array_list, &data);
  ///  * data++;
  ///  * ret = rcutils_array_list_get(&array_list, 0, &out_data);
  ///  * assert(42 == out_data);
  ///  * ret = rcutils_array_list_fini(&array_list);
  ///  * ```
  ///  *
  ///  * \param[inout] array_list object to be initialized
  ///  * \param[in] initial_capacity the initial capacity to allocate in the list
  ///  * \param[in] data_size the size (in bytes) of the data object being stored in the list
  ///  * \param[in] allocator to be used to allocate and deallocate memory
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_array_list_init(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int initial_capacity,
    int data_size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_array_list_init(
      array_list,
      initial_capacity,
      data_size,
      allocator,
    );
  }

  late final _rcutils_array_list_initPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_array_list_t>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<rcutils_allocator_t>)>>('rcutils_array_list_init');
  late final _rcutils_array_list_init = _rcutils_array_list_initPtr.asFunction<
      int Function(ffi.Pointer<rcutils_array_list_t>, int, int,
          ffi.Pointer<rcutils_allocator_t>)>();

  /// Finalize an array list, reclaiming all resources.
  /// /**
  ///  * This function reclaims any memory owned by the array list.
  ///  *
  ///  * The allocator used to initialize the array list is used to deallocate each
  ///  * entry in the list and the list itself.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] array_list object to be finalized
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_array_list_fini(
    ffi.Pointer<rcutils_array_list_t> array_list,
  ) {
    return _rcutils_array_list_fini(
      array_list,
    );
  }

  late final _rcutils_array_list_finiPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_array_list_t>)>>('rcutils_array_list_fini');
  late final _rcutils_array_list_fini = _rcutils_array_list_finiPtr
      .asFunction<int Function(ffi.Pointer<rcutils_array_list_t>)>();

  /// Adds an entry to the list
  /// /**
  ///  * This function adds the provided data to the end of the list. A shallow copy of
  ///  * the provided data is made to store in the list instead of just storing
  ///  * the pointer to the provided data.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] array_list to add the data to
  ///  * \param[in] data a pointer to the data to add to the list
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_array_list_add(
    ffi.Pointer<rcutils_array_list_t> array_list,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _rcutils_array_list_add(
      array_list,
      data,
    );
  }

  late final _rcutils_array_list_addPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_array_list_t>,
              ffi.Pointer<ffi.Void>)>>('rcutils_array_list_add');
  late final _rcutils_array_list_add = _rcutils_array_list_addPtr.asFunction<
      int Function(ffi.Pointer<rcutils_array_list_t>, ffi.Pointer<ffi.Void>)>();

  /// Sets an entry in the list to the provided data
  /// /**
  ///  * This function sets the provided data at the specified index in the list.
  ///  * A shallow copy of the provided data is made to store in the list instead
  ///  * of just storing the pointer to the provided data.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] array_list to add the data to
  ///  * \param[in] index the position in the list to set the data
  ///  * \param[in] data a pointer to the data that will be set in the list
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if index out of bounds, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_array_list_set(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int index,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _rcutils_array_list_set(
      array_list,
      index,
      data,
    );
  }

  late final _rcutils_array_list_setPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_array_list_t>, ffi.Size,
              ffi.Pointer<ffi.Void>)>>('rcutils_array_list_set');
  late final _rcutils_array_list_set = _rcutils_array_list_setPtr.asFunction<
      int Function(
          ffi.Pointer<rcutils_array_list_t>, int, ffi.Pointer<ffi.Void>)>();

  /// Removes an entry in the list at the provided index
  /// /**
  ///  * This function removes data from the list at the specified index. The capacity
  ///  * of the list will never decrease when entries are removed.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] array_list to add the data to
  ///  * \param[in] index the index of the item to remove from the list
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if index out of bounds, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_array_list_remove(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int index,
  ) {
    return _rcutils_array_list_remove(
      array_list,
      index,
    );
  }

  late final _rcutils_array_list_removePtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_array_list_t>,
              ffi.Size)>>('rcutils_array_list_remove');
  late final _rcutils_array_list_remove = _rcutils_array_list_removePtr
      .asFunction<int Function(ffi.Pointer<rcutils_array_list_t>, int)>();

  /// Retrieves an entry in the list at the provided index
  /// /**
  ///  * This function retrieves a copy of the data stored in the list at the provided index.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  *
  ///  * \param[in] array_list to add the data to
  ///  * \param[in] index the index at which to get the data
  ///  * \param[out] data a copy of the data stored in the list
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_array_list_get(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int index,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _rcutils_array_list_get(
      array_list,
      index,
      data,
    );
  }

  late final _rcutils_array_list_getPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_array_list_t>, ffi.Size,
              ffi.Pointer<ffi.Void>)>>('rcutils_array_list_get');
  late final _rcutils_array_list_get = _rcutils_array_list_getPtr.asFunction<
      int Function(
          ffi.Pointer<rcutils_array_list_t>, int, ffi.Pointer<ffi.Void>)>();

  /// Retrieves the size of the provided array_list
  /// /**
  ///  * This function retrieves the number of items in the provided array list
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  *
  ///  * \param[in] array_list list to get the size of
  ///  * \param[out] size The number of items currently stored in the list
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_array_list_get_size(
    ffi.Pointer<rcutils_array_list_t> array_list,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _rcutils_array_list_get_size(
      array_list,
      size,
    );
  }

  late final _rcutils_array_list_get_sizePtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_array_list_t>,
              ffi.Pointer<ffi.Size>)>>('rcutils_array_list_get_size');
  late final _rcutils_array_list_get_size =
      _rcutils_array_list_get_sizePtr.asFunction<
          int Function(
              ffi.Pointer<rcutils_array_list_t>, ffi.Pointer<ffi.Size>)>();

  /// Return a zero initialized char array struct.
  /// /**
  ///  * \return rcutils_char_array_t a zero initialized char array struct
  ///  */
  rcutils_char_array_t rcutils_get_zero_initialized_char_array() {
    return _rcutils_get_zero_initialized_char_array();
  }

  late final _rcutils_get_zero_initialized_char_arrayPtr =
      _lookup<ffi.NativeFunction<rcutils_char_array_t Function()>>(
          'rcutils_get_zero_initialized_char_array');
  late final _rcutils_get_zero_initialized_char_array =
      _rcutils_get_zero_initialized_char_arrayPtr
          .asFunction<rcutils_char_array_t Function()>();

  /// Initialize a zero initialized char array struct.
  /// /**
  ///  * This function may leak if the char array struct is already
  ///  * pre-initialized.
  ///  * If the capacity is set to 0, no memory is allocated and the internal buffer
  ///  * is still NULL.
  ///  *
  ///  * \param[in] char_array a pointer to the to be initialized char array struct
  ///  * \param[in] buffer_capacity the size of the memory to allocate for the byte stream
  ///  * \param[in] allocator the allocator to use for the memory allocation
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if no memory could be allocated correctly
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_char_array_init(
    ffi.Pointer<rcutils_char_array_t> char_array,
    int buffer_capacity,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_char_array_init(
      char_array,
      buffer_capacity,
      allocator,
    );
  }

  late final _rcutils_char_array_initPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_char_array_t>, ffi.Size,
              ffi.Pointer<rcutils_allocator_t>)>>('rcutils_char_array_init');
  late final _rcutils_char_array_init = _rcutils_char_array_initPtr.asFunction<
      int Function(ffi.Pointer<rcutils_char_array_t>, int,
          ffi.Pointer<rcutils_allocator_t>)>();

  /// Finalize a char array struct.
  /// /**
  ///  * Cleans up and deallocates any resources owned by rcutils_char_array_t.
  ///  * The array passed to this function needs to have been initialized by
  ///  * rcutils_char_array_init().
  ///  * If .owns_buffer is false, this function has no effect because that
  ///  * implies that the char_array does not own the internal buffer.
  ///  * Passing an uninitialized instance to this function leads to undefined
  ///  * behavior.
  ///  *
  ///  * \param[in] char_array pointer to the rcutils_char_array_t to be cleaned up
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if the char_array argument is invalid
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_char_array_fini(
    ffi.Pointer<rcutils_char_array_t> char_array,
  ) {
    return _rcutils_char_array_fini(
      char_array,
    );
  }

  late final _rcutils_char_array_finiPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_char_array_t>)>>('rcutils_char_array_fini');
  late final _rcutils_char_array_fini = _rcutils_char_array_finiPtr
      .asFunction<int Function(ffi.Pointer<rcutils_char_array_t>)>();

  /// Resize the internal buffer of the char array.
  /// /**
  ///  * The internal buffer of the char array can be resized dynamically if needed.
  ///  * If the new size is smaller than the current capacity, then the memory is
  ///  * truncated.
  ///  * Be aware, that this will deallocate the memory and therefore invalidates any
  ///  * pointers to this storage.
  ///  * If the new size is larger, new memory is getting allocated and the existing
  ///  * content is copied over.
  ///  * Note that if the array doesn't own the current buffer the function just
  ///  * allocates a new block of memory and copies the contents of the old buffer
  ///  * instead of resizing the existing buffer.
  ///  *
  ///  * \param[in] char_array pointer to the instance of rcutils_char_array_t which is being resized
  ///  * \param[in] new_size the new size of the internal buffer
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if new_size is set to zero
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_char_array_resize(
    ffi.Pointer<rcutils_char_array_t> char_array,
    int new_size,
  ) {
    return _rcutils_char_array_resize(
      char_array,
      new_size,
    );
  }

  late final _rcutils_char_array_resizePtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_char_array_t>,
              ffi.Size)>>('rcutils_char_array_resize');
  late final _rcutils_char_array_resize = _rcutils_char_array_resizePtr
      .asFunction<int Function(ffi.Pointer<rcutils_char_array_t>, int)>();

  /// Expand the internal buffer of the char array.
  /// /**
  ///  * This function is equivalent to `rcutils_char_array_resize` except that it resizes
  ///  * the internal buffer only when it is not big enough.
  ///  * If the buffer is already big enough for `new_size`, it returns `RCUTILS_RET_OK` without
  ///  * doing anything.
  ///  *
  ///  * \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being resized
  ///  * \param[in] new_size the new size of the internal buffer
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_char_array_expand_as_needed(
    ffi.Pointer<rcutils_char_array_t> char_array,
    int new_size,
  ) {
    return _rcutils_char_array_expand_as_needed(
      char_array,
      new_size,
    );
  }

  late final _rcutils_char_array_expand_as_neededPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_char_array_t>,
              ffi.Size)>>('rcutils_char_array_expand_as_needed');
  late final _rcutils_char_array_expand_as_needed =
      _rcutils_char_array_expand_as_neededPtr
          .asFunction<int Function(ffi.Pointer<rcutils_char_array_t>, int)>();

  /// Produce output according to format and args.
  /// /**
  ///  * This function is equivalent to `vsprintf(char_array->buffer, format, args)`
  ///  * except that the buffer grows as needed so a user doesn't have to deal with
  ///  * memory management.
  ///  * The `va_list args` will be cloned before being used, so a user can safely
  ///  * use it again after calling this function.
  ///  *
  ///  * \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being
  ///  * written to
  ///  * \param[in] format the format string used by the underlying `vsnprintf`
  ///  * \param[in] args the `va_list` used by the underlying `vsnprintf`
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_char_array_vsprintf(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Char> format,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return _rcutils_char_array_vsprintf(
      char_array,
      format,
      args,
    );
  }

  late final _rcutils_char_array_vsprintfPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_char_array_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>>('rcutils_char_array_vsprintf');
  late final _rcutils_char_array_vsprintf =
      _rcutils_char_array_vsprintfPtr.asFunction<
          int Function(ffi.Pointer<rcutils_char_array_t>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<__va_list_tag>)>();

  /// Append a string (or part of it) to the string in buffer.
  /// /**
  ///  * This function treats the internal buffer as a string and appends the src string to it.
  ///  * If src is longer than n, n bytes will be used and an extra null byte will be appended.
  ///  * It is virtually equivalent to `strncat(char_array->buffer, src, n)` except that the buffer
  ///  * grows as needed so a user doesn't have to deal with memory management.
  ///  *
  ///  * \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being appended to
  ///  * \param[in] src the string to be appended to the end of the string in buffer
  ///  * \param[in] n it uses at most n bytes from the src string
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_char_array_strncat(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Char> src,
    int n,
  ) {
    return _rcutils_char_array_strncat(
      char_array,
      src,
      n,
    );
  }

  late final _rcutils_char_array_strncatPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_char_array_t>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('rcutils_char_array_strncat');
  late final _rcutils_char_array_strncat =
      _rcutils_char_array_strncatPtr.asFunction<
          int Function(
              ffi.Pointer<rcutils_char_array_t>, ffi.Pointer<ffi.Char>, int)>();

  /// Append a string to the string in buffer.
  /// /**
  ///  * This function treats the internal buffer as a string and appends the src string to it.
  ///  * It is virtually equivalent to `strcat(char_array->buffer, src)` except that the buffer
  ///  * grows as needed. That is to say, a user can safely use it without doing calculation or
  ///  * checks on the sizes of the src and buffer.
  ///  *
  ///  * \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being
  ///  * appended to
  ///  * \param[in] src the string to be appended to the end of the string in buffer
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_char_array_strcat(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Char> src,
  ) {
    return _rcutils_char_array_strcat(
      char_array,
      src,
    );
  }

  late final _rcutils_char_array_strcatPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_char_array_t>,
              ffi.Pointer<ffi.Char>)>>('rcutils_char_array_strcat');
  late final _rcutils_char_array_strcat =
      _rcutils_char_array_strcatPtr.asFunction<
          int Function(
              ffi.Pointer<rcutils_char_array_t>, ffi.Pointer<ffi.Char>)>();

  /// Copy memory to buffer.
  /// /**
  ///  * This function is equivalent to `memcpy(char_array->buffer, src, n)` except that the buffer
  ///  * grows as needed so a user doesn't have to worry about overflow.
  ///  *
  ///  * \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being resized
  ///  * \param[in] src the memory to be copied from
  ///  * \param[in] n a total of n bytes will be copied
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_char_array_memcpy(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Char> src,
    int n,
  ) {
    return _rcutils_char_array_memcpy(
      char_array,
      src,
      n,
    );
  }

  late final _rcutils_char_array_memcpyPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_char_array_t>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('rcutils_char_array_memcpy');
  late final _rcutils_char_array_memcpy =
      _rcutils_char_array_memcpyPtr.asFunction<
          int Function(
              ffi.Pointer<rcutils_char_array_t>, ffi.Pointer<ffi.Char>, int)>();

  /// Copy a string to buffer.
  /// /**
  ///  * This function is equivalent to `strcpy(char_array->buffer, src)` except that the buffer
  ///  * grows as needed so that `src` will fit without overflow.
  ///  *
  ///  * \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being
  ///  * copied to
  ///  * \param[in] src the string to be copied from
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_char_array_strcpy(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Char> src,
  ) {
    return _rcutils_char_array_strcpy(
      char_array,
      src,
    );
  }

  late final _rcutils_char_array_strcpyPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_char_array_t>,
              ffi.Pointer<ffi.Char>)>>('rcutils_char_array_strcpy');
  late final _rcutils_char_array_strcpy =
      _rcutils_char_array_strcpyPtr.asFunction<
          int Function(
              ffi.Pointer<rcutils_char_array_t>, ffi.Pointer<ffi.Char>)>();

  /// A hashing function for a null terminated c string.
  /// /**
  ///  * A hashing function for a null terminated c string.
  ///  * Should be used when your key is just a pointer to a c-string
  ///  */
  int rcutils_hash_map_string_hash_func(
    ffi.Pointer<ffi.Void> key_str,
  ) {
    return _rcutils_hash_map_string_hash_func(
      key_str,
    );
  }

  late final _rcutils_hash_map_string_hash_funcPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Void>)>>(
          'rcutils_hash_map_string_hash_func');
  late final _rcutils_hash_map_string_hash_func =
      _rcutils_hash_map_string_hash_funcPtr
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// A comparison function for a null terminated c string.
  /// /**
  ///  * A comparison function for a null terminated c string.
  ///  * Should be used when your key is just a pointer to a c-string
  ///  */
  int rcutils_hash_map_string_cmp_func(
    ffi.Pointer<ffi.Void> val1,
    ffi.Pointer<ffi.Void> val2,
  ) {
    return _rcutils_hash_map_string_cmp_func(
      val1,
      val2,
    );
  }

  late final _rcutils_hash_map_string_cmp_funcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('rcutils_hash_map_string_cmp_func');
  late final _rcutils_hash_map_string_cmp_func =
      _rcutils_hash_map_string_cmp_funcPtr.asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// Return an empty hash_map struct.
  /// /**
  ///  * This function returns an empty and zero initialized hash_map struct.
  ///  * All hash maps should be initialized with this or manually initialized
  ///  * before being used.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * Example:
  ///  * ```c
  ///  * // Do not do this:
  ///  * // rcutils_hash_map_t foo;
  ///  * // rcutils_hash_map_fini(&foo); // undefined behavior!
  ///  *
  ///  * // Do this instead:
  ///  * rcutils_hash_map_t bar = rcutils_get_zero_initialized_hash_map();
  ///  * rcutils_hash_map_fini(&bar); // ok
  ///  * ```
  ///  * */
  rcutils_hash_map_t rcutils_get_zero_initialized_hash_map() {
    return _rcutils_get_zero_initialized_hash_map();
  }

  late final _rcutils_get_zero_initialized_hash_mapPtr =
      _lookup<ffi.NativeFunction<rcutils_hash_map_t Function()>>(
          'rcutils_get_zero_initialized_hash_map');
  late final _rcutils_get_zero_initialized_hash_map =
      _rcutils_get_zero_initialized_hash_mapPtr
          .asFunction<rcutils_hash_map_t Function()>();

  /// Initialize a rcutils_hash_map_t, allocating space for given capacity.
  /// /**
  ///  * This function initializes the rcutils_hash_map_t with a given initial
  ///  * capacity for entries.
  ///  * Note this does not allocate space for keys or values in the hash_map, just the
  ///  * arrays of pointers to the keys and values.
  ///  * rcutils_hash_map_set() should still be used when assigning values.
  ///  *
  ///  * The hash_map argument should point to allocated memory and should have
  ///  * been zero initialized with rcutils_get_zero_initialized_hash_map().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * Example:
  ///  * ```c
  ///  * rcutils_hash_map_t hash_map = rcutils_get_zero_initialized_hash_map();
  ///  * rcutils_ret_t ret =
  ///  *   rcutils_hash_map_init(&hash_map, 10, rcutils_get_default_allocator());
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... do error handling
  ///  * }
  ///  * // ... use the hash_map and when done:
  ///  * ret = rcutils_hash_map_fini(&hash_map);
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... do error handling
  ///  * }
  ///  * ```
  ///  *
  ///  * \param[inout] hash_map rcutils_hash_map_t to be initialized
  ///  * \param[in] initial_capacity the amount of initial capacity for the hash_map
  ///  * \param[in] key_size the size (in bytes) of the key used to index the data
  ///  * \param[in] data_size the size (in bytes) of the data being stored
  ///  * \param[in] key_hashing_func a function that returns a hashed value for a key
  ///  * \param[in] key_cmp_func a function used to compare keys
  ///  * \param[in] allocator the allocator to use through out the lifetime of the hash_map
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or
  ///  * \return #RCUTILS_RET_STRING_MAP_ALREADY_INIT if alread initialized, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_hash_map_init(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    int initial_capacity,
    int key_size,
    int data_size,
    rcutils_hash_map_key_hasher_t key_hashing_func,
    rcutils_hash_map_key_cmp_t key_cmp_func,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_hash_map_init(
      hash_map,
      initial_capacity,
      key_size,
      data_size,
      key_hashing_func,
      key_cmp_func,
      allocator,
    );
  }

  late final _rcutils_hash_map_initPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_hash_map_t>,
              ffi.Size,
              ffi.Size,
              ffi.Size,
              rcutils_hash_map_key_hasher_t,
              rcutils_hash_map_key_cmp_t,
              ffi.Pointer<rcutils_allocator_t>)>>('rcutils_hash_map_init');
  late final _rcutils_hash_map_init = _rcutils_hash_map_initPtr.asFunction<
      int Function(
          ffi.Pointer<rcutils_hash_map_t>,
          int,
          int,
          int,
          rcutils_hash_map_key_hasher_t,
          rcutils_hash_map_key_cmp_t,
          ffi.Pointer<rcutils_allocator_t>)>();

  /// Finalize the previously initialized hash_map struct.
  /// /**
  ///  * This function will free any resources which were created when initializing
  ///  * or when calling rcutils_hash_map_set().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] hash_map rcutils_hash_map_t to be finalized
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_hash_map_fini(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
  ) {
    return _rcutils_hash_map_fini(
      hash_map,
    );
  }

  late final _rcutils_hash_map_finiPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_hash_map_t>)>>('rcutils_hash_map_fini');
  late final _rcutils_hash_map_fini = _rcutils_hash_map_finiPtr
      .asFunction<int Function(ffi.Pointer<rcutils_hash_map_t>)>();

  /// Get the current capacity of the hash_map.
  /// /**
  ///  * This function will return the internal capacity of the hash_map, which is the
  ///  * number of buckets the hash_map uses to sort the keys.
  ///  * The capacity does not indicate how many key value pairs are stored in the
  ///  * hash_map, the rcutils_hash_map_get_size() function can provide that, nor the
  ///  * maximum number that can be stored without increasing the capacity.
  ///  * The capacity can be set initially with rcutils_hash_map_init().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] hash_map rcutils_hash_map_t to be queried
  ///  * \param[out] capacity capacity of the hash_map
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_hash_map_get_capacity(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Size> capacity,
  ) {
    return _rcutils_hash_map_get_capacity(
      hash_map,
      capacity,
    );
  }

  late final _rcutils_hash_map_get_capacityPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_hash_map_t>,
              ffi.Pointer<ffi.Size>)>>('rcutils_hash_map_get_capacity');
  late final _rcutils_hash_map_get_capacity =
      _rcutils_hash_map_get_capacityPtr.asFunction<
          int Function(
              ffi.Pointer<rcutils_hash_map_t>, ffi.Pointer<ffi.Size>)>();

  /// Get the current size of the hash_map.
  /// /**
  ///  * This function will return the internal size of the hash_map, which is the
  ///  * current number of key value pairs in the hash_map.
  ///  * The size is changed when calling rcutils_hash_map_set() or rcutils_hash_map_unset().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] hash_map rcutils_hash_map_t to be queried
  ///  * \param[out] size size of the hash_map
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_hash_map_get_size(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _rcutils_hash_map_get_size(
      hash_map,
      size,
    );
  }

  late final _rcutils_hash_map_get_sizePtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_hash_map_t>,
              ffi.Pointer<ffi.Size>)>>('rcutils_hash_map_get_size');
  late final _rcutils_hash_map_get_size =
      _rcutils_hash_map_get_sizePtr.asFunction<
          int Function(
              ffi.Pointer<rcutils_hash_map_t>, ffi.Pointer<ffi.Size>)>();

  /// Set a key value pair in the hash_map, increasing capacity if necessary.
  /// /**
  ///  * If the key already exists in the map then the value is updated to the new value
  ///  * provided. If it does not already exist then a new entry is added for the new key
  ///  * and value. The capacity will be increased if needed.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] hash_map rcutils_hash_map_t to be updated
  ///  * \param[in] key hash_map key
  ///  * \param[in] value value for given hash_map key
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or
  ///  * \return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_hash_map_set(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _rcutils_hash_map_set(
      hash_map,
      key,
      value,
    );
  }

  late final _rcutils_hash_map_setPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_hash_map_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('rcutils_hash_map_set');
  late final _rcutils_hash_map_set = _rcutils_hash_map_setPtr.asFunction<
      int Function(ffi.Pointer<rcutils_hash_map_t>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>)>();

  /// Unset a key value pair in the hash_map.
  /// /**
  ///  * Unsets the key value pair in the hash_map and frees any internal resources allocated
  ///  * for the entry. This function will never decrease the capacity when removing keys.
  ///  * If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] hash_map rcutils_hash_map_t to be updated
  ///  * \param[in] key hash_map key, must be null terminated c string
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or
  ///  * \return #RCUTILS_RET_STRING_KEY_NOT_FOUND if the key is not found in the map, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_hash_map_unset(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
  ) {
    return _rcutils_hash_map_unset(
      hash_map,
      key,
    );
  }

  late final _rcutils_hash_map_unsetPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_hash_map_t>,
              ffi.Pointer<ffi.Void>)>>('rcutils_hash_map_unset');
  late final _rcutils_hash_map_unset = _rcutils_hash_map_unsetPtr.asFunction<
      int Function(ffi.Pointer<rcutils_hash_map_t>, ffi.Pointer<ffi.Void>)>();

  /// Get whether or not a key exists.
  /// /**
  ///  * Returns true if the provided key exists in the hash_map or false if it does not or
  ///  * if the hash_map or key are invalid.
  ///  * In all cases no error message is set.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] hash_map rcutils_hash_map_t to be searched
  ///  * \param[in] key hash_map key, must be null terminated c string
  ///  * \return `true` if key is in the hash_map, or
  ///  * \return `false` if key is not in the hash_map, or
  ///  * \return `false` for invalid arguments, or
  ///  * \return `false` if the hash_map is invalid.
  ///  */
  bool rcutils_hash_map_key_exists(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
  ) {
    return _rcutils_hash_map_key_exists(
      hash_map,
      key,
    );
  }

  late final _rcutils_hash_map_key_existsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<rcutils_hash_map_t>,
              ffi.Pointer<ffi.Void>)>>('rcutils_hash_map_key_exists');
  late final _rcutils_hash_map_key_exists =
      _rcutils_hash_map_key_existsPtr.asFunction<
          bool Function(
              ffi.Pointer<rcutils_hash_map_t>, ffi.Pointer<ffi.Void>)>();

  /// Get value given a key.
  /// /**
  ///  * This function can be used to retrieve a shallow copy of the stored data. The data
  ///  * pointer must point to a section of memory large enough to copy the full size of
  ///  * the data being stored, which is specified when the hash_map in initialized.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] hash_map rcutils_hash_map_t to be searched
  ///  * \param[in] key hash_map key to look up the data for
  ///  * \param[out] data A copy of the data stored in the map
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or
  ///  * \return #RCUTILS_RET_NOT_FOUND if the key doesn't exist in the map, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_hash_map_get(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _rcutils_hash_map_get(
      hash_map,
      key,
      data,
    );
  }

  late final _rcutils_hash_map_getPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_hash_map_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('rcutils_hash_map_get');
  late final _rcutils_hash_map_get = _rcutils_hash_map_getPtr.asFunction<
      int Function(ffi.Pointer<rcutils_hash_map_t>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>)>();

  /// Get the next key in the hash_map, unless NULL is given, then get the first key.
  /// /**
  ///  * This function allows you to iteratively get each key/value pair in the hash_map.
  ///  *
  ///  * If NULL is given for the previous_key, then the first key in the hash_map is returned.
  ///  * If that returned key is given as the previous_key for the next call to this function,
  ///  * then the next key in the hash_map is returned.
  ///  * If there are no more keys in the hash_map or if the given key is not in the hash_map,
  ///  * an error will be returned.
  ///  *
  ///  * The order of the keys in the hash_map is arbitrary and if the hash_map is modified
  ///  * between calls to this function the behavior is undefined.
  ///  * If the hash_map is modified then iteration should begin again by passing NULL to
  ///  * get the first key again.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * Example:
  ///  * ```c
  ///  * printf("entries in the hash_map:\n");
  ///  * int key = 0, data = 0;
  ///  * rcutils_ret_t status = rcutils_hash_map_get_next_key(&hash_map, NULL, &key, &data);
  ///  * while (RCUTILS_RET_OK == status) {
  ///  *   printf("%i: %i\n", key, data);
  ///  *   status = rcutils_hash_map_get_next_key(&hash_map, &key, &key, &data);
  ///  * }
  ///  * ```
  ///  *
  ///  * \param[in] hash_map rcutils_hash_map_t to be queried
  ///  * \param[in] previous_key NULL to get the first key or the previous key to get the next for
  ///  * \param[out] key A copy of the next key in the sequence
  ///  * \param[out] data A copy of the next data in the sequence
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_NOT_INITIALIZED if the hash_map is invalid, or
  ///  * \return #RCUTILS_RET_NOT_FOUND if the previous_key doesn't exist in the map, or
  ///  * \return #RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES if there is no more data beyound the previous_key, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_hash_map_get_next_key_and_data(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> previous_key,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _rcutils_hash_map_get_next_key_and_data(
      hash_map,
      previous_key,
      key,
      data,
    );
  }

  late final _rcutils_hash_map_get_next_key_and_dataPtr = _lookup<
          ffi.NativeFunction<
              rcutils_ret_t Function(
                  ffi.Pointer<rcutils_hash_map_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>(
      'rcutils_hash_map_get_next_key_and_data');
  late final _rcutils_hash_map_get_next_key_and_data =
      _rcutils_hash_map_get_next_key_and_dataPtr.asFunction<
          int Function(ffi.Pointer<rcutils_hash_map_t>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// Interface to qsort with rcutils-style argument validation.
  /// /**
  ///  * This function changes the order of the elements in the array so that they
  ///  * are in ascending order according to the given comparison function.
  ///  *
  ///  * This function is thread-safe.
  ///  *
  ///  * \param[inout] ptr object whose elements should be sorted.
  ///  * \param[in] count number of elements present in the object.
  ///  * \param[in] size size of each element, in bytes.
  ///  * \param[in] comp function used to compare two elements.
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_qsort(
    ffi.Pointer<ffi.Void> ptr,
    int count,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        comp,
  ) {
    return _rcutils_qsort(
      ptr,
      count,
      size,
      comp,
    );
  }

  late final _rcutils_qsortPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('rcutils_qsort');
  late final _rcutils_qsort = _rcutils_qsortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  /// Return an empty string array struct.
  /// /**
  ///  * This function returns an empty and zero initialized string array struct.
  ///  * Calling rcutils_string_array_fini() on any non-initialized instance leads
  ///  * to undefined behavior.
  ///  * Every instance of string_array_t has to either be zero_initialized with this
  ///  * function or manually allocated.
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * rcutils_string_array_t foo;
  ///  * rcutils_string_array_fini(&foo); // undefined behavior!
  ///  *
  ///  * rcutils_string_array_t bar = rcutils_get_zero_initialized_string_array();
  ///  * rcutils_string_array_fini(&bar); // ok
  ///  * ```
  ///  */
  rcutils_string_array_t rcutils_get_zero_initialized_string_array() {
    return _rcutils_get_zero_initialized_string_array();
  }

  late final _rcutils_get_zero_initialized_string_arrayPtr =
      _lookup<ffi.NativeFunction<rcutils_string_array_t Function()>>(
          'rcutils_get_zero_initialized_string_array');
  late final _rcutils_get_zero_initialized_string_array =
      _rcutils_get_zero_initialized_string_arrayPtr
          .asFunction<rcutils_string_array_t Function()>();

  /// Initialize a string array with a given size.
  /// /**
  ///  * This function will initialize a given, zero initialized, string array to
  ///  * a given size.
  ///  *
  ///  * Note that putting a string into the array gives owenship to the array.
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * rcutils_allocator_t allocator = rcutils_get_default_allocator();
  ///  * rcutils_string_array_t string_array = rcutils_get_zero_initialized_string_array();
  ///  * rcutils_ret_t ret = rcutils_string_array_init(&string_array, 2, &allocator);
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... error handling
  ///  * }
  ///  * string_array.data[0] = rcutils_strdup("Hello", &allocator);
  ///  * string_array.data[1] = rcutils_strdup("World", &allocator);
  ///  * ret = rcutils_string_array_fini(&string_array);
  ///  * ```
  ///  *
  ///  * \param[inout] string_array object to be initialized
  ///  * \param[in] size the size the array should be
  ///  * \param[in] allocator to be used to allocate and deallocate memory
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_array_init(
    ffi.Pointer<rcutils_string_array_t> string_array,
    int size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_string_array_init(
      string_array,
      size,
      allocator,
    );
  }

  late final _rcutils_string_array_initPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_string_array_t>, ffi.Size,
              ffi.Pointer<rcutils_allocator_t>)>>('rcutils_string_array_init');
  late final _rcutils_string_array_init =
      _rcutils_string_array_initPtr.asFunction<
          int Function(ffi.Pointer<rcutils_string_array_t>, int,
              ffi.Pointer<rcutils_allocator_t>)>();

  /// Finalize a string array, reclaiming all resources.
  /// /**
  ///  * This function reclaims any memory owned by the string array, including the
  ///  * strings it references.
  ///  *
  ///  * The allocator used to initialize the string array is used to deallocate each
  ///  * string in the array and the array of strings itself.
  ///  *
  ///  * \param[inout] string_array object to be finalized
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_array_fini(
    ffi.Pointer<rcutils_string_array_t> string_array,
  ) {
    return _rcutils_string_array_fini(
      string_array,
    );
  }

  late final _rcutils_string_array_finiPtr = _lookup<
          ffi.NativeFunction<
              rcutils_ret_t Function(ffi.Pointer<rcutils_string_array_t>)>>(
      'rcutils_string_array_fini');
  late final _rcutils_string_array_fini = _rcutils_string_array_finiPtr
      .asFunction<int Function(ffi.Pointer<rcutils_string_array_t>)>();

  /// Compare two string arrays.
  /// /**
  ///  * The two string arrays are compared according to lexicographical order.
  ///  *
  ///  * \param[in] lhs The first string array.
  ///  * \param[in] rhs The second string array.
  ///  * \param[out] res Negative value if `lhs` appears before `rhs` in lexicographical order.
  ///  *   Zero if `lhs` and `rhs` are equal.
  ///  *   Positive value if `lhs` appears after `rhs` in lexographical order.
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if any argument is `NULL, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if `lhs->data` or `rhs->data` is `NULL, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_array_cmp(
    ffi.Pointer<rcutils_string_array_t> lhs,
    ffi.Pointer<rcutils_string_array_t> rhs,
    ffi.Pointer<ffi.Int> res,
  ) {
    return _rcutils_string_array_cmp(
      lhs,
      rhs,
      res,
    );
  }

  late final _rcutils_string_array_cmpPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_string_array_t>,
              ffi.Pointer<rcutils_string_array_t>,
              ffi.Pointer<ffi.Int>)>>('rcutils_string_array_cmp');
  late final _rcutils_string_array_cmp =
      _rcutils_string_array_cmpPtr.asFunction<
          int Function(ffi.Pointer<rcutils_string_array_t>,
              ffi.Pointer<rcutils_string_array_t>, ffi.Pointer<ffi.Int>)>();

  /// Resize a string array, reclaiming removed resources.
  /// /**
  ///  * This function changes the size of an existing string array.
  ///  * If the new size is larger, new entries are added to the end of the array and
  ///  * are zero- initialized.
  ///  * If the new size is smaller, entries are removed from the end of the array
  ///  * and their resources reclaimed.
  ///  *
  ///  * \par Note:
  ///  * Resizing to 0 is not a substitute for calling ::rcutils_string_array_fini.
  ///  *
  ///  * \par Note:
  ///  * If this function fails, \p string_array remains unchanged and should still
  ///  * be reclaimed with ::rcutils_string_array_fini.
  ///  *
  ///  * \param[inout] string_array object to be resized.
  ///  * \param[in] new_size the size the array should be changed to.
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_array_resize(
    ffi.Pointer<rcutils_string_array_t> string_array,
    int new_size,
  ) {
    return _rcutils_string_array_resize(
      string_array,
      new_size,
    );
  }

  late final _rcutils_string_array_resizePtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_string_array_t>,
              ffi.Size)>>('rcutils_string_array_resize');
  late final _rcutils_string_array_resize = _rcutils_string_array_resizePtr
      .asFunction<int Function(ffi.Pointer<rcutils_string_array_t>, int)>();

  /// Lexicographic comparer for pointers to string pointers.
  /// /**
  ///  * This functions compares pointers to string pointers lexicographically
  ///  * ascending.
  ///  *
  ///  * \param[in] lhs pointer to the first string pointer.
  ///  * \param[in] rhs pointer to the second string pointer.
  ///  * \return <0 if lhs is lexicographically lower, or
  ///  * \return 0 if the strings are the same, or
  ///  * \return >0 if lhs is lexicographically higher.
  ///  */
  int rcutils_string_array_sort_compare(
    ffi.Pointer<ffi.Void> lhs,
    ffi.Pointer<ffi.Void> rhs,
  ) {
    return _rcutils_string_array_sort_compare(
      lhs,
      rhs,
    );
  }

  late final _rcutils_string_array_sort_comparePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('rcutils_string_array_sort_compare');
  late final _rcutils_string_array_sort_compare =
      _rcutils_string_array_sort_comparePtr.asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// Return an empty string map struct.
  /// /**
  ///  * This function returns an empty and zero initialized string map struct.
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * // Do not do this:
  ///  * // rcutils_string_map_t foo;
  ///  * // rcutils_string_map_fini(&foo); // undefined behavior!
  ///  *
  ///  * // Do this instead:
  ///  * rcutils_string_map_t bar = rcutils_get_zero_initialized_string_map();
  ///  * rcutils_string_map_fini(&bar); // ok
  ///  * ```
  ///  * */
  rcutils_string_map_t rcutils_get_zero_initialized_string_map() {
    return _rcutils_get_zero_initialized_string_map();
  }

  late final _rcutils_get_zero_initialized_string_mapPtr =
      _lookup<ffi.NativeFunction<rcutils_string_map_t Function()>>(
          'rcutils_get_zero_initialized_string_map');
  late final _rcutils_get_zero_initialized_string_map =
      _rcutils_get_zero_initialized_string_mapPtr
          .asFunction<rcutils_string_map_t Function()>();

  /// Initialize a rcutils_string_map_t, allocating space for given capacity.
  /// /**
  ///  * This function initializes the rcutils_string_map_t with a given initial
  ///  * capacity for entries.
  ///  * Note this does not allocate space for keys or values in the map, just the
  ///  * arrays of pointers to the keys and values.
  ///  * rcutils_string_map_set() should still be used when assigning values.
  ///  *
  ///  * The string_map argument should point to allocated memory and should have
  ///  * been zero initialized with rcutils_get_zero_initialized_string_map().
  ///  * For example:
  ///  *
  ///  * ```c
  ///  * rcutils_string_map_t string_map = rcutils_get_zero_initialized_string_map();
  ///  * rcutils_ret_t ret =
  ///  *   rcutils_string_map_init(&string_map, 10, rcutils_get_default_allocator());
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... do error handling
  ///  * }
  ///  * // ... use the string map and when done:
  ///  * ret = rcutils_string_map_fini(&string_map);
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... do error handling
  ///  * }
  ///  * ```
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be initialized
  ///  * \param[in] initial_capacity the amount of initial capacity for the string map
  ///  * \param[in] allocator the allocator to use through out the lifetime of the map
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or
  ///  * \return #RCUTILS_RET_STRING_MAP_ALREADY_INIT if already initialized, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_map_init(
    ffi.Pointer<rcutils_string_map_t> string_map,
    int initial_capacity,
    rcutils_allocator_t allocator,
  ) {
    return _rcutils_string_map_init(
      string_map,
      initial_capacity,
      allocator,
    );
  }

  late final _rcutils_string_map_initPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_string_map_t>, ffi.Size,
              rcutils_allocator_t)>>('rcutils_string_map_init');
  late final _rcutils_string_map_init = _rcutils_string_map_initPtr.asFunction<
      int Function(
          ffi.Pointer<rcutils_string_map_t>, int, rcutils_allocator_t)>();

  /// Finalize the previously initialized string map struct.
  /// /**
  ///  * This function will free any resources which were created when initializing
  ///  * or when calling rcutils_string_map_set().
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be finalized
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_map_fini(
    ffi.Pointer<rcutils_string_map_t> string_map,
  ) {
    return _rcutils_string_map_fini(
      string_map,
    );
  }

  late final _rcutils_string_map_finiPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_string_map_t>)>>('rcutils_string_map_fini');
  late final _rcutils_string_map_fini = _rcutils_string_map_finiPtr
      .asFunction<int Function(ffi.Pointer<rcutils_string_map_t>)>();

  /// Get the current capacity of the string map.
  /// /**
  ///  * This function will return the internal capacity of the map, which is the
  ///  * maximum number of key value pairs the map could hold.
  ///  * The capacity can be set initially with rcutils_string_map_init() or
  ///  * with rcutils_string_map_reserve().
  ///  * The capacity does not indicate how many key value paris are stored in the
  ///  * map, the rcutils_string_map_get_size() function can provide that.
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be queried
  ///  * \param[out] capacity capacity of the string map
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_map_get_capacity(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Size> capacity,
  ) {
    return _rcutils_string_map_get_capacity(
      string_map,
      capacity,
    );
  }

  late final _rcutils_string_map_get_capacityPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_string_map_t>,
              ffi.Pointer<ffi.Size>)>>('rcutils_string_map_get_capacity');
  late final _rcutils_string_map_get_capacity =
      _rcutils_string_map_get_capacityPtr.asFunction<
          int Function(
              ffi.Pointer<rcutils_string_map_t>, ffi.Pointer<ffi.Size>)>();

  /// Get the current size of the string map.
  /// /**
  ///  * This function will return the internal size of the map, which is the
  ///  * current number of key value pairs in the map.
  ///  * The size is changed when calling rcutils_string_map_set_no_resize(),
  ///  * rcutils_string_map_set(), or rcutils_string_map_unset().
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be queried
  ///  * \param[out] size size of the string map
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_map_get_size(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _rcutils_string_map_get_size(
      string_map,
      size,
    );
  }

  late final _rcutils_string_map_get_sizePtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_string_map_t>,
              ffi.Pointer<ffi.Size>)>>('rcutils_string_map_get_size');
  late final _rcutils_string_map_get_size =
      _rcutils_string_map_get_sizePtr.asFunction<
          int Function(
              ffi.Pointer<rcutils_string_map_t>, ffi.Pointer<ffi.Size>)>();

  /// Reserve a given amount of capacity in the map.
  /// /**
  ///  * Increases the capacity of the map to at least the given size.
  ///  *
  ///  * If the current capacity is less than requested capacity then the capacity
  ///  * is increased using the allocator given during initialization of the map in
  ///  * rcutils_string_map_init().
  ///  * If the requested capacity is less than the current capacity, the capacity
  ///  * may be reduced, but no existing key value pairs will be truncated to do so.
  ///  * In effect, the capacity will be shrunk to fit the number of items in map or
  ///  * the requested capacity, which ever is larger.
  ///  *
  ///  * If recovering all resources is desired first call rcutils_string_map_clear()
  ///  * and then this function with a capacity of 0.
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to have space reserved in
  ///  * \param[in] capacity requested size to reserve in the map
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or
  ///  * \return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_map_reserve(
    ffi.Pointer<rcutils_string_map_t> string_map,
    int capacity,
  ) {
    return _rcutils_string_map_reserve(
      string_map,
      capacity,
    );
  }

  late final _rcutils_string_map_reservePtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_string_map_t>,
              ffi.Size)>>('rcutils_string_map_reserve');
  late final _rcutils_string_map_reserve = _rcutils_string_map_reservePtr
      .asFunction<int Function(ffi.Pointer<rcutils_string_map_t>, int)>();

  /// Remove all key value pairs from the map.
  /// /**
  ///  * This function will remove all key value pairs from the map, and it will
  ///  * reclaim all resources allocated as a result of setting key value pairs.
  ///  * rcutils_string_map_fini() should still be called after this.
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be cleared
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_map_clear(
    ffi.Pointer<rcutils_string_map_t> string_map,
  ) {
    return _rcutils_string_map_clear(
      string_map,
    );
  }

  late final _rcutils_string_map_clearPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_string_map_t>)>>('rcutils_string_map_clear');
  late final _rcutils_string_map_clear = _rcutils_string_map_clearPtr
      .asFunction<int Function(ffi.Pointer<rcutils_string_map_t>)>();

  /// Set a key value pair in the map, increasing capacity if necessary.
  /// /**
  ///  * The capacity will be increased if needed using rcutils_string_map_reserve().
  ///  * Otherwise it is the same as rcutils_string_map_set_no_resize().
  ///  *
  ///  * \see rcutils_string_map_set_no_resize()
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be updated
  ///  * \param[in] key map key, must be null terminated c string
  ///  * \param[in] value value for given map key, must be null terminated c string
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or
  ///  * \return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_map_set(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _rcutils_string_map_set(
      string_map,
      key,
      value,
    );
  }

  late final _rcutils_string_map_setPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_string_map_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('rcutils_string_map_set');
  late final _rcutils_string_map_set = _rcutils_string_map_setPtr.asFunction<
      int Function(ffi.Pointer<rcutils_string_map_t>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Set a key value pair in the map but only if the map has enough capacity.
  /// /**
  ///  * If the map already contains the given key, the existing value will be
  ///  * replaced with the given value.
  ///  * If the map does not contain the given key, and the map has additional
  ///  * unused capacity, then it will store the given key and value in the map.
  ///  * If there is no unused capacity in the map, then RCUTILS_RET_NOT_ENOUGH_SPACE
  ///  * is returned.
  ///  *
  ///  * The given key and value c strings are copied into the map, and so storage is
  ///  * allocated for them in the map when this function is called if necessary.
  ///  * The storage allocated for this purpose is reclaimed either when
  ///  * rcutils_string_map_fini() is called on this map or when using this function
  ///  * or rcutils_string_map_unset().
  ///  *
  ///  * Any allocation that occurs in this functions uses the allocator of the map,
  ///  * which is given when the map is initialized in rcutils_string_map_init().
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be updated
  ///  * \param[in] key map key, must be null terminated c string
  ///  * \param[in] value value for given map key, must be null terminated c string
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or
  ///  * \return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or
  ///  * \return #RCUTILS_RET_NOT_ENOUGH_SPACE if map is full, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_map_set_no_resize(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _rcutils_string_map_set_no_resize(
      string_map,
      key,
      value,
    );
  }

  late final _rcutils_string_map_set_no_resizePtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_string_map_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('rcutils_string_map_set_no_resize');
  late final _rcutils_string_map_set_no_resize =
      _rcutils_string_map_set_no_resizePtr.asFunction<
          int Function(ffi.Pointer<rcutils_string_map_t>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Unset a key value pair in the map.
  /// /**
  ///  * The key needs to be a null terminated c string.
  ///  * If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be updated
  ///  * \param[in] key map key, must be null terminated c string
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or
  ///  * \return #RCUTILS_RET_STRING_KEY_NOT_FOUND if key not found, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_map_unset(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Char> key,
  ) {
    return _rcutils_string_map_unset(
      string_map,
      key,
    );
  }

  late final _rcutils_string_map_unsetPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_string_map_t>,
              ffi.Pointer<ffi.Char>)>>('rcutils_string_map_unset');
  late final _rcutils_string_map_unset =
      _rcutils_string_map_unsetPtr.asFunction<
          int Function(
              ffi.Pointer<rcutils_string_map_t>, ffi.Pointer<ffi.Char>)>();

  /// Get whether or not a key exists.
  /// /**
  ///  * The key needs to be a null terminated c string.
  ///  *
  ///  * This function can fail and return false if the key is not found,
  ///  * or the string_map is NULL or invalid, or if the key is NULL.
  ///  * In all cases no error message is set.
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be searched
  ///  * \param[in] key map key, must be null terminated c string
  ///  * \return `true` if key is in the map, or
  ///  * \return `false` if key is not in the map, or
  ///  * \return `false` for invalid arguments, or
  ///  * \return `false` if the string map is invalid.
  ///  */
  bool rcutils_string_map_key_exists(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Char> key,
  ) {
    return _rcutils_string_map_key_exists(
      string_map,
      key,
    );
  }

  late final _rcutils_string_map_key_existsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<rcutils_string_map_t>,
              ffi.Pointer<ffi.Char>)>>('rcutils_string_map_key_exists');
  late final _rcutils_string_map_key_exists =
      _rcutils_string_map_key_existsPtr.asFunction<
          bool Function(
              ffi.Pointer<rcutils_string_map_t>, ffi.Pointer<ffi.Char>)>();

  /// Get whether or not a key of known length exists.
  /// /**
  ///  * Identical to rcutils_string_map_key_exists() but without relying on key to be
  ///  * a null terminated c string.
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be searched
  ///  * \param[in] key map key
  ///  * \param[in] key_length map key length
  ///  * \return `true` if key is in the map, or
  ///  * \return `false` if key is not in the map, or
  ///  * \return `false` for invalid arguments, or
  ///  * \return `false` if the string map is invalid.
  ///  */
  bool rcutils_string_map_key_existsn(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Char> key,
    int key_length,
  ) {
    return _rcutils_string_map_key_existsn(
      string_map,
      key,
      key_length,
    );
  }

  late final _rcutils_string_map_key_existsnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<rcutils_string_map_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('rcutils_string_map_key_existsn');
  late final _rcutils_string_map_key_existsn =
      _rcutils_string_map_key_existsnPtr.asFunction<
          bool Function(
              ffi.Pointer<rcutils_string_map_t>, ffi.Pointer<ffi.Char>, int)>();

  /// Get value given a key.
  /// /**
  ///  * The key needs to be a null terminated c string.
  ///  *
  ///  * This function can fail, and therefore return NULL, if the key is not found,
  ///  * or the string_map is NULL or invalid, or if the key is NULL.
  ///  * In all cases no error message is set.
  ///  *
  ///  * The returned value string is still owned by the map, and it should not be
  ///  * modified or free'd.
  ///  * This also means that the value pointer becomes invalid if either
  ///  * rcutils_string_map_clear() or rcutils_string_map_fini() are called or if
  ///  * the key value pair is updated or removed with one of rcutils_string_map_set()
  ///  * or rcutils_string_map_set_no_resize() or rcutils_string_map_unset().
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be searched
  ///  * \param[in] key map key, must be null terminated c string
  ///  * \return value for the given key if successful, or
  ///  * \return `NULL` for invalid arguments, or
  ///  * \return `NULL` if the string map is invalid, or
  ///  * \return `NULL` if key not found, or
  ///  * \return `NULL` if an unknown error occurs.
  ///  */
  ffi.Pointer<ffi.Char> rcutils_string_map_get(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Char> key,
  ) {
    return _rcutils_string_map_get(
      string_map,
      key,
    );
  }

  late final _rcutils_string_map_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcutils_string_map_t>,
              ffi.Pointer<ffi.Char>)>>('rcutils_string_map_get');
  late final _rcutils_string_map_get = _rcutils_string_map_getPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<rcutils_string_map_t>, ffi.Pointer<ffi.Char>)>();

  /// Get value given a key and key length.
  /// /**
  ///  * Identical to rcutils_string_map_get() but without relying on key to be a
  ///  * null terminated c string.
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be searched
  ///  * \param[in] key map key
  ///  * \param[in] key_length map key length
  ///  * \return value for the given key if successful, or
  ///  * \return `NULL` for invalid arguments, or
  ///  * \return `NULL` if the string map is invalid, or
  ///  * \return `NULL` if key not found, or
  ///  * \return `NULL` if an unknown error occurs.
  ///  */
  ffi.Pointer<ffi.Char> rcutils_string_map_getn(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Char> key,
    int key_length,
  ) {
    return _rcutils_string_map_getn(
      string_map,
      key,
      key_length,
    );
  }

  late final _rcutils_string_map_getnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcutils_string_map_t>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('rcutils_string_map_getn');
  late final _rcutils_string_map_getn = _rcutils_string_map_getnPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<rcutils_string_map_t>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the next key in the map, unless NULL is given, then get the first key.
  /// /**
  ///  * This function allows you iteratively get each key in the map.
  ///  *
  ///  * If NULL is given for the key, then the first key in the map is returned.
  ///  * If that returned key if given to the this function, then the next key in the
  ///  * map is returned.
  ///  * If there are no more keys in the map or if the given key is not in the map,
  ///  * NULL is returned.
  ///  *
  ///  * The order of the keys in the map is arbitrary and if the map is modified
  ///  * between calls to this function the behavior is undefined.
  ///  * If the map is modifeid then iteration should begin again by passing NULL to
  ///  * get the first key again.
  ///  *
  ///  * This function operates based on the address of the pointer, you cannot pass
  ///  * a copy of a key to get the next key.
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * printf("keys in the map:\n");
  ///  * const char * current_key = rcutils_string_map_get_next_key(&map, NULL);
  ///  * while (current_key) {
  ///  *   printf("  - %s\n", current_key);
  ///  *   current_key = rcutils_string_map_get_next_key(&map, current_key);
  ///  * }
  ///  * ```
  ///  *
  ///  * NULL can also be returned if NULL is given for the string_map or if the
  ///  * string_map is invalid.
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be queried
  ///  * \param[in] key NULL to get the first key or the previous key to get the next
  ///  * \return value for the given key if successful, or
  ///  * \return `NULL` for invalid arguments, or
  ///  * \return `NULL` if the string map is invalid, or
  ///  * \return `NULL` if key not found, or
  ///  * \return `NULL` if there are no more keys in the map, or
  ///  * \return `NULL` if an unknown error occurs.
  ///  */
  ffi.Pointer<ffi.Char> rcutils_string_map_get_next_key(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Char> key,
  ) {
    return _rcutils_string_map_get_next_key(
      string_map,
      key,
    );
  }

  late final _rcutils_string_map_get_next_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcutils_string_map_t>,
              ffi.Pointer<ffi.Char>)>>('rcutils_string_map_get_next_key');
  late final _rcutils_string_map_get_next_key =
      _rcutils_string_map_get_next_keyPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<rcutils_string_map_t>, ffi.Pointer<ffi.Char>)>();

  /// Copy all the key value pairs from one map into another, overwritting and resizing if needed.
  /// /**
  ///  * If the destination string map does not have enough storage, then it is will
  ///  * be resized.
  ///  * If a key value pair exists in the destination map, its value will be
  ///  * replaced with the source map's value.
  ///  *
  ///  * It is possible for only some of the values to be copied if an error happens
  ///  * during the copying process, e.g. if memory allocation fails.
  ///  *
  ///  * \param[in] src_string_map rcutils_string_map_t to be copied from
  ///  * \param[inout] dst_string_map rcutils_string_map_t to be copied to
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT for invalid arguments, or
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation fails, or
  ///  * \return #RCUTILS_RET_STRING_MAP_INVALID if the string map is invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unknown error occurs.
  ///  */
  int rcutils_string_map_copy(
    ffi.Pointer<rcutils_string_map_t> src_string_map,
    ffi.Pointer<rcutils_string_map_t> dst_string_map,
  ) {
    return _rcutils_string_map_copy(
      src_string_map,
      dst_string_map,
    );
  }

  late final _rcutils_string_map_copyPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_string_map_t>,
              ffi.Pointer<rcutils_string_map_t>)>>('rcutils_string_map_copy');
  late final _rcutils_string_map_copy = _rcutils_string_map_copyPtr.asFunction<
      int Function(ffi.Pointer<rcutils_string_map_t>,
          ffi.Pointer<rcutils_string_map_t>)>();

  /// Return a zero initialized uint8 array struct.
  /// /**
  ///  * \return rcutils_uint8_array_t a zero initialized uint8 array struct
  ///  */
  rcutils_uint8_array_t rcutils_get_zero_initialized_uint8_array() {
    return _rcutils_get_zero_initialized_uint8_array();
  }

  late final _rcutils_get_zero_initialized_uint8_arrayPtr =
      _lookup<ffi.NativeFunction<rcutils_uint8_array_t Function()>>(
          'rcutils_get_zero_initialized_uint8_array');
  late final _rcutils_get_zero_initialized_uint8_array =
      _rcutils_get_zero_initialized_uint8_arrayPtr
          .asFunction<rcutils_uint8_array_t Function()>();

  /// Initialize a zero initialized uint8 array struct.
  /// /**
  ///  * This function may leak if the uint8 array struct is already initialized.
  ///  * If the capacity is set to 0, no memory is allocated and the internal buffer
  ///  * is still NULL.
  ///  *
  ///  * \param[inout] uint8_array a pointer to the to be initialized uint8 array struct
  ///  * \param[in] buffer_capacity the size of the memory to allocate for the byte stream
  ///  * \param[in] allocator the allocator to use for the memory allocation
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return 'RCUTILS_RET_BAD_ALLOC` if no memory could be allocated correctly
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_uint8_array_init(
    ffi.Pointer<rcutils_uint8_array_t> uint8_array,
    int buffer_capacity,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_uint8_array_init(
      uint8_array,
      buffer_capacity,
      allocator,
    );
  }

  late final _rcutils_uint8_array_initPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_uint8_array_t>, ffi.Size,
              ffi.Pointer<rcutils_allocator_t>)>>('rcutils_uint8_array_init');
  late final _rcutils_uint8_array_init =
      _rcutils_uint8_array_initPtr.asFunction<
          int Function(ffi.Pointer<rcutils_uint8_array_t>, int,
              ffi.Pointer<rcutils_allocator_t>)>();

  /// Finalize a uint8 array struct.
  /// /**
  ///  * Cleans up and deallocates any resources used in a rcutils_uint8_array_t.
  ///  * The array passed to this function needs to have been initialized by
  ///  * rcutils_uint8_array_init().
  ///  * Passing an uninitialized instance to this function leads to undefined
  ///  * behavior.
  ///  *
  ///  * \param[in] uint8_array pointer to the rcutils_uint8_array_t to be cleaned up
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if the uint8_array argument is invalid
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_uint8_array_fini(
    ffi.Pointer<rcutils_uint8_array_t> uint8_array,
  ) {
    return _rcutils_uint8_array_fini(
      uint8_array,
    );
  }

  late final _rcutils_uint8_array_finiPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_uint8_array_t>)>>('rcutils_uint8_array_fini');
  late final _rcutils_uint8_array_fini = _rcutils_uint8_array_finiPtr
      .asFunction<int Function(ffi.Pointer<rcutils_uint8_array_t>)>();

  /// Resize the internal buffer of the uint8 array.
  /// /**
  ///  * The internal buffer of the uint8 array can be resized dynamically if needed.
  ///  * If the new size is smaller than the current capacity, then the memory is
  ///  * truncated.
  ///  * Be aware, that this might deallocate the memory and therefore invalidates any
  ///  * pointers to this storage.
  ///  *
  ///  * \param[inout] uint8_array pointer to the instance of rcutils_uint8_array_t which is
  ///  * being resized
  ///  * \param[in] new_size the new size of the internal buffer
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if new_size is set to zero
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation failed, or
  ///  * \return #RCUTILS_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcutils_uint8_array_resize(
    ffi.Pointer<rcutils_uint8_array_t> uint8_array,
    int new_size,
  ) {
    return _rcutils_uint8_array_resize(
      uint8_array,
      new_size,
    );
  }

  late final _rcutils_uint8_array_resizePtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<rcutils_uint8_array_t>,
              ffi.Size)>>('rcutils_uint8_array_resize');
  late final _rcutils_uint8_array_resize = _rcutils_uint8_array_resizePtr
      .asFunction<int Function(ffi.Pointer<rcutils_uint8_array_t>, int)>();

  /// This function returns the time from a system clock.
  /// The closest equivalent would be to std::chrono::system_clock::now();
  ///
  /// The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.
  ///
  /// The now argument must point to an allocated rcutils_time_point_value_t object,
  /// as the result is copied into this variable.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[out] now a datafield in which the current time is stored
  /// \return #RCUTILS_RET_OK if the current time was successfully obtained, or
  /// \return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or
  /// \return #RCUTILS_RET_ERROR if an unspecified error occur.
  int rcutils_system_time_now(
    ffi.Pointer<rcutils_time_point_value_t> now,
  ) {
    return _rcutils_system_time_now(
      now,
    );
  }

  late final _rcutils_system_time_nowPtr = _lookup<
          ffi.NativeFunction<
              rcutils_ret_t Function(ffi.Pointer<rcutils_time_point_value_t>)>>(
      'rcutils_system_time_now');
  late final _rcutils_system_time_now = _rcutils_system_time_nowPtr
      .asFunction<int Function(ffi.Pointer<rcutils_time_point_value_t>)>();

  /// Retrieve the current time as a rcutils_time_point_value_t object.
  /// /**
  ///  * This function returns the time from a monotonically increasing clock.
  ///  * The closest equivalent would be to std::chrono::steady_clock::now();
  ///  *
  ///  * The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.
  ///  *
  ///  * The now argument must point to an allocated rcutils_time_point_value_t object,
  ///  * as the result is copied into this variable.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[out] now a struct in which the current time is stored
  ///  * \return #RCUTILS_RET_OK if the current time was successfully obtained, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unspecified error occur.
  ///  */
  int rcutils_steady_time_now(
    ffi.Pointer<rcutils_time_point_value_t> now,
  ) {
    return _rcutils_steady_time_now(
      now,
    );
  }

  late final _rcutils_steady_time_nowPtr = _lookup<
          ffi.NativeFunction<
              rcutils_ret_t Function(ffi.Pointer<rcutils_time_point_value_t>)>>(
      'rcutils_steady_time_now');
  late final _rcutils_steady_time_now = _rcutils_steady_time_nowPtr
      .asFunction<int Function(ffi.Pointer<rcutils_time_point_value_t>)>();

  /// Return a time point as nanoseconds in a string.
  /// /**
  ///  * The number is always fixed width, with left padding zeros up to the maximum
  ///  * number of digits the time point can represent.
  ///  * Right now that is 19 digits (so 19 characters) for a signed 64-bit integer.
  ///  * Negative values will have a leading `-`, so they will be one character
  ///  * longer than the positive values.
  ///  *
  ///  * The recommended minimum size of the input string is 32 characters, but
  ///  * 21 (` ` or `-` for sign, 19 digits, null terminator) should be sufficiently
  ///  * large for both positive and negative values.
  ///  * If the given string is not large enough, the result will be truncated.
  ///  * If you need a string with variable width, using `snprintf()` directly is
  ///  * recommended.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No [1]
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] if `snprintf()` does not allocate additional memory internally</i>
  ///  *
  ///  * \param[in] time_point the time to be made into a string
  ///  * \param[out] str the output string in which it is stored
  ///  * \param[in] str_size the size of the output string
  ///  * \return #RCUTILS_RET_OK if successful (even if truncated), or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unspecified error occur.
  ///  */
  int rcutils_time_point_value_as_nanoseconds_string(
    ffi.Pointer<rcutils_time_point_value_t> time_point,
    ffi.Pointer<ffi.Char> str,
    int str_size,
  ) {
    return _rcutils_time_point_value_as_nanoseconds_string(
      time_point,
      str,
      str_size,
    );
  }

  late final _rcutils_time_point_value_as_nanoseconds_stringPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_time_point_value_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('rcutils_time_point_value_as_nanoseconds_string');
  late final _rcutils_time_point_value_as_nanoseconds_string =
      _rcutils_time_point_value_as_nanoseconds_stringPtr.asFunction<
          int Function(ffi.Pointer<rcutils_time_point_value_t>,
              ffi.Pointer<ffi.Char>, int)>();

  /// Return a time point as floating point seconds in a string.
  /// /**
  ///  * The number is always fixed width, with left padding zeros up to the maximum
  ///  * number of digits for the mantissa that the time point can represent and a
  ///  * characteristic (fractional-part) with a fixed width of 9 digits.
  ///  * Right now that means the mantissa is always 10 digits to add up to 19 total
  ///  * for the signed 64-bit time point type.
  ///  * Negative values will have a leading `-`, so they will be one character
  ///  * longer then positive values.
  ///  *
  ///  * The recommended minimum size of the input string is 32 characters, but
  ///  * 22 (` ` or `-` for sign, 19 digits, decimal point, null terminator) should
  ///  * be sufficient for now.
  ///  * If the given string is not large enough, the result will be truncated.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No [1]
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] if `snprintf()` does not allocate additional memory internally</i>
  ///  *
  ///  * \param[in] time_point the time to be made into a string
  ///  * \param[out] str the output string in which it is stored
  ///  * \param[in] str_size the size of the output string
  ///  * \return #RCUTILS_RET_OK if successful (even if truncated), or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCUTILS_RET_ERROR if an unspecified error occur.
  ///  */
  int rcutils_time_point_value_as_seconds_string(
    ffi.Pointer<rcutils_time_point_value_t> time_point,
    ffi.Pointer<ffi.Char> str,
    int str_size,
  ) {
    return _rcutils_time_point_value_as_seconds_string(
      time_point,
      str,
      str_size,
    );
  }

  late final _rcutils_time_point_value_as_seconds_stringPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(
              ffi.Pointer<rcutils_time_point_value_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('rcutils_time_point_value_as_seconds_string');
  late final _rcutils_time_point_value_as_seconds_string =
      _rcutils_time_point_value_as_seconds_stringPtr.asFunction<
          int Function(ffi.Pointer<rcutils_time_point_value_t>,
              ffi.Pointer<ffi.Char>, int)>();

  /// The flag if the logging system has been initialized.
  late final ffi.Pointer<ffi.Bool> _g_rcutils_logging_initialized =
      _lookup<ffi.Bool>('g_rcutils_logging_initialized');

  bool get g_rcutils_logging_initialized =>
      _g_rcutils_logging_initialized.value;

  set g_rcutils_logging_initialized(bool value) =>
      _g_rcutils_logging_initialized.value = value;

  /// Initialize the logging system using the specified allocator.
  /// /**
  ///  * Initialize the logging system only if it was not in an initialized state.
  ///  *
  ///  * If an invalid allocator is passed, the initialization will fail.
  ///  * Otherwise, this function will still set the internal state to initialized
  ///  * even if an error occurs, to avoid repeated failing initialization attempts
  ///  * since this function is called automatically from logging macros.
  ///  * To re-attempt initialization, call rcutils_logging_shutdown() before
  ///  * re-calling this function.
  ///  *
  ///  * If multiple errors occur, the error code of the last error will be returned.
  ///  *
  ///  * The `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable can be used to set
  ///  * the output format of messages logged to the console.
  ///  * Available tokens are:
  ///  *   - `file_name`, the full file name of the caller including the path
  ///  *   - `function_name`, the function name of the caller
  ///  *   - `line_number`, the line number of the caller
  ///  *   - `message`, the message string after it has been formatted
  ///  *   - `name`, the full logger name
  ///  *   - `severity`, the name of the severity level, e.g. `INFO`
  ///  *   - `time`, the timestamp of log message in floating point seconds
  ///  *   - `time_as_nanoseconds`, the timestamp of log message in integer nanoseconds
  ///  *
  ///  * The `RCUTILS_COLORIZED_OUTPUT` environment variable allows configuring if colours
  ///  * are used or not. Available values are:
  ///  *  - `1`: Force using colours.
  ///  *  - `0`: Don't use colours.
  ///  * If it is unset, colours are used depending if the target stream is a terminal or not.
  ///  * See `isatty` documentation.
  ///  *
  ///  * The format string can use these tokens by referencing them in curly brackets,
  ///  * e.g. `"[{severity}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})"`.
  ///  * Any number of tokens can be used.
  ///  * The limit of the format string is 2048 characters.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] allocator rcutils_allocator_t to be used.
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if the allocator is invalid, in which
  ///  *   case initialization will fail, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if an error occurs reading the output
  ///  *   format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in
  ///  *   which case the default format will be used, or
  ///  * \return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger
  ///  *   severity level map cannot be initialized, in which case logger severity
  ///  *   levels will not be configurable.
  ///  */
  int rcutils_logging_initialize_with_allocator(
    rcutils_allocator_t allocator,
  ) {
    return _rcutils_logging_initialize_with_allocator(
      allocator,
    );
  }

  late final _rcutils_logging_initialize_with_allocatorPtr =
      _lookup<ffi.NativeFunction<rcutils_ret_t Function(rcutils_allocator_t)>>(
          'rcutils_logging_initialize_with_allocator');
  late final _rcutils_logging_initialize_with_allocator =
      _rcutils_logging_initialize_with_allocatorPtr
          .asFunction<int Function(rcutils_allocator_t)>();

  /// Initialize the logging system.
  /// /**
  ///  * Call rcutils_logging_initialize_with_allocator() using the default allocator.
  ///  * This function is called automatically when using the logging macros.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT if an error occurs reading the output
  ///  *   format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in
  ///  *   which case the default format will be used, or
  ///  * \return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger
  ///  *   severity level map cannot be initialized, in which case logger levels
  ///  *   will not be configurable.
  ///  */
  int rcutils_logging_initialize() {
    return _rcutils_logging_initialize();
  }

  late final _rcutils_logging_initializePtr =
      _lookup<ffi.NativeFunction<rcutils_ret_t Function()>>(
          'rcutils_logging_initialize');
  late final _rcutils_logging_initialize =
      _rcutils_logging_initializePtr.asFunction<int Function()>();

  /// Shutdown the logging system.
  /// /**
  ///  * Free the resources allocated for the logging system.
  ///  * This puts the system into a state equivalent to being uninitialized.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID if the internal logger
  ///  *   severity level map cannot be finalized.
  ///  */
  int rcutils_logging_shutdown() {
    return _rcutils_logging_shutdown();
  }

  late final _rcutils_logging_shutdownPtr =
      _lookup<ffi.NativeFunction<rcutils_ret_t Function()>>(
          'rcutils_logging_shutdown');
  late final _rcutils_logging_shutdown =
      _rcutils_logging_shutdownPtr.asFunction<int Function()>();

  /// The names of severity levels.
  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>
      _g_rcutils_log_severity_names =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>(
          'g_rcutils_log_severity_names');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get g_rcutils_log_severity_names =>
      _g_rcutils_log_severity_names.value;

  set g_rcutils_log_severity_names(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      _g_rcutils_log_severity_names.value = value;

  /// Get a severity value from its string representation (e.g. DEBUG).
  /// /**
  ///  * String representation must match one of the values in
  ///  * `g_rcutils_log_severity_names`, but is not case-sensitive.
  ///  * Examples: UNSET, DEBUG, INFO, WARN, Error, fatal.
  ///  *
  ///  * \param[in] severity_string String representation of the severity, must be a
  ///  *   null terminated c string
  ///  * \param[in] allocator rcutils_allocator_t to be used
  ///  * \param[in,out] severity The severity level as a represented by the
  ///  *   `RCUTILS_LOG_SEVERITY` enum
  ///  * \return #RCUTILS_RET_OK if successful, or
  ///  * \return #RCUTILS_RET_INVALID_ARGUMENT on invalid arguments, or
  ///  * \return #RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID if unable to match
  ///  *   string, or
  ///  * \return #RCUTILS_RET_ERROR if an unspecified error occured.
  ///  */
  int rcutils_logging_severity_level_from_string(
    ffi.Pointer<ffi.Char> severity_string,
    rcutils_allocator_t allocator,
    ffi.Pointer<ffi.Int> severity,
  ) {
    return _rcutils_logging_severity_level_from_string(
      severity_string,
      allocator,
      severity,
    );
  }

  late final _rcutils_logging_severity_level_from_stringPtr = _lookup<
          ffi.NativeFunction<
              rcutils_ret_t Function(ffi.Pointer<ffi.Char>, rcutils_allocator_t,
                  ffi.Pointer<ffi.Int>)>>(
      'rcutils_logging_severity_level_from_string');
  late final _rcutils_logging_severity_level_from_string =
      _rcutils_logging_severity_level_from_stringPtr.asFunction<
          int Function(ffi.Pointer<ffi.Char>, rcutils_allocator_t,
              ffi.Pointer<ffi.Int>)>();

  /// The function pointer of the current output handler.
  late final ffi.Pointer<rcutils_logging_output_handler_t>
      _g_rcutils_logging_output_handler =
      _lookup<rcutils_logging_output_handler_t>(
          'g_rcutils_logging_output_handler');

  rcutils_logging_output_handler_t get g_rcutils_logging_output_handler =>
      _g_rcutils_logging_output_handler.value;

  set g_rcutils_logging_output_handler(
          rcutils_logging_output_handler_t value) =>
      _g_rcutils_logging_output_handler.value = value;

  /// Get the current output handler.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \return The function pointer of the current output handler.
  ///  */
  rcutils_logging_output_handler_t rcutils_logging_get_output_handler() {
    return _rcutils_logging_get_output_handler();
  }

  late final _rcutils_logging_get_output_handlerPtr =
      _lookup<ffi.NativeFunction<rcutils_logging_output_handler_t Function()>>(
          'rcutils_logging_get_output_handler');
  late final _rcutils_logging_get_output_handler =
      _rcutils_logging_get_output_handlerPtr
          .asFunction<rcutils_logging_output_handler_t Function()>();

  /// Set the current output handler.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] function The function pointer of the output handler to be used.
  ///  */
  void rcutils_logging_set_output_handler(
    rcutils_logging_output_handler_t function,
  ) {
    return _rcutils_logging_set_output_handler(
      function,
    );
  }

  late final _rcutils_logging_set_output_handlerPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(rcutils_logging_output_handler_t)>>(
      'rcutils_logging_set_output_handler');
  late final _rcutils_logging_set_output_handler =
      _rcutils_logging_set_output_handlerPtr
          .asFunction<void Function(rcutils_logging_output_handler_t)>();

  /// Formats a log message according to RCUTILS_CONSOLE_OUTPUT_FORMAT
  /// /**
  ///  * A formatter that is meant to be used by an output handler to format a log message to the match
  ///  * the format specified in RCUTILS_CONSOLE_OUTPUT_FORMAT by performing token replacement.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] location The location information about where the log came from
  ///  * \param[in] severity The severity of the log message expressed as an integer
  ///  * \param[in] name The name of the logger that this message came from
  ///  * \param[in] timestamp The time at which the log message was generated
  ///  * \param[in] msg The message being logged
  ///  * \param[out] logging_output An output buffer for the formatted message
  ///  * \return #RCUTILS_RET_OK if successful.
  ///  * \return #RCUTILS_RET_BAD_ALLOC if memory allocation error occured
  ///  */
  int rcutils_logging_format_message(
    ffi.Pointer<rcutils_log_location_t> location,
    int severity,
    ffi.Pointer<ffi.Char> name,
    int timestamp,
    ffi.Pointer<ffi.Char> msg,
    ffi.Pointer<rcutils_char_array_t> logging_output,
  ) {
    return _rcutils_logging_format_message(
      location,
      severity,
      name,
      timestamp,
      msg,
      logging_output,
    );
  }

  late final _rcutils_logging_format_messagePtr = _lookup<
          ffi.NativeFunction<
              rcutils_ret_t Function(
                  ffi.Pointer<rcutils_log_location_t>,
                  ffi.Int,
                  ffi.Pointer<ffi.Char>,
                  rcutils_time_point_value_t,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<rcutils_char_array_t>)>>(
      'rcutils_logging_format_message');
  late final _rcutils_logging_format_message =
      _rcutils_logging_format_messagePtr.asFunction<
          int Function(
              ffi.Pointer<rcutils_log_location_t>,
              int,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<rcutils_char_array_t>)>();

  /// The default severity level for loggers.
  /// /**
  ///  * This level is used for (1) nameless log calls and (2) named log
  ///  * calls where the effective level of the logger name is unspecified.
  ///  *
  ///  * \see rcutils_logging_get_logger_effective_level()
  ///  */
  late final ffi.Pointer<ffi.Int> _g_rcutils_logging_default_logger_level =
      _lookup<ffi.Int>('g_rcutils_logging_default_logger_level');

  int get g_rcutils_logging_default_logger_level =>
      _g_rcutils_logging_default_logger_level.value;

  set g_rcutils_logging_default_logger_level(int value) =>
      _g_rcutils_logging_default_logger_level.value = value;

  /// Get the default level for loggers.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \return The level.
  ///  */
  int rcutils_logging_get_default_logger_level() {
    return _rcutils_logging_get_default_logger_level();
  }

  late final _rcutils_logging_get_default_logger_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'rcutils_logging_get_default_logger_level');
  late final _rcutils_logging_get_default_logger_level =
      _rcutils_logging_get_default_logger_levelPtr.asFunction<int Function()>();

  /// Set the default severity level for loggers.
  /// /**
  ///  * If the severity level requested is `RCUTILS_LOG_SEVERITY_UNSET`, the default
  ///  * value for the default logger (`RCUTILS_DEFAULT_LOGGER_DEFAULT_LEVEL`)
  ///  * will be restored instead.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] level The level to be used.
  ///  */
  void rcutils_logging_set_default_logger_level(
    int level,
  ) {
    return _rcutils_logging_set_default_logger_level(
      level,
    );
  }

  late final _rcutils_logging_set_default_logger_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'rcutils_logging_set_default_logger_level');
  late final _rcutils_logging_set_default_logger_level =
      _rcutils_logging_set_default_logger_levelPtr
          .asFunction<void Function(int)>();

  /// Get the severity level for a logger.
  /// /**
  ///  * This considers the severity level of the specifed logger only.
  ///  * To get the effective level of a logger given the severity level of its
  ///  * ancestors, see rcutils_logging_get_logger_effective_level().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] name The name of the logger, must be null terminated c string
  ///  * \return The level of the logger if it has been set, or
  ///  * \return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or
  ///  * \return `g_rcutils_logging_default_logger_level` for an empty name, or
  ///  * \return -1 on invalid arguments, or
  ///  * \return -1 if an error occurred
  ///  */
  int rcutils_logging_get_logger_level(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _rcutils_logging_get_logger_level(
      name,
    );
  }

  late final _rcutils_logging_get_logger_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rcutils_logging_get_logger_level');
  late final _rcutils_logging_get_logger_level =
      _rcutils_logging_get_logger_levelPtr
          .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get the level for a logger and its name length.
  /// /**
  ///  * Identical to rcutils_logging_get_logger_level() but without
  ///  * relying on the logger name to be a null terminated c string.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] name The name of the logger
  ///  * \param[in] name_length Logger name length
  ///  * \return The level of the logger if it has been set, or
  ///  * \return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or
  ///  * \return `g_rcutils_logging_default_logger_level` for `name_length` of `0`, or
  ///  * \return -1 on invalid arguments, or
  ///  * \return -1 if an error occurred
  ///  */
  int rcutils_logging_get_logger_leveln(
    ffi.Pointer<ffi.Char> name,
    int name_length,
  ) {
    return _rcutils_logging_get_logger_leveln(
      name,
      name_length,
    );
  }

  late final _rcutils_logging_get_logger_levelnPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>(
      'rcutils_logging_get_logger_leveln');
  late final _rcutils_logging_get_logger_leveln =
      _rcutils_logging_get_logger_levelnPtr
          .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Set the severity level for a logger.
  /// /**
  ///  * If an empty string is specified as the name, the
  ///  * `g_rcutils_logging_default_logger_level` will be set.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] name The name of the logger, must be null terminated c string.
  ///  * \param[in] level The level to be used.
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` on invalid arguments, or
  ///  * \return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if severity map invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unspecified error occured
  ///  */
  int rcutils_logging_set_logger_level(
    ffi.Pointer<ffi.Char> name,
    int level,
  ) {
    return _rcutils_logging_set_logger_level(
      name,
      level,
    );
  }

  late final _rcutils_logging_set_logger_levelPtr = _lookup<
      ffi.NativeFunction<
          rcutils_ret_t Function(ffi.Pointer<ffi.Char>,
              ffi.Int)>>('rcutils_logging_set_logger_level');
  late final _rcutils_logging_set_logger_level =
      _rcutils_logging_set_logger_levelPtr
          .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Determine if a logger is enabled for a severity level.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] name The name of the logger, must be null terminated c string or NULL.
  ///  * \param[in] severity The severity level.
  ///  *
  ///  * \return `true` if the logger is enabled for the level, or
  ///  * \return `false` otherwise.
  ///  */
  bool rcutils_logging_logger_is_enabled_for(
    ffi.Pointer<ffi.Char> name,
    int severity,
  ) {
    return _rcutils_logging_logger_is_enabled_for(
      name,
      severity,
    );
  }

  late final _rcutils_logging_logger_is_enabled_forPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'rcutils_logging_logger_is_enabled_for');
  late final _rcutils_logging_logger_is_enabled_for =
      _rcutils_logging_logger_is_enabled_forPtr
          .asFunction<bool Function(ffi.Pointer<ffi.Char>, int)>();

  /// Determine the effective level for a logger.
  /// /**
  ///  * The effective level is determined as the severity level of
  ///  * the logger if it is set, otherwise it is the first specified severity
  ///  * level of the logger's ancestors, starting with its closest ancestor.
  ///  * The ancestor hierarchy is signified by logger names being separated by dots:
  ///  * a logger named `x` is an ancestor of `x.y`, and both `x` and `x.y` are
  ///  * ancestors of `x.y.z`, etc.
  ///  * If the level has not been set for the logger nor any of its
  ///  * ancestors, the default level is used.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] name The name of the logger, must be null terminated c string.
  ///  *
  ///  * \return The level, or
  ///  * \return -1 on invalid arguments, or
  ///  * \return -1 if an error occurred.
  ///  */
  int rcutils_logging_get_logger_effective_level(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _rcutils_logging_get_logger_effective_level(
      name,
    );
  }

  late final _rcutils_logging_get_logger_effective_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rcutils_logging_get_logger_effective_level');
  late final _rcutils_logging_get_logger_effective_level =
      _rcutils_logging_get_logger_effective_levelPtr
          .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Log a message.
  /// /**
  ///  * The attributes of this function are also being influenced by the currently
  ///  * set output handler.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, for formatted outputs <= 1023 characters
  ///  *                    | Yes, for formatted outputs >= 1024 characters
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] location The pointer to the location struct or NULL
  ///  * \param[in] severity The severity level
  ///  * \param[in] name The name of the logger, must be null terminated c string or NULL
  ///  * \param[in] format The format string
  ///  * \param[in] ... The variable arguments
  ///  */
  void rcutils_log(
    ffi.Pointer<rcutils_log_location_t> location,
    int severity,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> format,
  ) {
    return _rcutils_log(
      location,
      severity,
      name,
      format,
    );
  }

  late final _rcutils_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<rcutils_log_location_t>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('rcutils_log');
  late final _rcutils_log = _rcutils_logPtr.asFunction<
      void Function(ffi.Pointer<rcutils_log_location_t>, int,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// The default output handler outputs log messages to the standard streams.
  /// /**
  ///  * The messages with a severity level `DEBUG` and `INFO` are written to `stdout`.
  ///  * The messages with a severity level `WARN`, `ERROR`, and `FATAL` are written
  ///  * to `stderr`.
  ///  * The console output format of the logged message can be configured through
  ///  * the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable: see
  ///  * rcutils_logging_initialize_with_allocator() for details.
  ///  * For configuring if using colours or not, `RCUTILS_COLORIZED_OUTPUT` can be used:
  ///  * see rcutils_logging_initialize_with_allocator() for details.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes, if the underlying *printf functions are
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] location The pointer to the location struct or NULL
  ///  * \param[in] severity The severity level
  ///  * \param[in] name The name of the logger, must be null terminated c string
  ///  * \param[in] timestamp The timestamp for when the log message was made
  ///  * \param[in] format The format string
  ///  * \param[in] args The `va_list` used by the logger
  ///  */
  void rcutils_logging_console_output_handler(
    ffi.Pointer<rcutils_log_location_t> location,
    int severity,
    ffi.Pointer<ffi.Char> name,
    int timestamp,
    ffi.Pointer<ffi.Char> format,
    ffi.Pointer<ffi.Pointer<__va_list_tag>> args,
  ) {
    return _rcutils_logging_console_output_handler(
      location,
      severity,
      name,
      timestamp,
      format,
      args,
    );
  }

  late final _rcutils_logging_console_output_handlerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<rcutils_log_location_t>,
                  ffi.Int,
                  ffi.Pointer<ffi.Char>,
                  rcutils_time_point_value_t,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<__va_list_tag>>)>>(
      'rcutils_logging_console_output_handler');
  late final _rcutils_logging_console_output_handler =
      _rcutils_logging_console_output_handlerPtr.asFunction<
          void Function(
              ffi.Pointer<rcutils_log_location_t>,
              int,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<__va_list_tag>>)>();

  /// Get zero initialized content filter options.
  rmw_subscription_content_filter_options_t
      rmw_get_zero_initialized_content_filter_options() {
    return _rmw_get_zero_initialized_content_filter_options();
  }

  late final _rmw_get_zero_initialized_content_filter_optionsPtr = _lookup<
      ffi.NativeFunction<
          rmw_subscription_content_filter_options_t
              Function()>>('rmw_get_zero_initialized_content_filter_options');
  late final _rmw_get_zero_initialized_content_filter_options =
      _rmw_get_zero_initialized_content_filter_optionsPtr
          .asFunction<rmw_subscription_content_filter_options_t Function()>();

  /// Initialize the given content filter options.
  /// /**
  ///  * \param[in] filter_expression The filter expression.
  ///  * \param[in] expression_parameters_argc The expression parameters argc.
  ///  * \param[in] expression_parameter_argv The expression parameters argv.
  ///  * \param[in] allocator The allocator used when copying data to the content filter options.
  ///  * \param[out] options The content filter options to be set.
  ///  * \returns RMW_RET_INVALID_ARGUMENT, or
  ///  * \returns RMW_RET_BAD_ALLOC, or
  ///  * \returns RMW_RET_OK
  ///  */
  int rmw_subscription_content_filter_options_init(
    ffi.Pointer<ffi.Char> filter_expression,
    int expression_parameters_argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> expression_parameter_argv,
    ffi.Pointer<rcutils_allocator_t> allocator,
    ffi.Pointer<rmw_subscription_content_filter_options_t> options,
  ) {
    return _rmw_subscription_content_filter_options_init(
      filter_expression,
      expression_parameters_argc,
      expression_parameter_argv,
      allocator,
      options,
    );
  }

  late final _rmw_subscription_content_filter_options_initPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.Pointer<rcutils_allocator_t>,
                  ffi.Pointer<rmw_subscription_content_filter_options_t>)>>(
      'rmw_subscription_content_filter_options_init');
  late final _rmw_subscription_content_filter_options_init =
      _rmw_subscription_content_filter_options_initPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<rcutils_allocator_t>,
              ffi.Pointer<rmw_subscription_content_filter_options_t>)>();

  /// Set the given content filter options.
  /// /**
  ///  * \param[in] filter_expression The filter expression.
  ///  * \param[in] expression_parameters_argc The expression parameters argc.
  ///  * \param[in] expression_parameter_argv The expression parameters argv.
  ///  * \param[in] allocator The allocator used when copying data to the content filter options.
  ///  * \param[out] options The content filter options to be set.
  ///  * \returns RMW_RET_INVALID_ARGUMENT, or
  ///  * \returns RMW_RET_BAD_ALLOC, or
  ///  * \returns RMW_RET_OK
  ///  */
  int rmw_subscription_content_filter_options_set(
    ffi.Pointer<ffi.Char> filter_expression,
    int expression_parameters_argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> expression_parameter_argv,
    ffi.Pointer<rcutils_allocator_t> allocator,
    ffi.Pointer<rmw_subscription_content_filter_options_t> options,
  ) {
    return _rmw_subscription_content_filter_options_set(
      filter_expression,
      expression_parameters_argc,
      expression_parameter_argv,
      allocator,
      options,
    );
  }

  late final _rmw_subscription_content_filter_options_setPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.Pointer<rcutils_allocator_t>,
                  ffi.Pointer<rmw_subscription_content_filter_options_t>)>>(
      'rmw_subscription_content_filter_options_set');
  late final _rmw_subscription_content_filter_options_set =
      _rmw_subscription_content_filter_options_setPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<rcutils_allocator_t>,
              ffi.Pointer<rmw_subscription_content_filter_options_t>)>();

  /// Copy the given content filter options.
  /// /**
  ///  * \param[in] src content filter options to be copied.
  ///  * \param[in] allocator allocator used when copying data to the new content filter options.
  ///  * \param[out] dst content filter options to be set.
  ///  * \returns RMW_RET_INVALID_ARGUMENT, or
  ///  * \returns RMW_RET_BAD_ALLOC, or
  ///  * \returns RMW_RET_OK
  ///  */
  int rmw_subscription_content_filter_options_copy(
    ffi.Pointer<rmw_subscription_content_filter_options_t> src,
    ffi.Pointer<rcutils_allocator_t> allocator,
    ffi.Pointer<rmw_subscription_content_filter_options_t> dst,
  ) {
    return _rmw_subscription_content_filter_options_copy(
      src,
      allocator,
      dst,
    );
  }

  late final _rmw_subscription_content_filter_options_copyPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_subscription_content_filter_options_t>,
                  ffi.Pointer<rcutils_allocator_t>,
                  ffi.Pointer<rmw_subscription_content_filter_options_t>)>>(
      'rmw_subscription_content_filter_options_copy');
  late final _rmw_subscription_content_filter_options_copy =
      _rmw_subscription_content_filter_options_copyPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_subscription_content_filter_options_t>,
              ffi.Pointer<rcutils_allocator_t>,
              ffi.Pointer<rmw_subscription_content_filter_options_t>)>();

  /// Finalize the content filter options.
  /// /**
  ///  * \param[in] options content filter options to be finalized.
  ///  * \param[in] allocator allocator used to deallocate the content filter options.
  ///  * \returns RMW_RET_INVALID_ARGUMENT, or
  ///  * \returns RMW_RET_ERROR, or
  ///  * \returns RMW_RET_OK
  ///  */
  int rmw_subscription_content_filter_options_fini(
    ffi.Pointer<rmw_subscription_content_filter_options_t> options,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rmw_subscription_content_filter_options_fini(
      options,
      allocator,
    );
  }

  late final _rmw_subscription_content_filter_options_finiPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_subscription_content_filter_options_t>,
                  ffi.Pointer<rcutils_allocator_t>)>>(
      'rmw_subscription_content_filter_options_fini');
  late final _rmw_subscription_content_filter_options_fini =
      _rmw_subscription_content_filter_options_finiPtr.asFunction<
          int Function(ffi.Pointer<rmw_subscription_content_filter_options_t>,
              ffi.Pointer<rcutils_allocator_t>)>();

  /// Check whether two rmw_time_t represent the same time.
  bool rmw_time_equal(
    rmw_time_t left,
    rmw_time_t right,
  ) {
    return _rmw_time_equal(
      left,
      right,
    );
  }

  late final _rmw_time_equalPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(rmw_time_t, rmw_time_t)>>(
          'rmw_time_equal');
  late final _rmw_time_equal =
      _rmw_time_equalPtr.asFunction<bool Function(rmw_time_t, rmw_time_t)>();

  /// Return the total nanosecond representation of a time.
  /// /**
  ///   * \return INT64_MAX if input is too large to store in 64 bits
  ///   */
  int rmw_time_total_nsec(
    rmw_time_t time,
  ) {
    return _rmw_time_total_nsec(
      time,
    );
  }

  late final _rmw_time_total_nsecPtr =
      _lookup<ffi.NativeFunction<rmw_duration_t Function(rmw_time_t)>>(
          'rmw_time_total_nsec');
  late final _rmw_time_total_nsec =
      _rmw_time_total_nsecPtr.asFunction<int Function(rmw_time_t)>();

  /// Construct rmw_time_t from a total nanoseconds representation.
  /// /**
  ///   * rmw_time_t only specifies relative time, so the origin is not relevant for this calculation.
  ///   * \return RMW_DURATION_INFINITE if input is negative, which is not representable in rmw_time_t
  ///   */
  rmw_time_t rmw_time_from_nsec(
    int nanoseconds,
  ) {
    return _rmw_time_from_nsec(
      nanoseconds,
    );
  }

  late final _rmw_time_from_nsecPtr =
      _lookup<ffi.NativeFunction<rmw_time_t Function(rmw_duration_t)>>(
          'rmw_time_from_nsec');
  late final _rmw_time_from_nsec =
      _rmw_time_from_nsecPtr.asFunction<rmw_time_t Function(int)>();

  /// Ensure that an rmw_time_t does not have nanoseconds > 1 second.
  rmw_time_t rmw_time_normalize(
    rmw_time_t time,
  ) {
    return _rmw_time_normalize(
      time,
    );
  }

  late final _rmw_time_normalizePtr =
      _lookup<ffi.NativeFunction<rmw_time_t Function(rmw_time_t)>>(
          'rmw_time_normalize');
  late final _rmw_time_normalize =
      _rmw_time_normalizePtr.asFunction<rmw_time_t Function(rmw_time_t)>();

  /// Get zero initialized mesage info.
  rmw_message_info_t rmw_get_zero_initialized_message_info() {
    return _rmw_get_zero_initialized_message_info();
  }

  late final _rmw_get_zero_initialized_message_infoPtr =
      _lookup<ffi.NativeFunction<rmw_message_info_t Function()>>(
          'rmw_get_zero_initialized_message_info');
  late final _rmw_get_zero_initialized_message_info =
      _rmw_get_zero_initialized_message_infoPtr
          .asFunction<rmw_message_info_t Function()>();

  /// Return a rcl_log_levels_t struct with members initialized to zero value.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \return a rcl_log_levels_t struct with members initialized to zero value.
  ///  */
  rcl_log_levels_t rcl_get_zero_initialized_log_levels() {
    return _rcl_get_zero_initialized_log_levels();
  }

  late final _rcl_get_zero_initialized_log_levelsPtr =
      _lookup<ffi.NativeFunction<rcl_log_levels_t Function()>>(
          'rcl_get_zero_initialized_log_levels');
  late final _rcl_get_zero_initialized_log_levels =
      _rcl_get_zero_initialized_log_levelsPtr
          .asFunction<rcl_log_levels_t Function()>();

  /// Initialize a log levels structure.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] log_levels The structure to be initialized.
  ///  * \param[in] allocator Memory allocator to be used and assigned into log_levels.
  ///  * \param[in] logger_count Number of logger settings to be allocated.
  ///  *  This reserves memory for logger_settings, but doesn't initialize it.
  ///  * \return #RCL_RET_OK if the structure was initialized successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if log_levels contains initialized memory, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if allocator is invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed.
  ///  */
  int rcl_log_levels_init(
    ffi.Pointer<rcl_log_levels_t> log_levels,
    ffi.Pointer<rcl_allocator_t> allocator,
    int logger_count,
  ) {
    return _rcl_log_levels_init(
      log_levels,
      allocator,
      logger_count,
    );
  }

  late final _rcl_log_levels_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_log_levels_t>,
              ffi.Pointer<rcl_allocator_t>, ffi.Size)>>('rcl_log_levels_init');
  late final _rcl_log_levels_init = _rcl_log_levels_initPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_log_levels_t>, ffi.Pointer<rcl_allocator_t>, int)>();

  /// Copy one log levels structure into another.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] src The structure to be copied.
  ///  *  Its allocator is used to copy memory into the new structure.
  ///  * \param[out] dst A log levels structure to be copied into.
  ///  * \return #RCL_RET_OK if the structure was copied successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if src is NULL, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if src allocator is invalid, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if dst is NULL, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if dst contains already allocated memory, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed.
  ///  */
  int rcl_log_levels_copy(
    ffi.Pointer<rcl_log_levels_t> src,
    ffi.Pointer<rcl_log_levels_t> dst,
  ) {
    return _rcl_log_levels_copy(
      src,
      dst,
    );
  }

  late final _rcl_log_levels_copyPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_log_levels_t>,
              ffi.Pointer<rcl_log_levels_t>)>>('rcl_log_levels_copy');
  late final _rcl_log_levels_copy = _rcl_log_levels_copyPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_log_levels_t>, ffi.Pointer<rcl_log_levels_t>)>();

  /// Reclaim resources held inside rcl_log_levels_t structure.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] log_levels The structure which its resources have to be deallocated.
  ///  * \return #RCL_RET_OK if the memory was successfully freed, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if the log_levels allocator is invalid and the structure contains initialized memory.
  ///  */
  int rcl_log_levels_fini(
    ffi.Pointer<rcl_log_levels_t> log_levels,
  ) {
    return _rcl_log_levels_fini(
      log_levels,
    );
  }

  late final _rcl_log_levels_finiPtr = _lookup<
          ffi
          .NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_log_levels_t>)>>(
      'rcl_log_levels_fini');
  late final _rcl_log_levels_fini = _rcl_log_levels_finiPtr
      .asFunction<int Function(ffi.Pointer<rcl_log_levels_t>)>();

  /// Shrink log levels structure.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] log_levels The structure to be shrunk.
  ///  * \return #RCL_RET_OK if the memory was successfully shrunk, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL or if its allocator is invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if reallocating memory failed.
  ///  */
  int rcl_log_levels_shrink_to_size(
    ffi.Pointer<rcl_log_levels_t> log_levels,
  ) {
    return _rcl_log_levels_shrink_to_size(
      log_levels,
    );
  }

  late final _rcl_log_levels_shrink_to_sizePtr = _lookup<
          ffi
          .NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_log_levels_t>)>>(
      'rcl_log_levels_shrink_to_size');
  late final _rcl_log_levels_shrink_to_size = _rcl_log_levels_shrink_to_sizePtr
      .asFunction<int Function(ffi.Pointer<rcl_log_levels_t>)>();

  /// Add logger setting with a name and a level.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] log_levels The structure where to set the logger log level.
  ///  * \param[in] logger_name Name for the logger, a copy of it will be stored in the structure.
  ///  * \param[in] log_level Minimum log level severity to be set for logger_name.
  ///  * \return #RCL_RET_OK if add logger setting successfully, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if log_levels is NULL, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if log_levels was not initialized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if log_levels allocator is invalid, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if logger_name is NULL, or
  ///  * \return #RCL_RET_ERROR if the log_levels structure is already full.
  ///  */
  int rcl_log_levels_add_logger_setting(
    ffi.Pointer<rcl_log_levels_t> log_levels,
    ffi.Pointer<ffi.Char> logger_name,
    int log_level,
  ) {
    return _rcl_log_levels_add_logger_setting(
      log_levels,
      logger_name,
      log_level,
    );
  }

  late final _rcl_log_levels_add_logger_settingPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_log_levels_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('rcl_log_levels_add_logger_setting');
  late final _rcl_log_levels_add_logger_setting =
      _rcl_log_levels_add_logger_settingPtr.asFunction<
          int Function(
              ffi.Pointer<rcl_log_levels_t>, ffi.Pointer<ffi.Char>, int)>();

  /// Return a rcl_arguments_t struct with members initialized to `NULL`.
  rcl_arguments_t rcl_get_zero_initialized_arguments() {
    return _rcl_get_zero_initialized_arguments();
  }

  late final _rcl_get_zero_initialized_argumentsPtr =
      _lookup<ffi.NativeFunction<rcl_arguments_t Function()>>(
          'rcl_get_zero_initialized_arguments');
  late final _rcl_get_zero_initialized_arguments =
      _rcl_get_zero_initialized_argumentsPtr
          .asFunction<rcl_arguments_t Function()>();

  /// Parse command line arguments into a structure usable by code.
  /// /**
  ///  * \sa rcl_get_zero_initialized_arguments()
  ///  *
  ///  * ROS arguments are expected to be scoped by a leading `--ros-args` flag and a trailing double
  ///  * dash token `--` which may be elided if no non-ROS arguments follow after the last `--ros-args`.
  ///  *
  ///  * Remap rule parsing is supported via `-r/--remap` flags e.g. `--remap from:=to` or `-r from:=to`.
  ///  * Successfully parsed remap rules are stored in the order they were given in `argv`.
  ///  * If given arguments `{"__ns:=/foo", "__ns:=/bar"}` then the namespace used by nodes in this
  ///  * process will be `/foo` and not `/bar`.
  ///  *
  ///  * \sa rcl_remap_topic_name()
  ///  * \sa rcl_remap_service_name()
  ///  * \sa rcl_remap_node_name()
  ///  * \sa rcl_remap_node_namespace()
  ///  *
  ///  * Parameter override rule parsing is supported via `-p/--param` flags e.g. `--param name:=value`
  ///  * or `-p name:=value`.
  ///  *
  ///  * The default log level will be parsed as `--log-level level` and logger levels will be parsed as
  ///  * multiple `--log-level name:=level`, where `level` is a name representing one of the log levels
  ///  * in the `RCUTILS_LOG_SEVERITY` enum, e.g. `info`, `debug`, `warn`, not case sensitive.
  ///  * If multiple of these rules are found, the last one parsed will be used.
  ///  *
  ///  * If an argument does not appear to be a valid ROS argument e.g. a `-r/--remap` flag followed by
  ///  * anything but a valid remap rule, parsing will fail immediately.
  ///  *
  ///  * If an argument does not appear to be a known ROS argument, then it is skipped and left unparsed.
  ///  *
  ///  * \sa rcl_arguments_get_count_unparsed_ros()
  ///  * \sa rcl_arguments_get_unparsed_ros()
  ///  *
  ///  * All arguments found outside a `--ros-args ... --` scope are skipped and left unparsed.
  ///  *
  ///  * \sa rcl_arguments_get_count_unparsed()
  ///  * \sa rcl_arguments_get_unparsed()
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] argc The number of arguments in argv.
  ///  * \param[in] argv The values of the arguments.
  ///  * \param[in] allocator A valid allocator.
  ///  * \param[out] args_output A structure that will contain the result of parsing.
  ///  *   Must be zero initialized before use.
  ///  * \return #RCL_RET_OK if the arguments were parsed successfully, or
  ///  * \return #RCL_RET_INVALID_ROS_ARGS if an invalid ROS argument is found, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_parse_arguments(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
    rcl_allocator_t allocator,
    ffi.Pointer<rcl_arguments_t> args_output,
  ) {
    return _rcl_parse_arguments(
      argc,
      argv,
      allocator,
      args_output,
    );
  }

  late final _rcl_parse_argumentsPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              rcl_allocator_t,
              ffi.Pointer<rcl_arguments_t>)>>('rcl_parse_arguments');
  late final _rcl_parse_arguments = _rcl_parse_argumentsPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>, rcl_allocator_t,
          ffi.Pointer<rcl_arguments_t>)>();

  /// Return the number of arguments that were not ROS specific arguments.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \return number of unparsed arguments, or
  ///  * \return -1 if args is `NULL` or zero initialized.
  ///  */
  int rcl_arguments_get_count_unparsed(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return _rcl_arguments_get_count_unparsed(
      args,
    );
  }

  late final _rcl_arguments_get_count_unparsedPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<rcl_arguments_t>)>>(
      'rcl_arguments_get_count_unparsed');
  late final _rcl_arguments_get_count_unparsed =
      _rcl_arguments_get_count_unparsedPtr
          .asFunction<int Function(ffi.Pointer<rcl_arguments_t>)>();

  /// Return a list of indices to non ROS specific arguments.
  /// /**
  ///  * Non ROS specific arguments may have been provided i.e. arguments outside a '--ros-args' scope.
  ///  * This function populates an array of indices to these arguments in the original argv array.
  ///  * Since the first argument is always assumed to be a process name, the list will always contain
  ///  * the index 0.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \param[in] allocator A valid allocator.
  ///  * \param[out] output_unparsed_indices An allocated array of indices into the original argv array.
  ///  *   This array must be deallocated by the caller using the given allocator.
  ///  *   If there are no unparsed args then the output will be set to NULL.
  ///  * \return #RCL_RET_OK if everything goes correctly, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_arguments_get_unparsed(
    ffi.Pointer<rcl_arguments_t> args,
    rcl_allocator_t allocator,
    ffi.Pointer<ffi.Pointer<ffi.Int>> output_unparsed_indices,
  ) {
    return _rcl_arguments_get_unparsed(
      args,
      allocator,
      output_unparsed_indices,
    );
  }

  late final _rcl_arguments_get_unparsedPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_arguments_t>, rcl_allocator_t,
                  ffi.Pointer<ffi.Pointer<ffi.Int>>)>>(
      'rcl_arguments_get_unparsed');
  late final _rcl_arguments_get_unparsed =
      _rcl_arguments_get_unparsedPtr.asFunction<
          int Function(ffi.Pointer<rcl_arguments_t>, rcl_allocator_t,
              ffi.Pointer<ffi.Pointer<ffi.Int>>)>();

  /// Return the number of ROS specific arguments that were not successfully parsed.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \return number of unparsed ROS specific arguments, or
  ///  * \return -1 if args is `NULL` or zero initialized.
  ///  */
  int rcl_arguments_get_count_unparsed_ros(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return _rcl_arguments_get_count_unparsed_ros(
      args,
    );
  }

  late final _rcl_arguments_get_count_unparsed_rosPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<rcl_arguments_t>)>>(
      'rcl_arguments_get_count_unparsed_ros');
  late final _rcl_arguments_get_count_unparsed_ros =
      _rcl_arguments_get_count_unparsed_rosPtr
          .asFunction<int Function(ffi.Pointer<rcl_arguments_t>)>();

  /// Return a list of indices to unknown ROS specific arguments that were left unparsed.
  /// /**
  ///  * Some ROS specific arguments may not have been recognized, or were not intended to be
  ///  * parsed by rcl.
  ///  * This function populates an array of indices to these arguments in the original argv array.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \param[in] allocator A valid allocator.
  ///  * \param[out] output_unparsed_ros_indices An allocated array of indices into the original argv array.
  ///  *   This array must be deallocated by the caller using the given allocator.
  ///  *   If there are no unparsed ROS specific arguments then the output will be set to NULL.
  ///  * \return #RCL_RET_OK if everything goes correctly, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_arguments_get_unparsed_ros(
    ffi.Pointer<rcl_arguments_t> args,
    rcl_allocator_t allocator,
    ffi.Pointer<ffi.Pointer<ffi.Int>> output_unparsed_ros_indices,
  ) {
    return _rcl_arguments_get_unparsed_ros(
      args,
      allocator,
      output_unparsed_ros_indices,
    );
  }

  late final _rcl_arguments_get_unparsed_rosPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_arguments_t>, rcl_allocator_t,
                  ffi.Pointer<ffi.Pointer<ffi.Int>>)>>(
      'rcl_arguments_get_unparsed_ros');
  late final _rcl_arguments_get_unparsed_ros =
      _rcl_arguments_get_unparsed_rosPtr.asFunction<
          int Function(ffi.Pointer<rcl_arguments_t>, rcl_allocator_t,
              ffi.Pointer<ffi.Pointer<ffi.Int>>)>();

  /// Return the number of parameter yaml files given in the arguments.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \return number of yaml files, or
  ///  * \return -1 if args is `NULL` or zero initialized.
  ///  */
  int rcl_arguments_get_param_files_count(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return _rcl_arguments_get_param_files_count(
      args,
    );
  }

  late final _rcl_arguments_get_param_files_countPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<rcl_arguments_t>)>>(
      'rcl_arguments_get_param_files_count');
  late final _rcl_arguments_get_param_files_count =
      _rcl_arguments_get_param_files_countPtr
          .asFunction<int Function(ffi.Pointer<rcl_arguments_t>)>();

  /// Return a list of yaml parameter file paths specified on the command line.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] arguments An arguments structure that has been parsed.
  ///  * \param[in] allocator A valid allocator.
  ///  * \param[out] parameter_files An allocated array of paramter file names.
  ///  *   This array must be deallocated by the caller using the given allocator.
  ///  *   The output is NULL if there were no paramter files.
  ///  * \return #RCL_RET_OK if everything goes correctly, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_arguments_get_param_files(
    ffi.Pointer<rcl_arguments_t> arguments,
    rcl_allocator_t allocator,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> parameter_files,
  ) {
    return _rcl_arguments_get_param_files(
      arguments,
      allocator,
      parameter_files,
    );
  }

  late final _rcl_arguments_get_param_filesPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_arguments_t>, rcl_allocator_t,
                  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>)>>(
      'rcl_arguments_get_param_files');
  late final _rcl_arguments_get_param_files =
      _rcl_arguments_get_param_filesPtr.asFunction<
          int Function(ffi.Pointer<rcl_arguments_t>, rcl_allocator_t,
              ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>)>();

  /// Return all parameter overrides parsed from the command line.
  /// /**
  ///  * Parameter overrides are parsed directly from command line arguments and
  ///  * parameter files provided in the command line.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] arguments An arguments structure that has been parsed.
  ///  * \param[out] parameter_overrides Parameter overrides as parsed from command line arguments.
  ///  *   This structure must be finalized by the caller.
  ///  *   The output is NULL if no parameter overrides were parsed.
  ///  * \return #RCL_RET_OK if everything goes correctly, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_arguments_get_param_overrides(
    ffi.Pointer<rcl_arguments_t> arguments,
    ffi.Pointer<ffi.Pointer<rcl_params_t>> parameter_overrides,
  ) {
    return _rcl_arguments_get_param_overrides(
      arguments,
      parameter_overrides,
    );
  }

  late final _rcl_arguments_get_param_overridesPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_arguments_t>,
                  ffi.Pointer<ffi.Pointer<rcl_params_t>>)>>(
      'rcl_arguments_get_param_overrides');
  late final _rcl_arguments_get_param_overrides =
      _rcl_arguments_get_param_overridesPtr.asFunction<
          int Function(ffi.Pointer<rcl_arguments_t>,
              ffi.Pointer<ffi.Pointer<rcl_params_t>>)>();

  /// Return a list of arguments with ROS-specific arguments removed.
  /// /**
  ///  * Some arguments may not have been intended as ROS arguments.
  ///  * This function populates an array of the aruments in a new argv array.
  ///  * Since the first argument is always assumed to be a process name, the list
  ///  * will always contain the first value from the argument vector.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] argv The argument vector
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \param[in] allocator A valid allocator.
  ///  * \param[out] nonros_argc The count of arguments that aren't ROS-specific
  ///  * \param[out] nonros_argv An allocated array of arguments that aren't ROS-specific
  ///  *   This array must be deallocated by the caller using the given allocator.
  ///  *   If there are no non-ROS args, then the output will be set to NULL.
  ///  * \return #RCL_RET_OK if everything goes correctly, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_remove_ros_arguments(
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
    ffi.Pointer<rcl_arguments_t> args,
    rcl_allocator_t allocator,
    ffi.Pointer<ffi.Int> nonros_argc,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> nonros_argv,
  ) {
    return _rcl_remove_ros_arguments(
      argv,
      args,
      allocator,
      nonros_argc,
      nonros_argv,
    );
  }

  late final _rcl_remove_ros_argumentsPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.Pointer<rcl_arguments_t>,
                  rcl_allocator_t,
                  ffi.Pointer<ffi.Int>,
                  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>)>>(
      'rcl_remove_ros_arguments');
  late final _rcl_remove_ros_arguments =
      _rcl_remove_ros_argumentsPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<rcl_arguments_t>,
              rcl_allocator_t,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>)>();

  /// Return log levels parsed from the command line.
  /// /**
  ///  * Log levels are parsed directly from command line arguments.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] arguments An arguments structure that has been parsed.
  ///  * \param[out] log_levels Log levels as parsed from command line arguments.
  ///  *   The output must be finished by the caller if the function successes.
  ///  * \return #RCL_RET_OK if everything goes correctly, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed.
  ///  */
  int rcl_arguments_get_log_levels(
    ffi.Pointer<rcl_arguments_t> arguments,
    ffi.Pointer<rcl_log_levels_t> log_levels,
  ) {
    return _rcl_arguments_get_log_levels(
      arguments,
      log_levels,
    );
  }

  late final _rcl_arguments_get_log_levelsPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_arguments_t>,
              ffi.Pointer<rcl_log_levels_t>)>>('rcl_arguments_get_log_levels');
  late final _rcl_arguments_get_log_levels =
      _rcl_arguments_get_log_levelsPtr.asFunction<
          int Function(
              ffi.Pointer<rcl_arguments_t>, ffi.Pointer<rcl_log_levels_t>)>();

  /// Copy one arguments structure into another.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args The structure to be copied.
  ///  *  Its allocator is used to copy memory into the new structure.
  ///  * \param[out] args_out A zero-initialized arguments structure to be copied into.
  ///  * \return #RCL_RET_OK if the structure was copied successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_arguments_copy(
    ffi.Pointer<rcl_arguments_t> args,
    ffi.Pointer<rcl_arguments_t> args_out,
  ) {
    return _rcl_arguments_copy(
      args,
      args_out,
    );
  }

  late final _rcl_arguments_copyPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_arguments_t>,
              ffi.Pointer<rcl_arguments_t>)>>('rcl_arguments_copy');
  late final _rcl_arguments_copy = _rcl_arguments_copyPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_arguments_t>, ffi.Pointer<rcl_arguments_t>)>();

  /// Reclaim resources held inside rcl_arguments_t structure.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args The structure to be deallocated.
  ///  * \return #RCL_RET_OK if the memory was successfully freed, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_arguments_fini(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return _rcl_arguments_fini(
      args,
    );
  }

  late final _rcl_arguments_finiPtr = _lookup<
          ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_arguments_t>)>>(
      'rcl_arguments_fini');
  late final _rcl_arguments_fini = _rcl_arguments_finiPtr
      .asFunction<int Function(ffi.Pointer<rcl_arguments_t>)>();

  /// Return a zero initialized rcl_init_options_t struct.
  rcl_init_options_t rcl_get_zero_initialized_init_options() {
    return _rcl_get_zero_initialized_init_options();
  }

  late final _rcl_get_zero_initialized_init_optionsPtr =
      _lookup<ffi.NativeFunction<rcl_init_options_t Function()>>(
          'rcl_get_zero_initialized_init_options');
  late final _rcl_get_zero_initialized_init_options =
      _rcl_get_zero_initialized_init_optionsPtr
          .asFunction<rcl_init_options_t Function()>();

  /// Initialize given init_options with the default values and implementation specific values.
  /// /**
  ///  * The given allocator is used, if required, during setup of the init options,
  ///  * but is also used during initialization.
  ///  *
  ///  * In either case the given allocator is stored in the returned init options.
  ///  *
  ///  * The `impl` pointer should not be changed manually.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] init_options object to be setup
  ///  * \param[in] allocator to be used during setup and during initialization
  ///  * \return #RCL_RET_OK if setup is successful, or
  ///  * \return #RCL_RET_ALREADY_INIT if init_options has already be initialized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_init_options_init(
    ffi.Pointer<rcl_init_options_t> init_options,
    rcl_allocator_t allocator,
  ) {
    return _rcl_init_options_init(
      init_options,
      allocator,
    );
  }

  late final _rcl_init_options_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_init_options_t>,
              rcl_allocator_t)>>('rcl_init_options_init');
  late final _rcl_init_options_init = _rcl_init_options_initPtr.asFunction<
      int Function(ffi.Pointer<rcl_init_options_t>, rcl_allocator_t)>();

  /// Copy the given source init_options to the destination init_options.
  /// /**
  ///  * The allocator from the source is used for any allocations and stored in the
  ///  * destination.
  ///  *
  ///  * The destination should either be zero initialized with
  ///  * rcl_get_zero_initialized_init_options() or should have had
  ///  * rcl_init_options_fini() called on it.
  ///  * Giving an already initialized init options for the destination will result
  ///  * in a failure with return code #RCL_RET_ALREADY_INIT.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] src rcl_init_options_t object to be copied from
  ///  * \param[out] dst rcl_init_options_t object to be copied into
  ///  * \return #RCL_RET_OK if the copy is successful, or
  ///  * \return #RCL_RET_ALREADY_INIT if the dst has already be initialized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_init_options_copy(
    ffi.Pointer<rcl_init_options_t> src,
    ffi.Pointer<rcl_init_options_t> dst,
  ) {
    return _rcl_init_options_copy(
      src,
      dst,
    );
  }

  late final _rcl_init_options_copyPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_init_options_t>,
              ffi.Pointer<rcl_init_options_t>)>>('rcl_init_options_copy');
  late final _rcl_init_options_copy = _rcl_init_options_copyPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_init_options_t>, ffi.Pointer<rcl_init_options_t>)>();

  /// Finalize the given init_options.
  /// /**
  ///  * The given init_options must be non-`NULL` and valid, i.e. had
  ///  * rcl_init_options_init() called on it but not this function yet.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] init_options object to be setup
  ///  * \return #RCL_RET_OK if setup is successful, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_init_options_fini(
    ffi.Pointer<rcl_init_options_t> init_options,
  ) {
    return _rcl_init_options_fini(
      init_options,
    );
  }

  late final _rcl_init_options_finiPtr = _lookup<
          ffi
          .NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_init_options_t>)>>(
      'rcl_init_options_fini');
  late final _rcl_init_options_fini = _rcl_init_options_finiPtr
      .asFunction<int Function(ffi.Pointer<rcl_init_options_t>)>();

  /// Return the domain_id stored in the init options.
  /// /**
  ///  * Get the domain id from the specified rcl_init_options_t object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] init_options object from which the domain id should be retrieved.
  ///  * \param[out] domain_id domain id to be set in init_options object.
  ///  * \return #RCL_RET_OK if successful, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid.
  ///  */
  int rcl_init_options_get_domain_id(
    ffi.Pointer<rcl_init_options_t> init_options,
    ffi.Pointer<ffi.Size> domain_id,
  ) {
    return _rcl_init_options_get_domain_id(
      init_options,
      domain_id,
    );
  }

  late final _rcl_init_options_get_domain_idPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_init_options_t>,
              ffi.Pointer<ffi.Size>)>>('rcl_init_options_get_domain_id');
  late final _rcl_init_options_get_domain_id =
      _rcl_init_options_get_domain_idPtr.asFunction<
          int Function(
              ffi.Pointer<rcl_init_options_t>, ffi.Pointer<ffi.Size>)>();

  /// Set a domain id in the init options provided.
  /// /**
  ///  * Store the domain id in the specified init_options object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] init_options objects in which to set the specified domain id.
  ///  * \param[in] domain_id domain id to be set in init_options object.
  ///  * \return #RCL_RET_OK if successful, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid.
  ///  */
  int rcl_init_options_set_domain_id(
    ffi.Pointer<rcl_init_options_t> init_options,
    int domain_id,
  ) {
    return _rcl_init_options_set_domain_id(
      init_options,
      domain_id,
    );
  }

  late final _rcl_init_options_set_domain_idPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_init_options_t>,
              ffi.Size)>>('rcl_init_options_set_domain_id');
  late final _rcl_init_options_set_domain_id =
      _rcl_init_options_set_domain_idPtr
          .asFunction<int Function(ffi.Pointer<rcl_init_options_t>, int)>();

  /// Return the rmw init options which are stored internally.
  /// /**
  ///  * This function can fail and return `NULL` if:
  ///  *   - init_options is NULL
  ///  *   - init_options is invalid, e.g. init_options->impl is NULL
  ///  *
  ///  * If NULL is returned an error message will have been set.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] init_options object from which the rmw init options should be retrieved
  ///  * \return pointer to the the rcl init options, or
  ///  * \return `NULL` if there was an error
  ///  */
  ffi.Pointer<rmw_init_options_t> rcl_init_options_get_rmw_init_options(
    ffi.Pointer<rcl_init_options_t> init_options,
  ) {
    return _rcl_init_options_get_rmw_init_options(
      init_options,
    );
  }

  late final _rcl_init_options_get_rmw_init_optionsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rmw_init_options_t> Function(
                  ffi.Pointer<rcl_init_options_t>)>>(
      'rcl_init_options_get_rmw_init_options');
  late final _rcl_init_options_get_rmw_init_options =
      _rcl_init_options_get_rmw_init_optionsPtr.asFunction<
          ffi.Pointer<rmw_init_options_t> Function(
              ffi.Pointer<rcl_init_options_t>)>();

  /// Return the allocator stored in the init_options.
  /// /**
  ///  * This function can fail and return `NULL` if:
  ///  *   - init_options is NULL
  ///  *   - init_options is invalid, e.g. init_options->impl is NULL
  ///  *
  ///  * If NULL is returned an error message will have been set.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] init_options object from which the allocator should be retrieved
  ///  * \return pointer to the rcl allocator, or
  ///  * \return `NULL` if there was an error
  ///  */
  ffi.Pointer<rcl_allocator_t> rcl_init_options_get_allocator(
    ffi.Pointer<rcl_init_options_t> init_options,
  ) {
    return _rcl_init_options_get_allocator(
      init_options,
    );
  }

  late final _rcl_init_options_get_allocatorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rcl_allocator_t> Function(
                  ffi.Pointer<rcl_init_options_t>)>>(
      'rcl_init_options_get_allocator');
  late final _rcl_init_options_get_allocator =
      _rcl_init_options_get_allocatorPtr.asFunction<
          ffi.Pointer<rcl_allocator_t> Function(
              ffi.Pointer<rcl_init_options_t>)>();

  /// Return a zero initialization context object.
  rcl_context_t rcl_get_zero_initialized_context() {
    return _rcl_get_zero_initialized_context();
  }

  late final _rcl_get_zero_initialized_contextPtr =
      _lookup<ffi.NativeFunction<rcl_context_t Function()>>(
          'rcl_get_zero_initialized_context');
  late final _rcl_get_zero_initialized_context =
      _rcl_get_zero_initialized_contextPtr
          .asFunction<rcl_context_t Function()>();

  /// Finalize a context.
  /// /**
  ///  * The context to be finalized must have been previously initialized with
  ///  * rcl_init(), and then later invalidated with rcl_shutdown().
  ///  * A zero-initialized context that has not been initialized can be finalized.
  ///  * If context is `NULL`, then #RCL_RET_INVALID_ARGUMENT is returned.
  ///  * If context is zero-initialized, then #RCL_RET_OK is returned.
  ///  * If context is initialized and valid (rcl_shutdown() was not called on it),
  ///  * then #RCL_RET_INVALID_ARGUMENT is returned.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[inout] context object to be finalized.
  ///  * \return #RCL_RET_OK if the shutdown was completed successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occur.
  ///  */
  int rcl_context_fini(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_context_fini(
      context,
    );
  }

  late final _rcl_context_finiPtr = _lookup<
          ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_context_t>)>>(
      'rcl_context_fini');
  late final _rcl_context_fini = _rcl_context_finiPtr
      .asFunction<int Function(ffi.Pointer<rcl_context_t>)>();

  /// Return the init options used during initialization for this context.
  /// /**
  ///  * This function can fail and return `NULL` if:
  ///  *   - context is NULL
  ///  *   - context is zero-initialized, e.g. context->impl is `NULL`
  ///  *
  ///  * If context is uninitialized then that is undefined behavior.
  ///  *
  ///  * If `NULL` is returned an error message will have been set.
  ///  *
  ///  * The options are for reference only, and therefore the returned pointer is
  ///  * const.
  ///  * Changing the values in the options is undefined behavior but will likely
  ///  * have no effect.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] context object from which the init options should be retrieved
  ///  * \return pointer to the the init options, or
  ///  * \return `NULL` if there was an error
  ///  */
  ffi.Pointer<rcl_init_options_t> rcl_context_get_init_options(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_context_get_init_options(
      context,
    );
  }

  late final _rcl_context_get_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rcl_init_options_t> Function(
              ffi.Pointer<rcl_context_t>)>>('rcl_context_get_init_options');
  late final _rcl_context_get_init_options =
      _rcl_context_get_init_optionsPtr.asFunction<
          ffi.Pointer<rcl_init_options_t> Function(
              ffi.Pointer<rcl_context_t>)>();

  /// Returns an unsigned integer that is unique to the given context, or `0` if invalid.
  /// /**
  ///  * The given context must be non-`NULL`, but does not need to be initialized or valid.
  ///  * If context is `NULL`, then `0` will be returned.
  ///  * If context is uninitialized, then it is undefined behavior.
  ///  *
  ///  * The instance ID may be `0` if the context is zero-initialized or if the
  ///  * context has been invalidated by rcl_shutdown().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] context object from which the instance id should be retrieved
  ///  * \return a unique id specific to this context instance, or
  ///  * \return `0` if invalid, or
  ///  * \return `0` if context is `NULL`
  ///  */
  int rcl_context_get_instance_id(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_context_get_instance_id(
      context,
    );
  }

  late final _rcl_context_get_instance_idPtr = _lookup<
      ffi.NativeFunction<
          rcl_context_instance_id_t Function(
              ffi.Pointer<rcl_context_t>)>>('rcl_context_get_instance_id');
  late final _rcl_context_get_instance_id = _rcl_context_get_instance_idPtr
      .asFunction<int Function(ffi.Pointer<rcl_context_t>)>();

  /// Returns the context domain id.
  /// /**
  ///  * \pre If context is uninitialized, then it is undefined behavior.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | No
  ///  *
  ///  * <i>[1] Calling the function asynchronously with rcl_init() or rcl_shutdown() can result
  ///  *  in the function sometimes succeeding and sometimes returning #RCL_RET_INVALID_ARGUMENT.</i>
  ///  *
  ///  * \param[in] context from which the domain id should be retrieved.
  ///  * \param[out] domain_id output variable where the domain id will be returned.
  ///  * \return #RCL_RET_INVALID_ARGUMENT if `context` is invalid (see rcl_context_is_valid()), or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if `domain_id` is `NULL`, or
  ///  * \return #RCL_RET_OK if the domain id was correctly retrieved.
  ///  */
  int rcl_context_get_domain_id(
    ffi.Pointer<rcl_context_t> context,
    ffi.Pointer<ffi.Size> domain_id,
  ) {
    return _rcl_context_get_domain_id(
      context,
      domain_id,
    );
  }

  late final _rcl_context_get_domain_idPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_context_t>,
              ffi.Pointer<ffi.Size>)>>('rcl_context_get_domain_id');
  late final _rcl_context_get_domain_id =
      _rcl_context_get_domain_idPtr.asFunction<
          int Function(ffi.Pointer<rcl_context_t>, ffi.Pointer<ffi.Size>)>();

  /// Return `true` if the given context is currently valid, otherwise `false`.
  /// /**
  ///  * If context is `NULL`, then `false` is returned.
  ///  * If context is zero-initialized, then `false` is returned.
  ///  * If context is uninitialized, then it is undefined behavior.
  ///  *
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] context object which should be checked for validity
  ///  * \return `true` if valid, otherwise `false`
  ///  */
  bool rcl_context_is_valid(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_context_is_valid(
      context,
    );
  }

  late final _rcl_context_is_validPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_context_t>)>>(
      'rcl_context_is_valid');
  late final _rcl_context_is_valid = _rcl_context_is_validPtr
      .asFunction<bool Function(ffi.Pointer<rcl_context_t>)>();

  /// Return pointer to the rmw context if the given context is currently valid, otherwise `NULL`.
  /// /**
  ///  * If context is `NULL`, then `NULL` is returned.
  ///  * If context is zero-initialized, then `NULL` is returned.
  ///  * If context is uninitialized, then it is undefined behavior.
  ///  *
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] context object from which the rmw context should be retrieved.
  ///  * \return pointer to rmw context if valid, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_context_t> rcl_context_get_rmw_context(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_context_get_rmw_context(
      context,
    );
  }

  late final _rcl_context_get_rmw_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_context_t> Function(
              ffi.Pointer<rcl_context_t>)>>('rcl_context_get_rmw_context');
  late final _rcl_context_get_rmw_context =
      _rcl_context_get_rmw_contextPtr.asFunction<
          ffi.Pointer<rmw_context_t> Function(ffi.Pointer<rcl_context_t>)>();

  /// Initialization of rcl.
  /// /**
  ///  * This function can be run any number of times, so long as the given context
  ///  * has been properly prepared.
  ///  *
  ///  * The given rcl_context_t must be zero initialized with the function
  ///  * rcl_get_zero_initialized_context() and must not be already initialized
  ///  * by this function.
  ///  * If the context is already initialized this function will fail and return the
  ///  * #RCL_RET_ALREADY_INIT error code.
  ///  * A context may be initialized again after it has been finalized with the
  ///  * rcl_shutdown() function and zero initialized again with
  ///  * rcl_get_zero_initialized_context().
  ///  *
  ///  * The `argc` and `argv` parameters may contain command line arguments for the
  ///  * program.
  ///  * rcl specific arguments will be parsed, but not removed.
  ///  * If `argc` is `0` and `argv` is `NULL` no parameters will be parsed.
  ///  *
  ///  * The `options` argument must be non-`NULL` and must have been initialized
  ///  * with rcl_init_options_init().
  ///  * It is unmodified by this function, and the ownership is not transfered to
  ///  * the context, but instead a copy is made into the context for later reference.
  ///  * Therefore, the given options need to be cleaned up with
  ///  * rcl_init_options_fini() after this function returns.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] argc number of strings in argv
  ///  * \param[in] argv command line arguments; rcl specific arguments are removed
  ///  * \param[in] options options used during initialization
  ///  * \param[out] context resulting context object that represents this init
  ///  * \return #RCL_RET_OK if initialization is successful, or
  ///  * \return #RCL_RET_ALREADY_INIT if rcl_init has already been called, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_INVALID_ROS_ARGS if an invalid ROS argument is found, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_init(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
    ffi.Pointer<rcl_init_options_t> options,
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_init(
      argc,
      argv,
      options,
      context,
    );
  }

  late final _rcl_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<rcl_init_options_t>,
              ffi.Pointer<rcl_context_t>)>>('rcl_init');
  late final _rcl_init = _rcl_initPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<rcl_init_options_t>, ffi.Pointer<rcl_context_t>)>();

  /// Shutdown a given rcl context.
  /// /**
  ///  * The given context must have been initialized with rcl_init().
  ///  * If not, this function will fail with #RCL_RET_ALREADY_SHUTDOWN.
  ///  *
  ///  * When this function is called:
  ///  *  - Any rcl objects created using this context are invalidated.
  ///  *  - Functions called on invalid objects may or may not fail.
  ///  *  - Calls to rcl_context_is_initialized() will return `false`.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[inout] context object to shutdown
  ///  * \return #RCL_RET_OK if the shutdown was completed successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ALREADY_SHUTDOWN if the context is not currently valid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occur.
  ///  */
  int rcl_shutdown(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_shutdown(
      context,
    );
  }

  late final _rcl_shutdownPtr = _lookup<
          ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_context_t>)>>(
      'rcl_shutdown');
  late final _rcl_shutdown =
      _rcl_shutdownPtr.asFunction<int Function(ffi.Pointer<rcl_context_t>)>();

  /// Return a rcl_guard_condition_t struct with members set to `NULL`.
  rcl_guard_condition_t rcl_get_zero_initialized_guard_condition() {
    return _rcl_get_zero_initialized_guard_condition();
  }

  late final _rcl_get_zero_initialized_guard_conditionPtr =
      _lookup<ffi.NativeFunction<rcl_guard_condition_t Function()>>(
          'rcl_get_zero_initialized_guard_condition');
  late final _rcl_get_zero_initialized_guard_condition =
      _rcl_get_zero_initialized_guard_conditionPtr
          .asFunction<rcl_guard_condition_t Function()>();

  /// Initialize a rcl guard_condition.
  /// /**
  ///  * After calling this function on a rcl_guard_condition_t, it can be passed to
  ///  * rcl_wait() and then concurrently it can be triggered to wake-up rcl_wait().
  ///  *
  ///  * Expected usage:
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  *
  ///  * // ... error handling
  ///  * rcl_guard_condition_t guard_condition = rcl_get_zero_initialized_guard_condition();
  ///  * // ... customize guard condition options
  ///  * rcl_ret_t ret = rcl_guard_condition_init(
  ///  *   &guard_condition, context, rcl_guard_condition_get_default_options());
  ///  * // ... error handling, and on shutdown do deinitialization:
  ///  * ret = rcl_guard_condition_fini(&guard_condition);
  ///  * // ... error handling for rcl_guard_condition_fini()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] guard_condition preallocated guard_condition structure
  ///  * \param[in] context the context instance with which the guard condition
  ///  *   should be associated
  ///  * \param[in] options the guard_condition's options
  ///  * \return #RCL_RET_OK if guard_condition was initialized successfully, or
  ///  * \return #RCL_RET_ALREADY_INIT if the guard condition is already initialized, or
  ///  * \return #RCL_RET_NOT_INIT if the given context is invalid, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_guard_condition_init(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
    ffi.Pointer<rcl_context_t> context,
    rcl_guard_condition_options_t options,
  ) {
    return _rcl_guard_condition_init(
      guard_condition,
      context,
      options,
    );
  }

  late final _rcl_guard_condition_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_guard_condition_t>,
              ffi.Pointer<rcl_context_t>,
              rcl_guard_condition_options_t)>>('rcl_guard_condition_init');
  late final _rcl_guard_condition_init =
      _rcl_guard_condition_initPtr.asFunction<
          int Function(ffi.Pointer<rcl_guard_condition_t>,
              ffi.Pointer<rcl_context_t>, rcl_guard_condition_options_t)>();

  /// Same as rcl_guard_condition_init(), but reusing an existing rmw handle.
  /// /**
  ///  * In addition to the documentation for rcl_guard_condition_init(), the
  ///  * `rmw_guard_condition` parameter must not be `NULL` and must point to a valid
  ///  * rmw guard condition.
  ///  *
  ///  * Also the life time of the rcl guard condition is tied to the life time of
  ///  * the rmw guard condition.
  ///  * So if the rmw guard condition is destroyed before the rcl guard condition,
  ///  * the rcl guard condition becomes invalid.
  ///  *
  ///  * Similarly if the resulting rcl guard condition is fini'ed before the rmw
  ///  * guard condition, then the rmw guard condition is no longer valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] guard_condition preallocated guard_condition structure
  ///  * \param[in] rmw_guard_condition existing rmw guard condition to reuse
  ///  * \param[in] context the context instance with which the rmw guard condition
  ///  *   was initialized with, i.e. the rmw context inside rcl context needs to
  ///  *   match rmw context in rmw guard condition
  ///  * \param[in] options the guard_condition's options
  ///  * \return #RCL_RET_OK if guard_condition was initialized successfully, or
  ///  * \return #RCL_RET_ALREADY_INIT if the guard condition is already initialized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_guard_condition_init_from_rmw(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
    ffi.Pointer<rmw_guard_condition_t> rmw_guard_condition,
    ffi.Pointer<rcl_context_t> context,
    rcl_guard_condition_options_t options,
  ) {
    return _rcl_guard_condition_init_from_rmw(
      guard_condition,
      rmw_guard_condition,
      context,
      options,
    );
  }

  late final _rcl_guard_condition_init_from_rmwPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_guard_condition_t>,
                  ffi.Pointer<rmw_guard_condition_t>,
                  ffi.Pointer<rcl_context_t>,
                  rcl_guard_condition_options_t)>>(
      'rcl_guard_condition_init_from_rmw');
  late final _rcl_guard_condition_init_from_rmw =
      _rcl_guard_condition_init_from_rmwPtr.asFunction<
          int Function(
              ffi.Pointer<rcl_guard_condition_t>,
              ffi.Pointer<rmw_guard_condition_t>,
              ffi.Pointer<rcl_context_t>,
              rcl_guard_condition_options_t)>();

  /// Finalize a rcl_guard_condition_t.
  /// /**
  ///  * After calling, calls to rcl_trigger_guard_condition() will fail when using
  ///  * this guard condition.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] specifically not thread-safe with rcl_trigger_guard_condition()</i>
  ///  *
  ///  * \param[inout] guard_condition handle to the guard_condition to be finalized
  ///  * \return #RCL_RET_OK if guard_condition was finalized successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_guard_condition_fini(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return _rcl_guard_condition_fini(
      guard_condition,
    );
  }

  late final _rcl_guard_condition_finiPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_guard_condition_t>)>>('rcl_guard_condition_fini');
  late final _rcl_guard_condition_fini = _rcl_guard_condition_finiPtr
      .asFunction<int Function(ffi.Pointer<rcl_guard_condition_t>)>();

  /// Return the default options in a rcl_guard_condition_options_t struct.
  /// /**
  ///  * The defaults are:
  ///  *
  ///  * - allocator = rcl_get_default_allocator()
  ///  *
  ///  * \return the default options in an rcl_guard_condition_options_t struct.
  ///  */
  rcl_guard_condition_options_t rcl_guard_condition_get_default_options() {
    return _rcl_guard_condition_get_default_options();
  }

  late final _rcl_guard_condition_get_default_optionsPtr =
      _lookup<ffi.NativeFunction<rcl_guard_condition_options_t Function()>>(
          'rcl_guard_condition_get_default_options');
  late final _rcl_guard_condition_get_default_options =
      _rcl_guard_condition_get_default_optionsPtr
          .asFunction<rcl_guard_condition_options_t Function()>();

  /// Trigger a rcl guard condition.
  /// /**
  ///  * This function can fail, and return RCL_RET_INVALID_ARGUMENT, if the:
  ///  *   - guard condition is `NULL`
  ///  *   - guard condition is invalid (never called init or called fini)
  ///  *
  ///  * A guard condition can be triggered from any thread.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] it can be called concurrently with itself, even on the same guard condition</i>
  ///  *
  ///  * \param[in] guard_condition handle to the guard_condition to be triggered
  ///  * \return #RCL_RET_OK if the guard condition was triggered, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_trigger_guard_condition(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return _rcl_trigger_guard_condition(
      guard_condition,
    );
  }

  late final _rcl_trigger_guard_conditionPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_guard_condition_t>)>>(
      'rcl_trigger_guard_condition');
  late final _rcl_trigger_guard_condition = _rcl_trigger_guard_conditionPtr
      .asFunction<int Function(ffi.Pointer<rcl_guard_condition_t>)>();

  /// Return the guard condition options.
  /// /**
  ///  * Returned is a pointer to the internally held rcl_guard_condition_options_t.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - guard_condition is `NULL`
  ///  *   - guard_condition is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned pointer is made invalid if the guard condition is finalized.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] guard_condition pointer to the rcl guard_condition
  ///  * \return rcl guard condition options if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_guard_condition_options_t> rcl_guard_condition_get_options(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return _rcl_guard_condition_get_options(
      guard_condition,
    );
  }

  late final _rcl_guard_condition_get_optionsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rcl_guard_condition_options_t> Function(
                  ffi.Pointer<rcl_guard_condition_t>)>>(
      'rcl_guard_condition_get_options');
  late final _rcl_guard_condition_get_options =
      _rcl_guard_condition_get_optionsPtr.asFunction<
          ffi.Pointer<rcl_guard_condition_options_t> Function(
              ffi.Pointer<rcl_guard_condition_t>)>();

  /// Return the rmw guard condition handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - guard_condition is `NULL`
  ///  *   - guard_condition is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned handle is made invalid if the guard condition is finalized or
  ///  * if rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * guard condition as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the guard condition using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] guard_condition pointer to the rcl guard_condition
  ///  * \return rmw guard condition handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_guard_condition_t> rcl_guard_condition_get_rmw_handle(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return _rcl_guard_condition_get_rmw_handle(
      guard_condition,
    );
  }

  late final _rcl_guard_condition_get_rmw_handlePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rmw_guard_condition_t> Function(
                  ffi.Pointer<rcl_guard_condition_t>)>>(
      'rcl_guard_condition_get_rmw_handle');
  late final _rcl_guard_condition_get_rmw_handle =
      _rcl_guard_condition_get_rmw_handlePtr.asFunction<
          ffi.Pointer<rmw_guard_condition_t> Function(
              ffi.Pointer<rcl_guard_condition_t>)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _RCL_DOMAIN_ID_ENV_VAR =
      _lookup<ffi.Pointer<ffi.Char>>('RCL_DOMAIN_ID_ENV_VAR');

  ffi.Pointer<ffi.Char> get RCL_DOMAIN_ID_ENV_VAR =>
      _RCL_DOMAIN_ID_ENV_VAR.value;

  set RCL_DOMAIN_ID_ENV_VAR(ffi.Pointer<ffi.Char> value) =>
      _RCL_DOMAIN_ID_ENV_VAR.value = value;

  /// Determine the default domain ID, based on the environment.
  /// /**
  ///  * \param[out] domain_id Must not be NULL.
  ///  * \returns #RCL_RET_INVALID_ARGUMENT if an argument is invalid, or,
  ///  * \returns #RCL_RET_ERROR in case of an unexpected error, or,
  ///  * \returns #RCL_RET_OK.
  ///  */
  int rcl_get_default_domain_id(
    ffi.Pointer<ffi.Size> domain_id,
  ) {
    return _rcl_get_default_domain_id(
      domain_id,
    );
  }

  late final _rcl_get_default_domain_idPtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<ffi.Size>)>>(
          'rcl_get_default_domain_id');
  late final _rcl_get_default_domain_id = _rcl_get_default_domain_idPtr
      .asFunction<int Function(ffi.Pointer<ffi.Size>)>();

  /// Return the default node options in a rcl_node_options_t.
  /// /**
  ///  * The default values are:
  ///  *
  ///  * - allocator = rcl_get_default_allocator()
  ///  * - use_global_arguments = true
  ///  * - enable_rosout = true
  ///  * - arguments = rcl_get_zero_initialized_arguments()
  ///  * - rosout_qos = rcl_qos_profile_rosout_default
  ///  *
  ///  * \return A structure with the default node options.
  ///  */
  rcl_node_options_t rcl_node_get_default_options() {
    return _rcl_node_get_default_options();
  }

  late final _rcl_node_get_default_optionsPtr =
      _lookup<ffi.NativeFunction<rcl_node_options_t Function()>>(
          'rcl_node_get_default_options');
  late final _rcl_node_get_default_options = _rcl_node_get_default_optionsPtr
      .asFunction<rcl_node_options_t Function()>();

  /// Copy one options structure into another.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] options The structure to be copied.
  ///  *   Its allocator is used to copy memory into the new structure.
  ///  * \param[out] options_out An options structure containing default values.
  ///  * \return #RCL_RET_OK if the structure was copied successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any function arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_node_options_copy(
    ffi.Pointer<rcl_node_options_t> options,
    ffi.Pointer<rcl_node_options_t> options_out,
  ) {
    return _rcl_node_options_copy(
      options,
      options_out,
    );
  }

  late final _rcl_node_options_copyPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_node_options_t>,
              ffi.Pointer<rcl_node_options_t>)>>('rcl_node_options_copy');
  late final _rcl_node_options_copy = _rcl_node_options_copyPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_node_options_t>, ffi.Pointer<rcl_node_options_t>)>();

  /// Finalize the given node_options.
  /// /**
  ///  * The given node_options must be non-`NULL` and valid, i.e. had
  ///  * rcl_node_get_default_options() called on it but not this function yet.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] options object to be finalized
  ///  * \return #RCL_RET_OK if setup is successful, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_node_options_fini(
    ffi.Pointer<rcl_node_options_t> options,
  ) {
    return _rcl_node_options_fini(
      options,
    );
  }

  late final _rcl_node_options_finiPtr = _lookup<
          ffi
          .NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_node_options_t>)>>(
      'rcl_node_options_fini');
  late final _rcl_node_options_fini = _rcl_node_options_finiPtr
      .asFunction<int Function(ffi.Pointer<rcl_node_options_t>)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>>
      _RCL_DISABLE_LOANED_MESSAGES_ENV_VAR =
      _lookup<ffi.Pointer<ffi.Char>>('RCL_DISABLE_LOANED_MESSAGES_ENV_VAR');

  ffi.Pointer<ffi.Char> get RCL_DISABLE_LOANED_MESSAGES_ENV_VAR =>
      _RCL_DISABLE_LOANED_MESSAGES_ENV_VAR.value;

  set RCL_DISABLE_LOANED_MESSAGES_ENV_VAR(ffi.Pointer<ffi.Char> value) =>
      _RCL_DISABLE_LOANED_MESSAGES_ENV_VAR.value = value;

  /// Return a rcl_node_t struct with members initialized to `NULL`.
  rcl_node_t rcl_get_zero_initialized_node() {
    return _rcl_get_zero_initialized_node();
  }

  late final _rcl_get_zero_initialized_nodePtr =
      _lookup<ffi.NativeFunction<rcl_node_t Function()>>(
          'rcl_get_zero_initialized_node');
  late final _rcl_get_zero_initialized_node =
      _rcl_get_zero_initialized_nodePtr.asFunction<rcl_node_t Function()>();

  /// Initialize a ROS node.
  /// /**
  ///  * Calling this on a rcl_node_t makes it a valid node handle until rcl_shutdown
  ///  * is called or until rcl_node_fini is called on it.
  ///  *
  ///  * After calling, the ROS node object can be used to create other middleware
  ///  * primitives like publishers, services, parameters, etc.
  ///  *
  ///  * The name of the node must not be NULL and adhere to naming restrictions,
  ///  * see the rmw_validate_node_name() function for rules.
  ///  *
  ///  * \todo TODO(wjwwood): node name uniqueness is not yet enforced
  ///  *
  ///  * The name of the node cannot coincide with another node of the same name.
  ///  * If a node of the same name is already in the domain, it will be shutdown.
  ///  *
  ///  * The namespace of the node should not be NULL and should also pass the
  ///  * rmw_validate_namespace() function's rules.
  ///  *
  ///  * Additionally this function allows namespaces which lack a leading forward
  ///  * slash.
  ///  * Because there is no notion of a relative namespace, there is no difference
  ///  * between a namespace which lacks a forward and the same namespace with a
  ///  * leading forward slash.
  ///  * Therefore, a namespace like ``"foo/bar"`` is automatically changed to
  ///  * ``"/foo/bar"`` by this function.
  ///  * Similarly, the namespace ``""`` will implicitly become ``"/"`` which is a
  ///  * valid namespace.
  ///  *
  ///  * \todo TODO(wjwwood):
  ///  *   Parameter infrastructure is currently initialized in the language specific
  ///  *   client library, e.g. rclcpp for C++, but will be initialized here in the
  ///  *   future. When that happens there will be an option to avoid parameter
  ///  *   infrastructure with an option in the rcl_node_options_t struct.
  ///  *
  ///  * A node contains infrastructure for ROS parameters, which include advertising
  ///  * publishers and service servers.
  ///  * This function will create those external parameter interfaces even if
  ///  * parameters are not used later.
  ///  *
  ///  * The rcl_node_t given must be allocated and zero initialized.
  ///  * Passing an rcl_node_t which has already had this function called on it, more
  ///  * recently than rcl_node_fini, will fail.
  ///  * An allocated rcl_node_t with uninitialized memory is undefined behavior.
  ///  *
  ///  * Expected usage:
  ///  *
  ///  * ```c
  ///  * rcl_context_t context = rcl_get_zero_initialized_context();
  ///  * // ... initialize the context with rcl_init()
  ///  * rcl_node_t node = rcl_get_zero_initialized_node();
  ///  * rcl_node_options_t node_ops = rcl_node_get_default_options();
  ///  * // ... node options customization
  ///  * rcl_ret_t ret = rcl_node_init(&node, "node_name", "/node_ns", &context, &node_ops);
  ///  * // ... error handling and then use the node, but eventually deinitialize it:
  ///  * ret = rcl_node_fini(&node);
  ///  * // ... error handling for rcl_node_fini()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \pre the node handle must be allocated, zero initialized, and invalid
  ///  * \pre the context handle must be allocated, initialized, and valid
  ///  * \post the node handle is valid and can be used in other `rcl_*` functions
  ///  *
  ///  * \param[inout] node a preallocated rcl_node_t
  ///  * \param[in] name the name of the node, must be a valid c-string
  ///  * \param[in] namespace_ the namespace of the node, must be a valid c-string
  ///  * \param[in] context the context instance with which the node should be
  ///  *   associated
  ///  * \param[in] options the node options.
  ///  *   The options are deep copied into the node.
  ///  *   The caller is always responsible for freeing memory used options they
  ///  *   pass in.
  ///  * \return #RCL_RET_OK if the node was initialized successfully, or
  ///  * \return #RCL_RET_ALREADY_INIT if the node has already be initialized, or
  ///  * \return #RCL_RET_NOT_INIT if the given context is invalid, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_NODE_INVALID_NAME if the name is invalid, or
  ///  * \return #RCL_RET_NODE_INVALID_NAMESPACE if the namespace_ is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_node_init(
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> namespace_,
    ffi.Pointer<rcl_context_t> context,
    ffi.Pointer<rcl_node_options_t> options,
  ) {
    return _rcl_node_init(
      node,
      name,
      namespace_,
      context,
      options,
    );
  }

  late final _rcl_node_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_node_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<rcl_context_t>,
              ffi.Pointer<rcl_node_options_t>)>>('rcl_node_init');
  late final _rcl_node_init = _rcl_node_initPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_node_t>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<rcl_context_t>,
          ffi.Pointer<rcl_node_options_t>)>();

  /// Finalize a rcl_node_t.
  /// /**
  ///  * Destroys any automatically created infrastructure and deallocates memory.
  ///  * After calling, the rcl_node_t can be safely deallocated.
  ///  *
  ///  * All middleware primitives created by the user, e.g. publishers, services, etc,
  ///  * which were created from this node must be finalized using their respective
  ///  * `rcl_*_fini()` functions before this is called.
  ///  * \sa rcl_publisher_fini()
  ///  * \sa rcl_subscription_fini()
  ///  * \sa rcl_client_fini()
  ///  * \sa rcl_service_fini()
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] node rcl_node_t to be finalized
  ///  * \return #RCL_RET_OK if node was finalized successfully, or
  ///  * \return #RCL_RET_NODE_INVALID if the node pointer is null, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_node_fini(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_fini(
      node,
    );
  }

  late final _rcl_node_finiPtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_node_t>)>>(
          'rcl_node_fini');
  late final _rcl_node_fini =
      _rcl_node_finiPtr.asFunction<int Function(ffi.Pointer<rcl_node_t>)>();

  /// Return `true` if the node is valid, else `false`.
  /// /**
  ///  * Also return `false` if the node pointer is `NULL` or the allocator is invalid.
  ///  *
  ///  * A node is invalid if:
  ///  *   - the implementation is `NULL` (rcl_node_init not called or failed)
  ///  *   - rcl_shutdown has been called since the node has been initialized
  ///  *   - the node has been finalized with rcl_node_fini
  ///  *
  ///  * There is a possible validity race condition.
  ///  *
  ///  * Consider:
  ///  *
  ///  * ```c
  ///  * assert(rcl_node_is_valid(node));  // <-- thread 1
  ///  * rcl_shutdown();                   // <-- thread 2
  ///  * // use node as if valid           // <-- thread 1
  ///  * ```
  ///  *
  ///  * In the third line the node is now invalid, even though on the previous line
  ///  * of thread 1 it was checked to be valid.
  ///  * This is why this function is considered not thread-safe.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] node rcl_node_t to be validated
  ///  * \return `true` if the node and allocator are valid, otherwise `false`.
  ///  */
  bool rcl_node_is_valid(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_is_valid(
      node,
    );
  }

  late final _rcl_node_is_validPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_node_t>)>>(
          'rcl_node_is_valid');
  late final _rcl_node_is_valid = _rcl_node_is_validPtr
      .asFunction<bool Function(ffi.Pointer<rcl_node_t>)>();

  /// Return true if node is valid, except for the context being valid.
  /// /**
  ///  * This is used in clean up functions that need to access the node, but do not
  ///  * need use any functions with the context.
  ///  *
  ///  * It is identical to rcl_node_is_valid except it ignores the state of the
  ///  * context associated with the node.
  ///  * \sa rcl_node_is_valid()
  ///  */
  bool rcl_node_is_valid_except_context(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_is_valid_except_context(
      node,
    );
  }

  late final _rcl_node_is_valid_except_contextPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_node_t>)>>(
          'rcl_node_is_valid_except_context');
  late final _rcl_node_is_valid_except_context =
      _rcl_node_is_valid_except_contextPtr
          .asFunction<bool Function(ffi.Pointer<rcl_node_t>)>();

  /// Return the name of the node.
  /// /**
  ///  * This function returns the node's internal name string.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned string is only valid as long as the given rcl_node_t is valid.
  ///  * The value of the string may change if the value in the rcl_node_t changes,
  ///  * and therefore copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the node
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Char> rcl_node_get_name(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_name(
      node,
    );
  }

  late final _rcl_node_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<rcl_node_t>)>>('rcl_node_get_name');
  late final _rcl_node_get_name = _rcl_node_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcl_node_t>)>();

  /// Return the namespace of the node.
  /// /**
  ///  * This function returns the node's internal namespace string.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned string is only valid as long as the given rcl_node_t is valid.
  ///  * The value of the string may change if the value in the rcl_node_t changes,
  ///  * and therefore copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the node
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Char> rcl_node_get_namespace(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_namespace(
      node,
    );
  }

  late final _rcl_node_get_namespacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<rcl_node_t>)>>('rcl_node_get_namespace');
  late final _rcl_node_get_namespace = _rcl_node_get_namespacePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcl_node_t>)>();

  /// Return the fully qualified name of the node.
  /// /**
  ///  * This function returns the node's internal namespace and name combined string.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the node
  ///  * \return fully qualified name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Char> rcl_node_get_fully_qualified_name(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_fully_qualified_name(
      node,
    );
  }

  late final _rcl_node_get_fully_qualified_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<rcl_node_t>)>>('rcl_node_get_fully_qualified_name');
  late final _rcl_node_get_fully_qualified_name =
      _rcl_node_get_fully_qualified_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcl_node_t>)>();

  /// Return the rcl node options.
  /// /**
  ///  * This function returns the node's internal options struct.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned struct is only valid as long as the given rcl_node_t is valid.
  ///  * The values in the struct may change if the options of the rcl_node_t changes,
  ///  * and therefore copying the struct is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the node
  ///  * \return options struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_node_options_t> rcl_node_get_options(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_options(
      node,
    );
  }

  late final _rcl_node_get_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rcl_node_options_t> Function(
              ffi.Pointer<rcl_node_t>)>>('rcl_node_get_options');
  late final _rcl_node_get_options = _rcl_node_get_optionsPtr.asFunction<
      ffi.Pointer<rcl_node_options_t> Function(ffi.Pointer<rcl_node_t>)>();

  /// Return the ROS domain ID that the node is using.
  /// /**
  ///  * This function returns the ROS domain ID that the node is in.
  ///  *
  ///  * This function should be used to determine what `domain_id` was used rather
  ///  * than checking the domain_id field in the node options, because if
  ///  * #RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID is used when creating the node then
  ///  * it is not changed after creation, but this function will return the actual
  ///  * `domain_id` used.
  ///  *
  ///  * The `domain_id` field must point to an allocated `size_t` object to which
  ///  * the ROS domain ID will be written.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node the handle to the node being queried
  ///  * \param[out] domain_id storage for the domain id
  ///  * \return #RCL_RET_OK if node the domain ID was retrieved successfully, or
  ///  * \return #RCL_RET_NODE_INVALID if the node is invalid, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_node_get_domain_id(
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<ffi.Size> domain_id,
  ) {
    return _rcl_node_get_domain_id(
      node,
      domain_id,
    );
  }

  late final _rcl_node_get_domain_idPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_node_t>,
              ffi.Pointer<ffi.Size>)>>('rcl_node_get_domain_id');
  late final _rcl_node_get_domain_id = _rcl_node_get_domain_idPtr.asFunction<
      int Function(ffi.Pointer<rcl_node_t>, ffi.Pointer<ffi.Size>)>();

  /// Return the rmw node handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned handle is made invalid if the node is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * node as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the node using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the rcl node
  ///  * \return rmw node handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_node_t> rcl_node_get_rmw_handle(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_rmw_handle(
      node,
    );
  }

  late final _rcl_node_get_rmw_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_node_t> Function(
              ffi.Pointer<rcl_node_t>)>>('rcl_node_get_rmw_handle');
  late final _rcl_node_get_rmw_handle = _rcl_node_get_rmw_handlePtr
      .asFunction<ffi.Pointer<rmw_node_t> Function(ffi.Pointer<rcl_node_t>)>();

  /// Return the associated rcl instance id.
  /// /**
  ///  * This id is stored when rcl_node_init is called and can be compared with the
  ///  * value returned by rcl_get_instance_id() to check if this node was created in
  ///  * the current rcl context (since the latest call to rcl_init().
  ///  *
  ///  * This function can fail, and therefore return `0`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * This function will succeed even if rcl_shutdown() has been called
  ///  * since the node was created.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the rcl node
  ///  * \return rcl instance id captured during node init or `0` on error
  ///  */
  int rcl_node_get_rcl_instance_id(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_rcl_instance_id(
      node,
    );
  }

  late final _rcl_node_get_rcl_instance_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<rcl_node_t>)>>(
          'rcl_node_get_rcl_instance_id');
  late final _rcl_node_get_rcl_instance_id = _rcl_node_get_rcl_instance_idPtr
      .asFunction<int Function(ffi.Pointer<rcl_node_t>)>();

  /// Return a guard condition which is triggered when the ROS graph changes.
  /// /**
  ///  * The handle returned is a pointer to an internally held rcl guard condition.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node is invalid
  ///  *
  ///  * The returned handle is made invalid if the node is finialized or if
  ///  * rcl_shutdown() is called.
  ///  *
  ///  * The guard condition will be triggered anytime a change to the ROS graph occurs.
  ///  * A ROS graph change includes things like (but not limited to) a new publisher
  ///  * advertises, a new subscription is created, a new service becomes available,
  ///  * a subscription is canceled, etc.
  ///  *
  ///  * \todo TODO(wjwwood): link to exhaustive list of graph events
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the rcl node
  ///  * \return rcl guard condition handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_guard_condition_t> rcl_node_get_graph_guard_condition(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_graph_guard_condition(
      node,
    );
  }

  late final _rcl_node_get_graph_guard_conditionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rcl_guard_condition_t> Function(
              ffi.Pointer<rcl_node_t>)>>('rcl_node_get_graph_guard_condition');
  late final _rcl_node_get_graph_guard_condition =
      _rcl_node_get_graph_guard_conditionPtr.asFunction<
          ffi.Pointer<rcl_guard_condition_t> Function(
              ffi.Pointer<rcl_node_t>)>();

  /// Return the logger name of the node.
  /// /**
  ///  * This function returns the node's internal logger name string.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned string is only valid as long as the given rcl_node_t is valid.
  ///  * The value of the string may change if the value in the rcl_node_t changes,
  ///  * and therefore copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the node
  ///  * \return logger_name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Char> rcl_node_get_logger_name(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_logger_name(
      node,
    );
  }

  late final _rcl_node_get_logger_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<rcl_node_t>)>>('rcl_node_get_logger_name');
  late final _rcl_node_get_logger_name = _rcl_node_get_logger_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcl_node_t>)>();

  /// Expand a given name into a fully-qualified topic name and apply remapping rules.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node Node object. Its name, namespace, local/global command line arguments are used.
  ///  * \param[in] input_name Topic name to be expanded and remapped.
  ///  * \param[in] allocator The allocator to be used when creating the output topic.
  ///  * \param[in] is_service For services use `true`, for topics use `false`.
  ///  * \param[in] only_expand When `true`, remapping rules are ignored.
  ///  * \param[out] output_name Output char * pointer.
  ///  * \return #RCL_RET_OK if the topic name was expanded successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any of input_name, node_name, node_namespace
  ///  *  or output_name are NULL, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if both local_args and global_args are NULL, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_TOPIC_NAME_INVALID if the given topic name is invalid
  ///  *  (see rcl_validate_topic_name()), or
  ///  * \return #RCL_RET_NODE_INVALID_NAME if the given node name is invalid
  ///  *  (see rmw_validate_node_name()), or
  ///  * \return #RCL_RET_NODE_INVALID_NAMESPACE if the given node namespace is invalid
  ///  *  (see rmw_validate_namespace()), or
  ///  * \return #RCL_RET_UNKNOWN_SUBSTITUTION for unknown substitutions in name, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_node_resolve_name(
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<ffi.Char> input_name,
    rcl_allocator_t allocator,
    bool is_service,
    bool only_expand,
    ffi.Pointer<ffi.Pointer<ffi.Char>> output_name,
  ) {
    return _rcl_node_resolve_name(
      node,
      input_name,
      allocator,
      is_service,
      only_expand,
      output_name,
    );
  }

  late final _rcl_node_resolve_namePtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_node_t>,
              ffi.Pointer<ffi.Char>,
              rcl_allocator_t,
              ffi.Bool,
              ffi.Bool,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('rcl_node_resolve_name');
  late final _rcl_node_resolve_name = _rcl_node_resolve_namePtr.asFunction<
      int Function(ffi.Pointer<rcl_node_t>, ffi.Pointer<ffi.Char>,
          rcl_allocator_t, bool, bool, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Check if loaned message is disabled, according to the environment variable.
  /// /**
  ///  * If the `ROS_DISABLE_LOANED_MESSAGES` environment variable is set to "1",
  ///  * `disable_loaned_message` will be set to true.
  ///  *
  ///  * \param[out] disable_loaned_message Must not be NULL.
  ///  * \return #RCL_RET_INVALID_ARGUMENT if an argument is not valid, or
  ///  * \return #RCL_RET_ERROR if an unexpected error happened, or
  ///  * \return #RCL_RET_OK.
  ///  */
  int rcl_get_disable_loaned_message(
    ffi.Pointer<ffi.Bool> disable_loaned_message,
  ) {
    return _rcl_get_disable_loaned_message(
      disable_loaned_message,
    );
  }

  late final _rcl_get_disable_loaned_messagePtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<ffi.Bool>)>>(
          'rcl_get_disable_loaned_message');
  late final _rcl_get_disable_loaned_message =
      _rcl_get_disable_loaned_messagePtr
          .asFunction<int Function(ffi.Pointer<ffi.Bool>)>();

  /// Get the message type support handle specific to this identifier.
  /// /**
  ///  * The handle's message typesupport identifier function is returned or if the parameters are NULL
  ///  * then an assert will happen.
  ///  *
  ///  * \param handle Handle to message type support
  ///  * \param identifier The typesupport identifier to get the handle function for
  ///  * \return The associated message typesupport handle function.
  ///  */
  ffi.Pointer<rosidl_message_type_support_t> get_message_typesupport_handle(
    ffi.Pointer<rosidl_message_type_support_t> handle,
    ffi.Pointer<ffi.Char> identifier,
  ) {
    return _get_message_typesupport_handle(
      handle,
      identifier,
    );
  }

  late final _get_message_typesupport_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rosidl_message_type_support_t> Function(
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<ffi.Char>)>>('get_message_typesupport_handle');
  late final _get_message_typesupport_handle =
      _get_message_typesupport_handlePtr.asFunction<
          ffi.Pointer<rosidl_message_type_support_t> Function(
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the message type support handle function specific to this identifier.
  /// /**
  ///  * If the identifier is the same as this handle's typesupport_identifier the handle is simply
  ///  * returned or if the parameters are NULL then an assert will happen.
  ///  *
  ///  * \param handle Handle to message type support
  ///  * \param identifier The typesupport identifier to get the handle function for
  ///  * \return if the identifier match's the handle's identifier then the handle's function
  ///  *   is returned.
  ///  */
  ffi.Pointer<rosidl_message_type_support_t>
      get_message_typesupport_handle_function(
    ffi.Pointer<rosidl_message_type_support_t> handle,
    ffi.Pointer<ffi.Char> identifier,
  ) {
    return _get_message_typesupport_handle_function(
      handle,
      identifier,
    );
  }

  late final _get_message_typesupport_handle_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rosidl_message_type_support_t> Function(
                  ffi.Pointer<rosidl_message_type_support_t>,
                  ffi.Pointer<ffi.Char>)>>(
      'get_message_typesupport_handle_function');
  late final _get_message_typesupport_handle_function =
      _get_message_typesupport_handle_functionPtr.asFunction<
          ffi.Pointer<rosidl_message_type_support_t> Function(
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<ffi.Char>)>();

  /// Check if the clock has started.
  /// /**
  ///  * This function returns true if the clock contains a time point value
  ///  * that is non-zero.
  ///  * Note that if data is uninitialized it may give a false positive.
  ///  *
  ///  * This function is primarily used to check if a clock using ROS time
  ///  * has started. This is because it is possible that a simulator might be
  ///  * initialized paused, causing ROS time to be 0 until it is unpaused.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] clock the handle to the clock which is being queried
  ///  * \return true if the clock has started, otherwise return false.
  ///  */
  bool rcl_clock_time_started(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_clock_time_started(
      clock,
    );
  }

  late final _rcl_clock_time_startedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_clock_t>)>>(
          'rcl_clock_time_started');
  late final _rcl_clock_time_started = _rcl_clock_time_startedPtr
      .asFunction<bool Function(ffi.Pointer<rcl_clock_t>)>();

  /// Check if the clock has valid values.
  /// /**
  ///  * This function returns true if the time source appears to be valid.
  ///  * It will check that the type is not uninitialized, and that pointers
  ///  * are not invalid.
  ///  * Note that if data is uninitialized it may give a false positive.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] clock the handle to the clock which is being queried
  ///  * \return true if the source is believed to be valid, otherwise return false.
  ///  */
  bool rcl_clock_valid(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_clock_valid(
      clock,
    );
  }

  late final _rcl_clock_validPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_clock_t>)>>(
          'rcl_clock_valid');
  late final _rcl_clock_valid =
      _rcl_clock_validPtr.asFunction<bool Function(ffi.Pointer<rcl_clock_t>)>();

  /// Initialize a clock based on the passed type.
  /// /**
  ///  * This will allocate all necessary internal structures, and initialize variables.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes [1]
  ///  * Thread-Safe        | No [2]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] If `clock_type` is #RCL_ROS_TIME</i>
  ///  * <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  ///  *        Thread-safety is also affected by that of the `allocator` object.</i>
  ///  *
  ///  * \param[in] clock_type the type identifying the time source to provide
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \param[in] allocator The allocator to use for allocations
  ///  * \return #RCL_RET_OK if the time source was successfully initialized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_clock_init(
    int clock_type,
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcl_allocator_t> allocator,
  ) {
    return _rcl_clock_init(
      clock_type,
      clock,
      allocator,
    );
  }

  late final _rcl_clock_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Int32, ffi.Pointer<rcl_clock_t>,
              ffi.Pointer<rcl_allocator_t>)>>('rcl_clock_init');
  late final _rcl_clock_init = _rcl_clock_initPtr.asFunction<
      int Function(
          int, ffi.Pointer<rcl_clock_t>, ffi.Pointer<rcl_allocator_t>)>();

  /// Finalize a clock.
  /// /**
  ///  * This will deallocate all necessary internal structures, and clean up any variables.
  ///  * It can be combined with any of the init functions.
  ///  *
  ///  * Passing a clock with type #RCL_CLOCK_UNINITIALIZED will result in
  ///  * #RCL_RET_INVALID_ARGUMENT being returned.
  ///  *
  ///  * This function is not thread-safe with any other function operating on the same
  ///  * clock object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  ///  *        Thread-safety is also affected by that of the `allocator` object associated with the
  ///  *        `clock` object.</i>
  ///  *
  ///  * \param[in] clock the handle to the clock which is being finalized
  ///  * \return #RCL_RET_OK if the time source was successfully finalized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_clock_fini(
      clock,
    );
  }

  late final _rcl_clock_finiPtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_clock_t>)>>(
          'rcl_clock_fini');
  late final _rcl_clock_fini =
      _rcl_clock_finiPtr.asFunction<int Function(ffi.Pointer<rcl_clock_t>)>();

  /// Initialize a clock as a #RCL_ROS_TIME time source.
  /// /**
  ///  * This will allocate all necessary internal structures, and initialize variables.
  ///  * It is specifically setting up a #RCL_ROS_TIME time source.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  ///  *        Thread-safety is also affected by that of the `allocator` object.</i>
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \param[in] allocator The allocator to use for allocations
  ///  * \return #RCL_RET_OK if the time source was successfully initialized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_ros_clock_init(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcl_allocator_t> allocator,
  ) {
    return _rcl_ros_clock_init(
      clock,
      allocator,
    );
  }

  late final _rcl_ros_clock_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_clock_t>,
              ffi.Pointer<rcl_allocator_t>)>>('rcl_ros_clock_init');
  late final _rcl_ros_clock_init = _rcl_ros_clock_initPtr.asFunction<
      int Function(ffi.Pointer<rcl_clock_t>, ffi.Pointer<rcl_allocator_t>)>();

  /// Finalize a clock as a #RCL_ROS_TIME time source.
  /// /**
  ///  * This will deallocate all necessary internal structures, and clean up any variables.
  ///  * It is specifically setting up a #RCL_ROS_TIME time source. It is expected
  ///  * to be paired with the init fuction.
  ///  *
  ///  * This function is not thread-safe with any other function operating on the same
  ///  * clock object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  ///  *        Thread-safety is also affected by that of the `allocator` object associated with the
  ///  *        `clock` object.</i>
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \return #RCL_RET_OK if the time source was successfully finalized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_ros_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_ros_clock_fini(
      clock,
    );
  }

  late final _rcl_ros_clock_finiPtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_clock_t>)>>(
          'rcl_ros_clock_fini');
  late final _rcl_ros_clock_fini = _rcl_ros_clock_finiPtr
      .asFunction<int Function(ffi.Pointer<rcl_clock_t>)>();

  /// Initialize a clock as a #RCL_STEADY_TIME time source.
  /// /**
  ///  * This will allocate all necessary internal structures, and initialize variables.
  ///  * It is specifically setting up a #RCL_STEADY_TIME time source.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  ///  *        Thread-safety is also affected by that of the `allocator` object.</i>
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \param[in] allocator The allocator to use for allocations
  ///  * \return #RCL_RET_OK if the time source was successfully initialized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_steady_clock_init(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcl_allocator_t> allocator,
  ) {
    return _rcl_steady_clock_init(
      clock,
      allocator,
    );
  }

  late final _rcl_steady_clock_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_clock_t>,
              ffi.Pointer<rcl_allocator_t>)>>('rcl_steady_clock_init');
  late final _rcl_steady_clock_init = _rcl_steady_clock_initPtr.asFunction<
      int Function(ffi.Pointer<rcl_clock_t>, ffi.Pointer<rcl_allocator_t>)>();

  /// Finalize a clock as a #RCL_STEADY_TIME time source.
  /// /**
  ///  * Finalize the clock as a #RCL_STEADY_TIME time source.
  ///  *
  ///  * This will deallocate all necessary internal structures, and clean up any variables.
  ///  * It is specifically setting up a steady time source. It is expected to be
  ///  * paired with the init fuction.
  ///  *
  ///  * This function is not thread-safe with any other function operating on the same
  ///  * clock object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  ///  *        Thread-safety is also affected by that of the `allocator` object associated with the
  ///  *        `clock` object.</i>
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \return #RCL_RET_OK if the time source was successfully finalized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_steady_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_steady_clock_fini(
      clock,
    );
  }

  late final _rcl_steady_clock_finiPtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_clock_t>)>>(
          'rcl_steady_clock_fini');
  late final _rcl_steady_clock_fini = _rcl_steady_clock_finiPtr
      .asFunction<int Function(ffi.Pointer<rcl_clock_t>)>();

  /// Initialize a clock as a #RCL_SYSTEM_TIME time source.
  /// /**
  ///  * Initialize the clock as a #RCL_SYSTEM_TIME time source.
  ///  *
  ///  * This will allocate all necessary internal structures, and initialize variables.
  ///  * It is specifically setting up a system time source.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  ///  *        Thread-safety is also affected by that of the `allocator` object associated with the
  ///  *        `clock` object.</i>
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \param[in] allocator The allocator to use for allocations
  ///  * \return #RCL_RET_OK if the time source was successfully initialized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_system_clock_init(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcl_allocator_t> allocator,
  ) {
    return _rcl_system_clock_init(
      clock,
      allocator,
    );
  }

  late final _rcl_system_clock_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_clock_t>,
              ffi.Pointer<rcl_allocator_t>)>>('rcl_system_clock_init');
  late final _rcl_system_clock_init = _rcl_system_clock_initPtr.asFunction<
      int Function(ffi.Pointer<rcl_clock_t>, ffi.Pointer<rcl_allocator_t>)>();

  /// Finalize a clock as a #RCL_SYSTEM_TIME time source.
  /// /**
  ///  * Finalize the clock as a #RCL_SYSTEM_TIME time source.
  ///  *
  ///  * This will deallocate all necessary internal structures, and clean up any variables.
  ///  * It is specifically setting up a system time source. It is expected to be paired with
  ///  * the init fuction.
  ///  *
  ///  * This function is not thread-safe with any function operating on the same clock object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  ///  *        Thread-safety is also affected by that of the `allocator` object associated with the
  ///  *        `clock` object.</i>
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized.
  ///  * \return #RCL_RET_OK if the time source was successfully finalized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_system_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_system_clock_fini(
      clock,
    );
  }

  late final _rcl_system_clock_finiPtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_clock_t>)>>(
          'rcl_system_clock_fini');
  late final _rcl_system_clock_fini = _rcl_system_clock_finiPtr
      .asFunction<int Function(ffi.Pointer<rcl_clock_t>)>();

  /// Compute the difference between two time points
  /// /**
  ///  * This function takes two time points and computes the duration between them.
  ///  * The two time points must be using the same time abstraction, and the
  ///  * resultant duration will also be of the same abstraction.
  ///  *
  ///  * The value will be computed as duration = finish - start. If start is after
  ///  * finish the duration will be negative.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] start The time point for the start of the duration.
  ///  * \param[in] finish The time point for the end of the duration.
  ///  * \param[out] delta The duration between the start and finish.
  ///  * \return #RCL_RET_OK if the difference was computed successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_difference_times(
    ffi.Pointer<rcl_time_point_t> start,
    ffi.Pointer<rcl_time_point_t> finish,
    ffi.Pointer<rcl_duration_t> delta,
  ) {
    return _rcl_difference_times(
      start,
      finish,
      delta,
    );
  }

  late final _rcl_difference_timesPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_time_point_t>,
              ffi.Pointer<rcl_time_point_t>,
              ffi.Pointer<rcl_duration_t>)>>('rcl_difference_times');
  late final _rcl_difference_times = _rcl_difference_timesPtr.asFunction<
      int Function(ffi.Pointer<rcl_time_point_t>, ffi.Pointer<rcl_time_point_t>,
          ffi.Pointer<rcl_duration_t>)>();

  /// Fill the time point value with the current value of the associated clock.
  /// /**
  ///  * This function will populate the data of the time_point_value object with the
  ///  * current value from it's associated time abstraction.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes [1]
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] If `clock` is of #RCL_ROS_TIME type.</i>
  ///  *
  ///  * \param[in] clock The time source from which to set the value.
  ///  * \param[out] time_point_value The time_point value to populate.
  ///  * \return #RCL_RET_OK if the last call time was retrieved successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_clock_get_now(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcl_time_point_value_t> time_point_value,
  ) {
    return _rcl_clock_get_now(
      clock,
      time_point_value,
    );
  }

  late final _rcl_clock_get_nowPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_clock_t>,
              ffi.Pointer<rcl_time_point_value_t>)>>('rcl_clock_get_now');
  late final _rcl_clock_get_now = _rcl_clock_get_nowPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_clock_t>, ffi.Pointer<rcl_time_point_value_t>)>();

  /// Enable the ROS time abstraction override.
  /// /**
  ///  * This method will enable the ROS time abstraction override values,
  ///  * such that the time source will report the set value instead of falling
  ///  * back to system time.
  ///  *
  ///  * This function is not thread-safe with rcl_clock_add_jump_callback(),
  ///  * nor rcl_clock_remove_jump_callback() functions when used on the same
  ///  * clock object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence [1]
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No [2]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>
  ///  * <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>
  ///  *
  ///  * \param[in] clock The clock to enable.
  ///  * \return #RCL_RET_OK if the time source was enabled successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_enable_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_enable_ros_time_override(
      clock,
    );
  }

  late final _rcl_enable_ros_time_overridePtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_clock_t>)>>(
          'rcl_enable_ros_time_override');
  late final _rcl_enable_ros_time_override = _rcl_enable_ros_time_overridePtr
      .asFunction<int Function(ffi.Pointer<rcl_clock_t>)>();

  /// Disable the ROS time abstraction override.
  /// /**
  ///  * This method will disable the #RCL_ROS_TIME time abstraction override values,
  ///  * such that the time source will report the system time even if a custom
  ///  * value has been set.
  ///  *
  ///  * This function is not thread-safe with rcl_clock_add_jump_callback(),
  ///  * nor rcl_clock_remove_jump_callback() functions when used on the same
  ///  * clock object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence [1]
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No [2]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>
  ///  * <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>
  ///  *
  ///  * \param[in] clock The clock to disable.
  ///  * \return #RCL_RET_OK if the time source was disabled successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_disable_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_disable_ros_time_override(
      clock,
    );
  }

  late final _rcl_disable_ros_time_overridePtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_clock_t>)>>(
          'rcl_disable_ros_time_override');
  late final _rcl_disable_ros_time_override = _rcl_disable_ros_time_overridePtr
      .asFunction<int Function(ffi.Pointer<rcl_clock_t>)>();

  /// Check if the #RCL_ROS_TIME time source has the override enabled.
  /// /**
  ///  * This will populate the is_enabled object to indicate if the
  ///  * time overide is enabled. If it is enabled, the set value will be returned.
  ///  * Otherwise this time source will return the equivalent to system time abstraction.
  ///  *
  ///  * This function is not thread-safe with rcl_enable_ros_time_override() nor
  ///  * rcl_disable_ros_time_override() functions when used on the same clock object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>
  ///  *
  ///  * \param[in] clock The clock to query.
  ///  * \param[out] is_enabled Whether the override is enabled..
  ///  * \return #RCL_RET_OK if the time source was queried successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_is_enabled_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<ffi.Bool> is_enabled,
  ) {
    return _rcl_is_enabled_ros_time_override(
      clock,
      is_enabled,
    );
  }

  late final _rcl_is_enabled_ros_time_overridePtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_clock_t>,
              ffi.Pointer<ffi.Bool>)>>('rcl_is_enabled_ros_time_override');
  late final _rcl_is_enabled_ros_time_override =
      _rcl_is_enabled_ros_time_overridePtr.asFunction<
          int Function(ffi.Pointer<rcl_clock_t>, ffi.Pointer<ffi.Bool>)>();

  /// Set the current time for this #RCL_ROS_TIME time source.
  /// /**
  ///  * This function will update the internal storage for the #RCL_ROS_TIME
  ///  * time source.
  ///  * If queried and override enabled the time source will return this value,
  ///  * otherwise it will return the system time.
  ///  *
  ///  * This function is not thread-safe with rcl_clock_add_jump_callback(),
  ///  * nor rcl_clock_remove_jump_callback() functions when used on the same
  ///  * clock object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence [1]
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No [2]
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>
  ///  * <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>
  ///  *
  ///  * \param[in] clock The clock to update.
  ///  * \param[in] time_value The new current time.
  ///  * \return #RCL_RET_OK if the time source was set successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_set_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
    int time_value,
  ) {
    return _rcl_set_ros_time_override(
      clock,
      time_value,
    );
  }

  late final _rcl_set_ros_time_overridePtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_clock_t>,
              rcl_time_point_value_t)>>('rcl_set_ros_time_override');
  late final _rcl_set_ros_time_override = _rcl_set_ros_time_overridePtr
      .asFunction<int Function(ffi.Pointer<rcl_clock_t>, int)>();

  /// Add a callback to be called when a time jump exceeds a threshold.
  /// /**
  ///  * The callback is called twice when the threshold is exceeded: once before the clock is
  ///  * updated, and once after.
  ///  * The user_data pointer is passed to the callback as the last argument.
  ///  * A callback and user_data pair must be unique among the callbacks added to a clock.
  ///  *
  ///  * This function is not thread-safe with rcl_clock_remove_jump_callback(),
  ///  * rcl_enable_ros_time_override(), rcl_disable_ros_time_override() nor
  ///  * rcl_set_ros_time_override() functions when used on the same clock object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  ///  *        Thread-safety is also affected by that of the `allocator` object associated with the
  ///  *        `clock` object.</i>
  ///  *
  ///  * \param[in] clock A clock to add a jump callback to.
  ///  * \param[in] threshold Criteria indicating when to call the callback.
  ///  * \param[in] callback A callback to call.
  ///  * \param[in] user_data A pointer to be passed to the callback.
  ///  * \return #RCL_RET_OK if the callback was added successfully, or
  ///  * \return #RCL_RET_BAD_ALLOC if a memory allocation failed, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occurs.
  ///  */
  int rcl_clock_add_jump_callback(
    ffi.Pointer<rcl_clock_t> clock,
    rcl_jump_threshold_t threshold,
    rcl_jump_callback_t callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rcl_clock_add_jump_callback(
      clock,
      threshold,
      callback,
      user_data,
    );
  }

  late final _rcl_clock_add_jump_callbackPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_clock_t>,
              rcl_jump_threshold_t,
              rcl_jump_callback_t,
              ffi.Pointer<ffi.Void>)>>('rcl_clock_add_jump_callback');
  late final _rcl_clock_add_jump_callback =
      _rcl_clock_add_jump_callbackPtr.asFunction<
          int Function(ffi.Pointer<rcl_clock_t>, rcl_jump_threshold_t,
              rcl_jump_callback_t, ffi.Pointer<ffi.Void>)>();

  /// Remove a previously added time jump callback.
  /// /**
  ///  * This function is not thread-safe with rcl_clock_add_jump_callback()
  ///  * rcl_enable_ros_time_override(), rcl_disable_ros_time_override() nor
  ///  * rcl_set_ros_time_override() functions when used on the same clock object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  ///  *        Thread-safety is also affected by that of the `allocator` object associated with the
  ///  *        `clock` object.</i>
  ///  *
  ///  * \param[in] clock The clock to remove a jump callback from.
  ///  * \param[in] callback The callback to call.
  ///  * \param[in] user_data A pointer to be passed to the callback.
  ///  * \return #RCL_RET_OK if the callback was added successfully, or
  ///  * \return #RCL_RET_BAD_ALLOC if a memory allocation failed, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ERROR the callback was not found or an unspecified error occurs.
  ///  */
  int rcl_clock_remove_jump_callback(
    ffi.Pointer<rcl_clock_t> clock,
    rcl_jump_callback_t callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rcl_clock_remove_jump_callback(
      clock,
      callback,
      user_data,
    );
  }

  late final _rcl_clock_remove_jump_callbackPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_clock_t>, rcl_jump_callback_t,
              ffi.Pointer<ffi.Void>)>>('rcl_clock_remove_jump_callback');
  late final _rcl_clock_remove_jump_callback =
      _rcl_clock_remove_jump_callbackPtr.asFunction<
          int Function(ffi.Pointer<rcl_clock_t>, rcl_jump_callback_t,
              ffi.Pointer<ffi.Void>)>();

  /// Return a rcl_publisher_t struct with members set to `NULL`.
  /// /**
  ///  * Should be called to get a null rcl_publisher_t before passing to
  ///  * rcl_publisher_init().
  ///  */
  rcl_publisher_t rcl_get_zero_initialized_publisher() {
    return _rcl_get_zero_initialized_publisher();
  }

  late final _rcl_get_zero_initialized_publisherPtr =
      _lookup<ffi.NativeFunction<rcl_publisher_t Function()>>(
          'rcl_get_zero_initialized_publisher');
  late final _rcl_get_zero_initialized_publisher =
      _rcl_get_zero_initialized_publisherPtr
          .asFunction<rcl_publisher_t Function()>();

  /// Initialize a rcl publisher.
  /// /**
  ///  * After calling this function on a rcl_publisher_t, it can be used to publish
  ///  * messages of the given type to the given topic using rcl_publish().
  ///  *
  ///  * The given rcl_node_t must be valid and the resulting rcl_publisher_t is only
  ///  * valid as long as the given rcl_node_t remains valid.
  ///  *
  ///  * The rosidl_message_type_support_t is obtained on a per .msg type basis.
  ///  * When the user defines a ROS message, code is generated which provides the
  ///  * required rosidl_message_type_support_t object.
  ///  * This object can be obtained using a language appropriate mechanism.
  ///  * \todo TODO(wjwwood) write these instructions once and link to it instead
  ///  *
  ///  * For C, a macro can be used (for example `std_msgs/String`):
  ///  *
  ///  * ```c
  ///  * #include <rosidl_runtime_c/message_type_support_struct.h>
  ///  * #include <std_msgs/msg/string.h>
  ///  * const rosidl_message_type_support_t * string_ts =
  ///  *   ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  ///  * ```
  ///  *
  ///  * For C++, a template function is used:
  ///  *
  ///  * ```cpp
  ///  * #include <rosidl_typesupport_cpp/message_type_support.hpp>
  ///  * #include <std_msgs/msg/string.hpp>
  ///  * const rosidl_message_type_support_t * string_ts =
  ///  *   rosidl_typesupport_cpp::get_message_type_support_handle<std_msgs::msg::String>();
  ///  * ```
  ///  *
  ///  * The rosidl_message_type_support_t object contains message type specific
  ///  * information used to publish messages.
  ///  *
  ///  * The topic name must be a c string which follows the topic and service name
  ///  * format rules for unexpanded names, also known as non-fully qualified names:
  ///  *
  ///  * \see rcl_expand_topic_name
  ///  *
  ///  * The options struct allows the user to set the quality of service settings as
  ///  * well as a custom allocator which is used when initializing/finalizing the
  ///  * publisher to allocate space for incidentals, e.g. the topic name string.
  ///  *
  ///  * Expected usage (for C messages):
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  * #include <rosidl_runtime_c/message_type_support_struct.h>
  ///  * #include <std_msgs/msg/string.h>
  ///  *
  ///  * rcl_node_t node = rcl_get_zero_initialized_node();
  ///  * rcl_node_options_t node_ops = rcl_node_get_default_options();
  ///  * rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  ///  * // ... error handling
  ///  * const rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  ///  * rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();
  ///  * rcl_publisher_options_t publisher_ops = rcl_publisher_get_default_options();
  ///  * ret = rcl_publisher_init(&publisher, &node, ts, "chatter", &publisher_ops);
  ///  * // ... error handling, and on shutdown do finalization:
  ///  * ret = rcl_publisher_fini(&publisher, &node);
  ///  * // ... error handling for rcl_publisher_fini()
  ///  * ret = rcl_node_fini(&node);
  ///  * // ... error handling for rcl_deinitialize_node()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] publisher preallocated publisher structure
  ///  * \param[in] node valid rcl node handle
  ///  * \param[in] type_support type support object for the topic's type
  ///  * \param[in] topic_name the name of the topic to publish on
  ///  * \param[in] options publisher options, including quality of service settings
  ///  * \return #RCL_RET_OK if the publisher was initialized successfully, or
  ///  * \return #RCL_RET_NODE_INVALID if the node is invalid, or
  ///  * \return #RCL_RET_ALREADY_INIT if the publisher is already initialized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory fails, or
  ///  * \return #RCL_RET_TOPIC_NAME_INVALID if the given topic name is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_publisher_init(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Char> topic_name,
    ffi.Pointer<rcl_publisher_options_t> options,
  ) {
    return _rcl_publisher_init(
      publisher,
      node,
      type_support,
      topic_name,
      options,
    );
  }

  late final _rcl_publisher_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_publisher_t>,
              ffi.Pointer<rcl_node_t>,
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<rcl_publisher_options_t>)>>('rcl_publisher_init');
  late final _rcl_publisher_init = _rcl_publisher_initPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_publisher_t>,
          ffi.Pointer<rcl_node_t>,
          ffi.Pointer<rosidl_message_type_support_t>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<rcl_publisher_options_t>)>();

  /// Finalize a rcl_publisher_t.
  /// /**
  ///  * After calling, the node will no longer be advertising that it is publishing
  ///  * on this topic (assuming this is the only publisher on this topic).
  ///  *
  ///  * After calling, calls to rcl_publish will fail when using this publisher.
  ///  * However, the given node handle is still valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] publisher handle to the publisher to be finalized
  ///  * \param[in] node a valid (not finalized) handle to the node used to create the publisher
  ///  * \return #RCL_RET_OK if publisher was finalized successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or
  ///  * \return #RCL_RET_NODE_INVALID if the node is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_publisher_fini(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_publisher_fini(
      publisher,
      node,
    );
  }

  late final _rcl_publisher_finiPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_publisher_t>,
              ffi.Pointer<rcl_node_t>)>>('rcl_publisher_fini');
  late final _rcl_publisher_fini = _rcl_publisher_finiPtr.asFunction<
      int Function(ffi.Pointer<rcl_publisher_t>, ffi.Pointer<rcl_node_t>)>();

  /// Return the default publisher options in a rcl_publisher_options_t.
  /// /**
  ///  * The defaults are:
  ///  *
  ///  * - qos = rmw_qos_profile_default
  ///  * - allocator = rcl_get_default_allocator()
  ///  * - rmw_publisher_options = rmw_get_default_publisher_options()
  ///  *
  ///  * \return A structure with the default publisher options.
  ///  */
  rcl_publisher_options_t rcl_publisher_get_default_options() {
    return _rcl_publisher_get_default_options();
  }

  late final _rcl_publisher_get_default_optionsPtr =
      _lookup<ffi.NativeFunction<rcl_publisher_options_t Function()>>(
          'rcl_publisher_get_default_options');
  late final _rcl_publisher_get_default_options =
      _rcl_publisher_get_default_optionsPtr
          .asFunction<rcl_publisher_options_t Function()>();

  /// Borrow a loaned message.
  /// /**
  ///  * The memory allocated for the ros message belongs to the middleware and must not be deallocated
  ///  * other than by a call to \sa rcl_return_loaned_message_from_publisher.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No [0]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * [0] the underlying middleware might allocate new memory or returns an existing chunk form a pool.
  ///  * The function in rcl however does not allocate any additional memory.
  ///  *
  ///  * \param[in] publisher Publisher to which the allocated message is associated.
  ///  * \param[in] type_support Typesupport to which the internal ros message is allocated.
  ///  * \param[out] ros_message The pointer to be filled to a valid ros message by the middleware.
  ///  * \return #RCL_RET_OK if the ros message was correctly initialized, or
  ///  * \return #RCL_RET_PUBLISHER_INVALID if the passed publisher is invalid, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if an argument other than the ros message is null, or
  ///  * \return #RCL_RET_BAD_ALLOC if the ros message could not be correctly created, or
  ///  * \return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or
  ///  * \return #RCL_RET_ERROR if an unexpected error occured.
  ///  */
  int rcl_borrow_loaned_message(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
  ) {
    return _rcl_borrow_loaned_message(
      publisher,
      type_support,
      ros_message,
    );
  }

  late final _rcl_borrow_loaned_messagePtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_publisher_t>,
                  ffi.Pointer<rosidl_message_type_support_t>,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'rcl_borrow_loaned_message');
  late final _rcl_borrow_loaned_message =
      _rcl_borrow_loaned_messagePtr.asFunction<
          int Function(
              ffi.Pointer<rcl_publisher_t>,
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Return a loaned message previously borrowed from a publisher.
  /// /**
  ///  * The ownership of the passed in ros message will be transferred back to the middleware.
  ///  * The middleware might deallocate and destroy the message so that the pointer is no longer
  ///  * guaranteed to be valid after that call.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher Publisher to which the loaned message is associated.
  ///  * \param[in] loaned_message Loaned message to be deallocated and destroyed.
  ///  * \return #RCL_RET_OK if successful, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if an argument is null, or
  ///  * \return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or
  ///  * \return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or
  ///  * \return #RCL_RET_ERROR if an unexpected error occurs and no message can be initialized.
  ///  */
  int rcl_return_loaned_message_from_publisher(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return _rcl_return_loaned_message_from_publisher(
      publisher,
      loaned_message,
    );
  }

  late final _rcl_return_loaned_message_from_publisherPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_publisher_t>, ffi.Pointer<ffi.Void>)>>(
      'rcl_return_loaned_message_from_publisher');
  late final _rcl_return_loaned_message_from_publisher =
      _rcl_return_loaned_message_from_publisherPtr.asFunction<
          int Function(ffi.Pointer<rcl_publisher_t>, ffi.Pointer<ffi.Void>)>();

  /// Publish a ROS message on a topic using a publisher.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the ros_message
  ///  * parameter and the type associate with the publisher (via the type support)
  ///  * match.
  ///  * Passing a different type to publish produces undefined behavior and cannot
  ///  * be checked by this function and therefore no deliberate error will occur.
  ///  *
  ///  * \todo TODO(wjwwood):
  ///  *   The blocking behavior of publish is a still a point of dispute.
  ///  *   This section should be updated once the behavior is clearly defined.
  ///  *   See: https://github.com/ros2/ros2/issues/255
  ///  *
  ///  * Calling rcl_publish() is a potentially blocking call.
  ///  * When called rcl_publish() will immediately do any publishing related work,
  ///  * including, but not limited to, converting the message into a different type,
  ///  * serializing the message, collecting publish statistics, etc.
  ///  * The last thing it will do is call the underlying middleware's publish
  ///  * function which may or may not block based on the quality of service settings
  ///  * given via the publisher options in rcl_publisher_init().
  ///  * For example, if the reliability is set to reliable, then a publish may block
  ///  * until space in the publish queue is available, but if the reliability is set
  ///  * to best effort then it should not block.
  ///  *
  ///  * The ROS message given by the `ros_message` void pointer is always owned by
  ///  * the calling code, but should remain constant during publish.
  ///  *
  ///  * This function is thread safe so long as access to both the publisher and the
  ///  * `ros_message` is synchronized.
  ///  * That means that calling rcl_publish() from multiple threads is allowed, but
  ///  * calling rcl_publish() at the same time as non-thread safe publisher
  ///  * functions is not, e.g. calling rcl_publish() and rcl_publisher_fini()
  ///  * concurrently is not allowed.
  ///  * Before calling rcl_publish() the message can change and after calling
  ///  * rcl_publish() the message can change, but it cannot be changed during the
  ///  * publish call.
  ///  * The same `ros_message`, however, can be passed to multiple calls of
  ///  * rcl_publish() simultaneously, even if the publishers differ.
  ///  * The `ros_message` is unmodified by rcl_publish().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] for unique pairs of publishers and messages, see above for more</i>
  ///  *
  ///  * \param[in] publisher handle to the publisher which will do the publishing
  ///  * \param[in] ros_message type-erased pointer to the ROS message
  ///  * \param[in] allocation structure pointer, used for memory preallocation (may be NULL)
  ///  * \return #RCL_RET_OK if the message was published successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_publish(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rcl_publish(
      publisher,
      ros_message,
      allocation,
    );
  }

  late final _rcl_publishPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_publisher_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<rmw_publisher_allocation_t>)>>('rcl_publish');
  late final _rcl_publish = _rcl_publishPtr.asFunction<
      int Function(ffi.Pointer<rcl_publisher_t>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<rmw_publisher_allocation_t>)>();

  /// Publish a serialized message on a topic using a publisher.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the serialized message
  ///  * parameter and the type associate with the publisher (via the type support)
  ///  * match.
  ///  * Even though this call to publish takes an already serialized serialized message,
  ///  * the publisher has to register its type as a ROS known message type.
  ///  * Passing a serialized message from a different type leads to undefined behavior on the subscriber side.
  ///  * The publish call might be able to send any abitrary serialized message, it is however
  ///  * not garantueed that the subscriber side successfully deserializes this byte stream.
  ///  *
  ///  * Apart from this, the `publish_serialized` function has the same behavior as rcl_publish()
  ///  * expect that no serialization step is done.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] for unique pairs of publishers and messages, see above for more</i>
  ///  *
  ///  * \param[in] publisher handle to the publisher which will do the publishing
  ///  * \param[in] serialized_message  pointer to the already serialized message in raw form
  ///  * \param[in] allocation structure pointer, used for memory preallocation (may be NULL)
  ///  * \return #RCL_RET_OK if the message was published successfully, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_publish_serialized_message(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rcl_serialized_message_t> serialized_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rcl_publish_serialized_message(
      publisher,
      serialized_message,
      allocation,
    );
  }

  late final _rcl_publish_serialized_messagePtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_publisher_t>,
                  ffi.Pointer<rcl_serialized_message_t>,
                  ffi.Pointer<rmw_publisher_allocation_t>)>>(
      'rcl_publish_serialized_message');
  late final _rcl_publish_serialized_message =
      _rcl_publish_serialized_messagePtr.asFunction<
          int Function(
              ffi.Pointer<rcl_publisher_t>,
              ffi.Pointer<rcl_serialized_message_t>,
              ffi.Pointer<rmw_publisher_allocation_t>)>();

  /// Publish a loaned message on a topic using a publisher.
  /// /**
  ///  * A previously borrowed loaned message can be sent via this call to rcl_publish_loaned_message().
  ///  * By calling this function, the ownership of the loaned message is getting transferred back
  ///  * to the middleware.
  ///  * The pointer to the `ros_message` is not guaranteed to be valid after as the middleware
  ///  * migth deallocate the memory for this message internally.
  ///  * It is thus recommended to call this function only in combination with
  ///  * \sa rcl_borrow_loaned_message().
  ///  *
  ///  * Apart from this, the `publish_loaned_message` function has the same behavior as rcl_publish()
  ///  * except that no serialization step is done.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No [0]
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[0] the middleware might deallocate the loaned message.
  ///  * The RCL function however does not allocate any memory.</i>
  ///  * <i>[1] for unique pairs of publishers and messages, see above for more</i>
  ///  *
  ///  * \param[in] publisher handle to the publisher which will do the publishing
  ///  * \param[in] ros_message  pointer to the previously borrow loaned message
  ///  * \param[in] allocation structure pointer, used for memory preallocation (may be NULL)
  ///  * \return #RCL_RET_OK if the message was published successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or
  ///  * \return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_publish_loaned_message(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rcl_publish_loaned_message(
      publisher,
      ros_message,
      allocation,
    );
  }

  late final _rcl_publish_loaned_messagePtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_publisher_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<rmw_publisher_allocation_t>)>>(
      'rcl_publish_loaned_message');
  late final _rcl_publish_loaned_message =
      _rcl_publish_loaned_messagePtr.asFunction<
          int Function(ffi.Pointer<rcl_publisher_t>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<rmw_publisher_allocation_t>)>();

  /// Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)
  /// /**
  ///  * If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of
  ///  * this publisher may manually call `assert_liveliness` at some point in time to signal to the rest
  ///  * of the system that this Node is still alive.
  ///  * This function must be called at least as often as the qos_profile's liveliness_lease_duration
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher handle to the publisher that needs liveliness to be asserted
  ///  * \return #RCL_RET_OK if the liveliness assertion was completed successfully, or
  ///  * \return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_publisher_assert_liveliness(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_assert_liveliness(
      publisher,
    );
  }

  late final _rcl_publisher_assert_livelinessPtr = _lookup<
          ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_publisher_t>)>>(
      'rcl_publisher_assert_liveliness');
  late final _rcl_publisher_assert_liveliness =
      _rcl_publisher_assert_livelinessPtr
          .asFunction<int Function(ffi.Pointer<rcl_publisher_t>)>();

  /// Wait until all published message data is acknowledged or until the specified timeout elapses.
  /// /**
  ///  * This function waits until all published message data were acknowledged by peer node or timeout.
  ///  *
  ///  * The timeout unit is nanoseconds.
  ///  * If the timeout is negative then this function will block indefinitely until all published message
  ///  * data were acknowledged.
  ///  * If the timeout is 0 then this function will be non-blocking; checking all published message data
  ///  * were acknowledged (If acknowledged, return RCL_RET_OK. Otherwise, return RCL_RET_TIMEOUT), but
  ///  * not waiting.
  ///  * If the timeout is greater than 0 then this function will return after that period of time has
  ///  * elapsed (return RCL_RET_TIMEOUT) or all published message data were acknowledged (return
  ///  * RCL_RET_OK).
  ///  *
  ///  * This function only waits for acknowledgments if the publisher's QOS profile is RELIABLE.
  ///  * Otherwise this function will immediately return RCL_RET_OK.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | No
  ///  *
  ///  * \param[in] publisher handle to the publisher that needs to wait for all acked.
  ///  * \param[in] timeout the duration to wait for all published message data were acknowledged, in
  ///  *   nanoseconds.
  ///  * \return #RCL_RET_OK if successful, or
  ///  * \return #RCL_RET_TIMEOUT if timed out, or
  ///  * \return #RCL_RET_PUBLISHER_INVALID if publisher is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs, or
  ///  * \return #RCL_RET_UNSUPPORTED if the middleware does not support that feature.
  ///  */
  int rcl_publisher_wait_for_all_acked(
    ffi.Pointer<rcl_publisher_t> publisher,
    int timeout,
  ) {
    return _rcl_publisher_wait_for_all_acked(
      publisher,
      timeout,
    );
  }

  late final _rcl_publisher_wait_for_all_ackedPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_publisher_t>,
              rcl_duration_value_t)>>('rcl_publisher_wait_for_all_acked');
  late final _rcl_publisher_wait_for_all_acked =
      _rcl_publisher_wait_for_all_ackedPtr
          .asFunction<int Function(ffi.Pointer<rcl_publisher_t>, int)>();

  /// Get the topic name for the publisher.
  /// /**
  ///  * This function returns the publisher's internal topic name string.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - publisher is `NULL`
  ///  *   - publisher is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned string is only valid as long as the rcl_publisher_t is valid.
  ///  * The value of the string may change if the topic name changes, and therefore
  ///  * copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the publisher
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Char> rcl_publisher_get_topic_name(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_get_topic_name(
      publisher,
    );
  }

  late final _rcl_publisher_get_topic_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<rcl_publisher_t>)>>('rcl_publisher_get_topic_name');
  late final _rcl_publisher_get_topic_name =
      _rcl_publisher_get_topic_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcl_publisher_t>)>();

  /// Return the rcl publisher options.
  /// /**
  ///  * This function returns the publisher's internal options struct.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - publisher is `NULL`
  ///  *   - publisher is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned struct is only valid as long as the rcl_publisher_t is valid.
  ///  * The values in the struct may change if the options of the publisher change,
  ///  * and therefore copying the struct is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the publisher
  ///  * \return options struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_publisher_options_t> rcl_publisher_get_options(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_get_options(
      publisher,
    );
  }

  late final _rcl_publisher_get_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rcl_publisher_options_t> Function(
              ffi.Pointer<rcl_publisher_t>)>>('rcl_publisher_get_options');
  late final _rcl_publisher_get_options =
      _rcl_publisher_get_optionsPtr.asFunction<
          ffi.Pointer<rcl_publisher_options_t> Function(
              ffi.Pointer<rcl_publisher_t>)>();

  /// Return the rmw publisher handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - publisher is `NULL`
  ///  *   - publisher is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned handle is made invalid if the publisher is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * publisher as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the publisher using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the rcl publisher
  ///  * \return rmw publisher handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_publisher_t> rcl_publisher_get_rmw_handle(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_get_rmw_handle(
      publisher,
    );
  }

  late final _rcl_publisher_get_rmw_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_publisher_t> Function(
              ffi.Pointer<rcl_publisher_t>)>>('rcl_publisher_get_rmw_handle');
  late final _rcl_publisher_get_rmw_handle =
      _rcl_publisher_get_rmw_handlePtr.asFunction<
          ffi.Pointer<rmw_publisher_t> Function(
              ffi.Pointer<rcl_publisher_t>)>();

  /// Return the context associated with this publisher.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - publisher is `NULL`
  ///  *   - publisher is invalid (never called init, called fini, etc.)
  ///  *
  ///  * The returned context is made invalid if the publisher is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * Therefore it is recommended to get the handle from the publisher using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the rcl publisher
  ///  * \return context if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_context_t> rcl_publisher_get_context(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_get_context(
      publisher,
    );
  }

  late final _rcl_publisher_get_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rcl_context_t> Function(
              ffi.Pointer<rcl_publisher_t>)>>('rcl_publisher_get_context');
  late final _rcl_publisher_get_context =
      _rcl_publisher_get_contextPtr.asFunction<
          ffi.Pointer<rcl_context_t> Function(ffi.Pointer<rcl_publisher_t>)>();

  /// Return true if the publisher is valid, otherwise false.
  /// /**
  ///  * The bool returned is `false` if `publisher` is invalid.
  ///  * The bool returned is `true` otherwise.
  ///  * In the case where `false` is to be returned, an error message is set.
  ///  * This function cannot fail.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the rcl publisher
  ///  * \return `true` if `publisher` is valid, otherwise `false`
  ///  */
  bool rcl_publisher_is_valid(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_is_valid(
      publisher,
    );
  }

  late final _rcl_publisher_is_validPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_publisher_t>)>>(
      'rcl_publisher_is_valid');
  late final _rcl_publisher_is_valid = _rcl_publisher_is_validPtr
      .asFunction<bool Function(ffi.Pointer<rcl_publisher_t>)>();

  /// Return true if the publisher is valid except the context, otherwise false.
  /// /**
  ///  * This is used in clean up functions that need to access the publisher, but do
  ///  * not need use any functions with the context.
  ///  *
  ///  * It is identical to rcl_publisher_is_valid except it ignores the state of the
  ///  * context associated with the publisher.
  ///  * \sa rcl_publisher_is_valid()
  ///  */
  bool rcl_publisher_is_valid_except_context(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_is_valid_except_context(
      publisher,
    );
  }

  late final _rcl_publisher_is_valid_except_contextPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_publisher_t>)>>(
      'rcl_publisher_is_valid_except_context');
  late final _rcl_publisher_is_valid_except_context =
      _rcl_publisher_is_valid_except_contextPtr
          .asFunction<bool Function(ffi.Pointer<rcl_publisher_t>)>();

  /// Get the number of subscriptions matched to a publisher.
  /// /**
  ///  * Used to get the internal count of subscriptions matched to a publisher.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] only if the underlying rmw doesn't make use of this feature </i>
  ///  *
  ///  * \param[in] publisher pointer to the rcl publisher
  ///  * \param[out] subscription_count number of matched subscriptions
  ///  * \return #RCL_RET_OK if the count was retrieved, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_PUBLISHER_INVALID if the publisher is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_publisher_get_subscription_count(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Size> subscription_count,
  ) {
    return _rcl_publisher_get_subscription_count(
      publisher,
      subscription_count,
    );
  }

  late final _rcl_publisher_get_subscription_countPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_publisher_t>,
              ffi.Pointer<ffi.Size>)>>('rcl_publisher_get_subscription_count');
  late final _rcl_publisher_get_subscription_count =
      _rcl_publisher_get_subscription_countPtr.asFunction<
          int Function(ffi.Pointer<rcl_publisher_t>, ffi.Pointer<ffi.Size>)>();

  /// Get the actual qos settings of the publisher.
  /// /**
  ///  * Used to get the actual qos settings of the publisher.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the publisher, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  * The returned struct is only valid as long as the rcl_publisher_t is valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the rcl publisher
  ///  * \return qos struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_qos_profile_t> rcl_publisher_get_actual_qos(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_get_actual_qos(
      publisher,
    );
  }

  late final _rcl_publisher_get_actual_qosPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_qos_profile_t> Function(
              ffi.Pointer<rcl_publisher_t>)>>('rcl_publisher_get_actual_qos');
  late final _rcl_publisher_get_actual_qos =
      _rcl_publisher_get_actual_qosPtr.asFunction<
          ffi.Pointer<rmw_qos_profile_t> Function(
              ffi.Pointer<rcl_publisher_t>)>();

  /// Check if publisher instance can loan messages.
  /// /**
  ///  * Depending on the middleware and the message type, this will return true if the middleware
  ///  * can allocate a ROS message instance.
  ///  */
  bool rcl_publisher_can_loan_messages(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_can_loan_messages(
      publisher,
    );
  }

  late final _rcl_publisher_can_loan_messagesPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_publisher_t>)>>(
      'rcl_publisher_can_loan_messages');
  late final _rcl_publisher_can_loan_messages =
      _rcl_publisher_can_loan_messagesPtr
          .asFunction<bool Function(ffi.Pointer<rcl_publisher_t>)>();

  /// Return an rmw_message_sequence_t struct with members initialized to `NULL`
  rmw_message_sequence_t rmw_get_zero_initialized_message_sequence() {
    return _rmw_get_zero_initialized_message_sequence();
  }

  late final _rmw_get_zero_initialized_message_sequencePtr =
      _lookup<ffi.NativeFunction<rmw_message_sequence_t Function()>>(
          'rmw_get_zero_initialized_message_sequence');
  late final _rmw_get_zero_initialized_message_sequence =
      _rmw_get_zero_initialized_message_sequencePtr
          .asFunction<rmw_message_sequence_t Function()>();

  /// Initialize an rmw_message_sequence_t object.
  /// /**
  ///  * \param[inout] sequence sequence object to be initialized.
  ///  * \param[in] size capacity of the sequence to be allocated.
  ///  * \param[in] allocator the allcator used to allocate memory.
  ///  */
  int rmw_message_sequence_init(
    ffi.Pointer<rmw_message_sequence_t> sequence,
    int size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rmw_message_sequence_init(
      sequence,
      size,
      allocator,
    );
  }

  late final _rmw_message_sequence_initPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_message_sequence_t>, ffi.Size,
              ffi.Pointer<rcutils_allocator_t>)>>('rmw_message_sequence_init');
  late final _rmw_message_sequence_init =
      _rmw_message_sequence_initPtr.asFunction<
          int Function(ffi.Pointer<rmw_message_sequence_t>, int,
              ffi.Pointer<rcutils_allocator_t>)>();

  /// Finalize an rmw_message_sequence_t object.
  /// /**
  ///  * The rmw_message_sequence_t struct has members which require memory to be allocated to them
  ///  * before setting values.
  ///  * This function reclaims any allocated resources within the object and zeroes out all other
  ///  * members.
  ///  *
  ///  * Note: This will not call `fini` or deallocate the underlying message structures.
  ///  *
  ///  * \param[inout] sequence sequence object to be finalized.
  ///  */
  int rmw_message_sequence_fini(
    ffi.Pointer<rmw_message_sequence_t> sequence,
  ) {
    return _rmw_message_sequence_fini(
      sequence,
    );
  }

  late final _rmw_message_sequence_finiPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_message_sequence_t>)>>(
      'rmw_message_sequence_fini');
  late final _rmw_message_sequence_fini = _rmw_message_sequence_finiPtr
      .asFunction<int Function(ffi.Pointer<rmw_message_sequence_t>)>();

  /// Return an rmw_message_info_sequence_t struct with members initialized to `NULL`
  rmw_message_info_sequence_t rmw_get_zero_initialized_message_info_sequence() {
    return _rmw_get_zero_initialized_message_info_sequence();
  }

  late final _rmw_get_zero_initialized_message_info_sequencePtr =
      _lookup<ffi.NativeFunction<rmw_message_info_sequence_t Function()>>(
          'rmw_get_zero_initialized_message_info_sequence');
  late final _rmw_get_zero_initialized_message_info_sequence =
      _rmw_get_zero_initialized_message_info_sequencePtr
          .asFunction<rmw_message_info_sequence_t Function()>();

  /// Initialize an rmw_message_info_sequence_t object.
  /// /**
  ///  * \param[inout] sequence sequence object to be initialized.
  ///  * \param[in] size capacity of the sequence to be allocated.
  ///  * \param[in] allocator the allcator used to allocate memory.
  ///  */
  int rmw_message_info_sequence_init(
    ffi.Pointer<rmw_message_info_sequence_t> sequence,
    int size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rmw_message_info_sequence_init(
      sequence,
      size,
      allocator,
    );
  }

  late final _rmw_message_info_sequence_initPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_message_info_sequence_t>,
                  ffi.Size, ffi.Pointer<rcutils_allocator_t>)>>(
      'rmw_message_info_sequence_init');
  late final _rmw_message_info_sequence_init =
      _rmw_message_info_sequence_initPtr.asFunction<
          int Function(ffi.Pointer<rmw_message_info_sequence_t>, int,
              ffi.Pointer<rcutils_allocator_t>)>();

  /// Finalize an rmw_message_sequence_t object.
  /// /**
  ///  * The rmw_message_sequence_t struct has members which require memory to be allocated to them
  ///  * before setting values.
  ///  * This function reclaims any allocated resources within the object and zeroes out all other
  ///  * members.
  ///  *
  ///  * \param[inout] sequence sequence object to be finalized.
  ///  */
  int rmw_message_info_sequence_fini(
    ffi.Pointer<rmw_message_info_sequence_t> sequence,
  ) {
    return _rmw_message_info_sequence_fini(
      sequence,
    );
  }

  late final _rmw_message_info_sequence_finiPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_message_info_sequence_t>)>>(
      'rmw_message_info_sequence_fini');
  late final _rmw_message_info_sequence_fini =
      _rmw_message_info_sequence_finiPtr
          .asFunction<int Function(ffi.Pointer<rmw_message_info_sequence_t>)>();

  /// Return a rcl_subscription_t struct with members set to `NULL`.
  /// /**
  ///  * Should be called to get a null rcl_subscription_t before passing to
  ///  * rcl_subscription_init().
  ///  */
  rcl_subscription_t rcl_get_zero_initialized_subscription() {
    return _rcl_get_zero_initialized_subscription();
  }

  late final _rcl_get_zero_initialized_subscriptionPtr =
      _lookup<ffi.NativeFunction<rcl_subscription_t Function()>>(
          'rcl_get_zero_initialized_subscription');
  late final _rcl_get_zero_initialized_subscription =
      _rcl_get_zero_initialized_subscriptionPtr
          .asFunction<rcl_subscription_t Function()>();

  /// Initialize a ROS subscription.
  /// /**
  ///  * After calling this function on a rcl_subscription_t, it can be used to take
  ///  * messages of the given type to the given topic using rcl_take().
  ///  *
  ///  * The given rcl_node_t must be valid and the resulting rcl_subscription_t is
  ///  * only valid as long as the given rcl_node_t remains valid.
  ///  *
  ///  * The rosidl_message_type_support_t is obtained on a per .msg type basis.
  ///  * When the user defines a ROS message, code is generated which provides the
  ///  * required rosidl_message_type_support_t object.
  ///  * This object can be obtained using a language appropriate mechanism.
  ///  * \todo TODO(wjwwood) write these instructions once and link to it instead
  ///  * For C a macro can be used (for example `std_msgs/String`):
  ///  *
  ///  * ```c
  ///  * #include <rosidl_runtime_c/message_type_support_struct.h>
  ///  * #include <std_msgs/msg/string.h>
  ///  * const rosidl_message_type_support_t * string_ts =
  ///  *   ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  ///  * ```
  ///  *
  ///  * For C++ a template function is used:
  ///  *
  ///  * ```cpp
  ///  * #include <rosidl_typesupport_cpp/message_type_support.hpp>
  ///  * #include <std_msgs/msgs/string.hpp>
  ///  * using rosidl_typesupport_cpp::get_message_type_support_handle;
  ///  * const rosidl_message_type_support_t * string_ts =
  ///  *   get_message_type_support_handle<std_msgs::msg::String>();
  ///  * ```
  ///  *
  ///  * The rosidl_message_type_support_t object contains message type specific
  ///  * information used to publish messages.
  ///  *
  ///  * The topic name must be a c string which follows the topic and service name
  ///  * format rules for unexpanded names, also known as non-fully qualified names:
  ///  *
  ///  * \see rcl_expand_topic_name
  ///  *
  ///  * The options struct allows the user to set the quality of service settings as
  ///  * well as a custom allocator which is used when (de)initializing the
  ///  * subscription to allocate space for incidental things, e.g. the topic
  ///  * name string.
  ///  *
  ///  * Expected usage (for C messages):
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  * #include <rosidl_runtime_c/message_type_support_struct.h>
  ///  * #include <std_msgs/msg/string.h>
  ///  *
  ///  * rcl_node_t node = rcl_get_zero_initialized_node();
  ///  * rcl_node_options_t node_ops = rcl_node_get_default_options();
  ///  * rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  ///  * // ... error handling
  ///  * const rosidl_message_type_support_t * ts =
  ///  *   ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  ///  * rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();
  ///  * rcl_subscription_options_t subscription_ops = rcl_subscription_get_default_options();
  ///  * ret = rcl_subscription_init(&subscription, &node, ts, "chatter", &subscription_ops);
  ///  * // ... error handling, and when finished deinitialization
  ///  * ret = rcl_subscription_fini(&subscription, &node);
  ///  * // ... error handling for rcl_subscription_fini()
  ///  * ret = rcl_node_fini(&node);
  ///  * // ... error handling for rcl_node_fini()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[out] subscription preallocated subscription structure
  ///  * \param[in] node valid rcl node handle
  ///  * \param[in] type_support type support object for the topic's type
  ///  * \param[in] topic_name the name of the topic
  ///  * \param[in] options subscription options, including quality of service settings
  ///  * \return #RCL_RET_OK if subscription was initialized successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ALREADY_INIT if the subcription is already initialized, or
  ///  * \return #RCL_RET_NODE_INVALID if the node is invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_TOPIC_NAME_INVALID if the given topic name is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_subscription_init(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Char> topic_name,
    ffi.Pointer<rcl_subscription_options_t> options,
  ) {
    return _rcl_subscription_init(
      subscription,
      node,
      type_support,
      topic_name,
      options,
    );
  }

  late final _rcl_subscription_initPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_subscription_t>,
                  ffi.Pointer<rcl_node_t>,
                  ffi.Pointer<rosidl_message_type_support_t>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<rcl_subscription_options_t>)>>(
      'rcl_subscription_init');
  late final _rcl_subscription_init = _rcl_subscription_initPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_subscription_t>,
          ffi.Pointer<rcl_node_t>,
          ffi.Pointer<rosidl_message_type_support_t>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<rcl_subscription_options_t>)>();

  /// Finalize a rcl_subscription_t.
  /// /**
  ///  * After calling, the node will no longer be subscribed on this topic
  ///  * (assuming this is the only subscription on this topic in this node).
  ///  *
  ///  * After calling, calls to rcl_wait and rcl_take will fail when using this
  ///  * subscription.
  ///  * Additioanlly rcl_wait will be interrupted if currently blocking.
  ///  * However, the given node handle is still valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] subscription handle to the subscription to be deinitialized
  ///  * \param[in] node a valid (not finalized) handle to the node used to create the subscription
  ///  * \return #RCL_RET_OK if subscription was deinitialized successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or
  ///  * \return #RCL_RET_NODE_INVALID if the node is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_subscription_fini(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_subscription_fini(
      subscription,
      node,
    );
  }

  late final _rcl_subscription_finiPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_subscription_t>,
              ffi.Pointer<rcl_node_t>)>>('rcl_subscription_fini');
  late final _rcl_subscription_fini = _rcl_subscription_finiPtr.asFunction<
      int Function(ffi.Pointer<rcl_subscription_t>, ffi.Pointer<rcl_node_t>)>();

  /// Return the default subscription options in a rcl_subscription_options_t.
  /// /**
  ///  * The defaults are:
  ///  *
  ///  * - qos = rmw_qos_profile_default
  ///  * - allocator = rcl_get_default_allocator()
  ///  * - rmw_subscription_options = rmw_get_default_subscription_options();
  ///  *
  ///  * \return A structure containing the default options for a subscription.
  ///  */
  rcl_subscription_options_t rcl_subscription_get_default_options() {
    return _rcl_subscription_get_default_options();
  }

  late final _rcl_subscription_get_default_optionsPtr =
      _lookup<ffi.NativeFunction<rcl_subscription_options_t Function()>>(
          'rcl_subscription_get_default_options');
  late final _rcl_subscription_get_default_options =
      _rcl_subscription_get_default_optionsPtr
          .asFunction<rcl_subscription_options_t Function()>();

  /// Reclaim resources held inside rcl_subscription_options_t structure.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | No
  ///  *
  ///  * \param[in] option The structure which its resources have to be deallocated.
  ///  * \return `RCL_RET_OK` if the memory was successfully freed, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if option is NULL, or
  ///  * \return `RCL_RET_BAD_ALLOC` if deallocating memory fails.
  ///  */
  int rcl_subscription_options_fini(
    ffi.Pointer<rcl_subscription_options_t> option,
  ) {
    return _rcl_subscription_options_fini(
      option,
    );
  }

  late final _rcl_subscription_options_finiPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_subscription_options_t>)>>(
      'rcl_subscription_options_fini');
  late final _rcl_subscription_options_fini = _rcl_subscription_options_finiPtr
      .asFunction<int Function(ffi.Pointer<rcl_subscription_options_t>)>();

  /// Set the content filter options for the given subscription options.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | No
  ///  *
  ///  * \param[in] filter_expression The filter expression is similar to the WHERE part of an SQL clause.
  ///  * \param[in] expression_parameters_argc The maximum of expression parameters argc is 100.
  ///  * \param[in] expression_parameter_argv The expression parameters argv are the tokens placeholder
  ///  * ‘parameters’ (i.e., "%n" tokens begin from 0) in the filter_expression.
  ///  *
  ///  * It can be NULL if there is no "%n" tokens placeholder in filter_expression.
  ///  * \param[out] options The subscription options to be set.
  ///  * \return `RCL_RET_OK` if set options successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if arguments invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory fails.
  ///  */
  int rcl_subscription_options_set_content_filter_options(
    ffi.Pointer<ffi.Char> filter_expression,
    int expression_parameters_argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> expression_parameter_argv,
    ffi.Pointer<rcl_subscription_options_t> options,
  ) {
    return _rcl_subscription_options_set_content_filter_options(
      filter_expression,
      expression_parameters_argc,
      expression_parameter_argv,
      options,
    );
  }

  late final _rcl_subscription_options_set_content_filter_optionsPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.Pointer<rcl_subscription_options_t>)>>(
      'rcl_subscription_options_set_content_filter_options');
  late final _rcl_subscription_options_set_content_filter_options =
      _rcl_subscription_options_set_content_filter_optionsPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<rcl_subscription_options_t>)>();

  /// Return the zero initialized subscription content filter options.
  rcl_subscription_content_filter_options_t
      rcl_get_zero_initialized_subscription_content_filter_options() {
    return _rcl_get_zero_initialized_subscription_content_filter_options();
  }

  late final _rcl_get_zero_initialized_subscription_content_filter_optionsPtr =
      _lookup<
              ffi.NativeFunction<
                  rcl_subscription_content_filter_options_t Function()>>(
          'rcl_get_zero_initialized_subscription_content_filter_options');
  late final _rcl_get_zero_initialized_subscription_content_filter_options =
      _rcl_get_zero_initialized_subscription_content_filter_optionsPtr
          .asFunction<rcl_subscription_content_filter_options_t Function()>();

  /// Initialize the content filter options for the given subscription options.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | No
  ///  *
  ///  * \param[in] subscription the handle to the subscription.
  ///  * \param[in] filter_expression The filter expression is similar to the WHERE part of an SQL clause,
  ///  * use empty ("") can reset (or clear) the content filter setting of a subscription.
  ///  * \param[in] expression_parameters_argc The maximum of expression parameters argc is 100.
  ///  * \param[in] expression_parameter_argv The expression parameters argv are the tokens placeholder
  ///  * ‘parameters’ (i.e., "%n" tokens begin from 0) in the filter_expression.
  ///  *
  ///  * It can be NULL if there is no "%n" tokens placeholder in filter_expression.
  ///  * \param[out] options The subscription options to be set.
  ///  * \return `RCL_RET_OK` if set options successfully, or
  ///  * \return `RCL_RET_SUBSCRIPTION_INVALID` if subscription is invalid, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if arguments invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory fails.
  ///  */
  int rcl_subscription_content_filter_options_init(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Char> filter_expression,
    int expression_parameters_argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> expression_parameter_argv,
    ffi.Pointer<rcl_subscription_content_filter_options_t> options,
  ) {
    return _rcl_subscription_content_filter_options_init(
      subscription,
      filter_expression,
      expression_parameters_argc,
      expression_parameter_argv,
      options,
    );
  }

  late final _rcl_subscription_content_filter_options_initPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_subscription_t>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.Pointer<rcl_subscription_content_filter_options_t>)>>(
      'rcl_subscription_content_filter_options_init');
  late final _rcl_subscription_content_filter_options_init =
      _rcl_subscription_content_filter_options_initPtr.asFunction<
          int Function(
              ffi.Pointer<rcl_subscription_t>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<rcl_subscription_content_filter_options_t>)>();

  /// Set the content filter options for the given subscription options.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | No
  ///  *
  ///  * \param[in] subscription the handle to the subscription.
  ///  * \param[in] filter_expression The filter expression is similar to the WHERE part of an SQL clause,
  ///  * use empty ("") can reset (or clear) the content filter setting of a subscription.
  ///  * \param[in] expression_parameters_argc The maximum of expression parameters argc is 100.
  ///  * \param[in] expression_parameter_argv The expression parameters argv are the tokens placeholder
  ///  * ‘parameters’ (i.e., "%n" tokens begin from 0) in the filter_expression.
  ///  *
  ///  * It can be NULL if there is no "%n" tokens placeholder in filter_expression.
  ///  * \param[out] options The subscription options to be set.
  ///  * \return `RCL_RET_OK` if set options successfully, or
  ///  * \return `RCL_RET_SUBSCRIPTION_INVALID` if subscription is invalid, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if arguments invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory fails.
  ///  */
  int rcl_subscription_content_filter_options_set(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Char> filter_expression,
    int expression_parameters_argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> expression_parameter_argv,
    ffi.Pointer<rcl_subscription_content_filter_options_t> options,
  ) {
    return _rcl_subscription_content_filter_options_set(
      subscription,
      filter_expression,
      expression_parameters_argc,
      expression_parameter_argv,
      options,
    );
  }

  late final _rcl_subscription_content_filter_options_setPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_subscription_t>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>,
                  ffi.Pointer<rcl_subscription_content_filter_options_t>)>>(
      'rcl_subscription_content_filter_options_set');
  late final _rcl_subscription_content_filter_options_set =
      _rcl_subscription_content_filter_options_setPtr.asFunction<
          int Function(
              ffi.Pointer<rcl_subscription_t>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<rcl_subscription_content_filter_options_t>)>();

  /// Reclaim rcl_subscription_content_filter_options_t structure.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | No
  ///  *
  ///  * \param[in] subscription the handle to the subscription.
  ///  * \param[in] options The structure which its resources have to be deallocated.
  ///  * \return `RCL_RET_OK` if the memory was successfully freed, or
  ///  * \return `RCL_RET_SUBSCRIPTION_INVALID` if subscription is invalid, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if option is NULL, or
  ///  *  if its allocator is invalid and the structure contains initialized memory.
  ///  */
  int rcl_subscription_content_filter_options_fini(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcl_subscription_content_filter_options_t> options,
  ) {
    return _rcl_subscription_content_filter_options_fini(
      subscription,
      options,
    );
  }

  late final _rcl_subscription_content_filter_options_finiPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_subscription_t>,
                  ffi.Pointer<rcl_subscription_content_filter_options_t>)>>(
      'rcl_subscription_content_filter_options_fini');
  late final _rcl_subscription_content_filter_options_fini =
      _rcl_subscription_content_filter_options_finiPtr.asFunction<
          int Function(ffi.Pointer<rcl_subscription_t>,
              ffi.Pointer<rcl_subscription_content_filter_options_t>)>();

  /// Check if the content filtered topic feature is enabled in the subscription.
  /// /**
  ///  * Depending on the middleware and whether cft is enabled in the subscription.
  ///  *
  ///  * \return `true` if the content filtered topic of `subscription` is enabled, otherwise `false`
  ///  */
  bool rcl_subscription_is_cft_enabled(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_is_cft_enabled(
      subscription,
    );
  }

  late final _rcl_subscription_is_cft_enabledPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_subscription_t>)>>(
      'rcl_subscription_is_cft_enabled');
  late final _rcl_subscription_is_cft_enabled =
      _rcl_subscription_is_cft_enabledPtr
          .asFunction<bool Function(ffi.Pointer<rcl_subscription_t>)>();

  /// Set the filter expression and expression parameters for the subscription.
  /// /**
  ///  * This function will set a filter expression and an array of expression parameters
  ///  * for the given subscription.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * \param[in] subscription The subscription to set content filter options.
  ///  * \param[in] options The rcl content filter options.
  ///  * \return `RCL_RET_OK` if the query was successful, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if `options` is NULL, or
  ///  * \return `RCL_RET_UNSUPPORTED` if the implementation does not support content filter topic, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_subscription_set_content_filter(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcl_subscription_content_filter_options_t> options,
  ) {
    return _rcl_subscription_set_content_filter(
      subscription,
      options,
    );
  }

  late final _rcl_subscription_set_content_filterPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_subscription_t>,
                  ffi.Pointer<rcl_subscription_content_filter_options_t>)>>(
      'rcl_subscription_set_content_filter');
  late final _rcl_subscription_set_content_filter =
      _rcl_subscription_set_content_filterPtr.asFunction<
          int Function(ffi.Pointer<rcl_subscription_t>,
              ffi.Pointer<rcl_subscription_content_filter_options_t>)>();

  /// Retrieve the filter expression of the subscription.
  /// /**
  ///  * This function will return an filter expression by the given subscription.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * \param[in] subscription The subscription object to inspect.
  ///  * \param[out] options The rcl content filter options.
  ///  *   It is up to the caller to finalize this options later on, using
  ///  *   rcl_subscription_content_filter_options_fini().
  ///  * \return `RCL_RET_OK` if the query was successful, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if `options` is NULL, or
  ///  * \return `RCL_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RCL_RET_UNSUPPORTED` if the implementation does not support content filter topic, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_subscription_get_content_filter(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcl_subscription_content_filter_options_t> options,
  ) {
    return _rcl_subscription_get_content_filter(
      subscription,
      options,
    );
  }

  late final _rcl_subscription_get_content_filterPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_subscription_t>,
                  ffi.Pointer<rcl_subscription_content_filter_options_t>)>>(
      'rcl_subscription_get_content_filter');
  late final _rcl_subscription_get_content_filter =
      _rcl_subscription_get_content_filterPtr.asFunction<
          int Function(ffi.Pointer<rcl_subscription_t>,
              ffi.Pointer<rcl_subscription_content_filter_options_t>)>();

  /// Take a ROS message from a topic using a rcl subscription.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the ros_message
  ///  * argument and the type associated with the subscription, via the type
  ///  * support, match.
  ///  * Passing a different type to rcl_take produces undefined behavior and cannot
  ///  * be checked by this function and therefore no deliberate error will occur.
  ///  *
  ///  * TODO(wjwwood) blocking of take?
  ///  * TODO(wjwwood) pre-, during-, and post-conditions for message ownership?
  ///  * TODO(wjwwood) is rcl_take thread-safe?
  ///  * TODO(wjwwood) Should there be an rcl_message_info_t?
  ///  *
  ///  * The ros_message pointer should point to an already allocated ROS message
  ///  * struct of the correct type, into which the taken ROS message will be copied
  ///  * if one is available.
  ///  * If taken is false after calling, then the ROS message will be unmodified.
  ///  *
  ///  * The taken boolean may be false even if a wait set reports that the
  ///  * subscription was ready to be taken from in some cases, e.g. when the
  ///  * state of the subscription changes it may cause the wait set to wake up
  ///  * but subsequent takes to fail to take anything.
  ///  *
  ///  * If allocation is required when taking the message, e.g. if space needs to
  ///  * be allocated for a dynamically sized array in the target message, then the
  ///  * allocator given in the subscription options is used.
  ///  *
  ///  * The rmw_message_info struct contains meta information about this particular
  ///  * message instance, like what the GUID of the publisher which published it
  ///  * originally or whether or not the message received from within the same
  ///  * process.
  ///  * The message_info argument should be an already allocated rmw_message_info_t
  ///  * structure.
  ///  * Passing `NULL` for message_info will result in the argument being ignored.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] only if required when filling the message, avoided for fixed sizes</i>
  ///  *
  ///  * \param[in] subscription the handle to the subscription from which to take
  ///  * \param[inout] ros_message type-erased ptr to a allocated ROS message
  ///  * \param[out] message_info rmw struct which contains meta-data for the message
  ///  * \param[in] allocation structure pointer used for memory preallocation (may be NULL)
  ///  * \return #RCL_RET_OK if the message was taken, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error
  ///  *         occurred in the middleware, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_take(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rcl_take(
      subscription,
      ros_message,
      message_info,
      allocation,
    );
  }

  late final _rcl_takePtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_subscription_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<rmw_message_info_t>,
              ffi.Pointer<rmw_subscription_allocation_t>)>>('rcl_take');
  late final _rcl_take = _rcl_takePtr.asFunction<
      int Function(
          ffi.Pointer<rcl_subscription_t>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<rmw_message_info_t>,
          ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Take a sequence of messages from a topic using a rcl subscription.
  /// /**
  ///  * In contrast to rcl_take(), this function can take multiple messages at
  ///  * the same time.
  ///  * It is the job of the caller to ensure that the type of the message_sequence
  ///  * argument and the type associated with the subscription, via the type
  ///  * support, match.
  ///  *
  ///  * The message_sequence pointer should point to an already allocated sequence
  ///  * of ROS messages of the correct type, into which the taken ROS messages will
  ///  * be copied if messages are available.
  ///  * The message_sequence `size` member will be set to the number of messages
  ///  * correctly taken.
  ///  *
  ///  * The rmw_message_info_sequence struct contains meta information about the
  ///  * corresponding message instance index.
  ///  * The message_info_sequence argument should be an already allocated
  ///  * rmw_message_info_sequence_t structure.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] only if storage in the serialized_message is insufficient</i>
  ///  *
  ///  * \param[in] subscription the handle to the subscription from which to take.
  ///  * \param[in] count number of messages to attempt to take.
  ///  * \param[inout] message_sequence pointer to a (pre-allocated) message sequence.
  ///  * \param[inout] message_info_sequence pointer to a (pre-allocated) message info sequence.
  ///  * \param[in] allocation structure pointer used for memory preallocation (may be NULL)
  ///  * \return #RCL_RET_OK if one or more messages was taken, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error
  ///  *         occurred in the middleware, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_take_sequence(
    ffi.Pointer<rcl_subscription_t> subscription,
    int count,
    ffi.Pointer<rmw_message_sequence_t> message_sequence,
    ffi.Pointer<rmw_message_info_sequence_t> message_info_sequence,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rcl_take_sequence(
      subscription,
      count,
      message_sequence,
      message_info_sequence,
      allocation,
    );
  }

  late final _rcl_take_sequencePtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_subscription_t>,
                  ffi.Size,
                  ffi.Pointer<rmw_message_sequence_t>,
                  ffi.Pointer<rmw_message_info_sequence_t>,
                  ffi.Pointer<rmw_subscription_allocation_t>)>>(
      'rcl_take_sequence');
  late final _rcl_take_sequence = _rcl_take_sequencePtr.asFunction<
      int Function(
          ffi.Pointer<rcl_subscription_t>,
          int,
          ffi.Pointer<rmw_message_sequence_t>,
          ffi.Pointer<rmw_message_info_sequence_t>,
          ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Take a serialized raw message from a topic using a rcl subscription.
  /// /**
  ///  * In contrast to rcl_take(), this function stores the taken message in
  ///  * its raw binary representation.
  ///  * It is the job of the caller to ensure that the type associate with the subscription
  ///  * matches, and can optionally be deserialized into its ROS message via, the correct
  ///  * type support.
  ///  * If the `serialized_message` parameter contains enough preallocated memory, the incoming
  ///  * message can be taken without any additional memory allocation.
  ///  * If not, the function will dynamically allocate enough memory for the message.
  ///  * Passing a different type to rcl_take produces undefined behavior and cannot
  ///  * be checked by this function and therefore no deliberate error will occur.
  ///  *
  ///  * Apart from the differences above, this function behaves like rcl_take().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] only if storage in the serialized_message is insufficient</i>
  ///  *
  ///  * \param[in] subscription the handle to the subscription from which to take
  ///  * \param[inout] serialized_message pointer to a (pre-allocated) serialized message.
  ///  * \param[out] message_info rmw struct which contains meta-data for the message
  ///  * \param[in] allocation structure pointer used for memory preallocation (may be NULL)
  ///  * \return #RCL_RET_OK if the message was published, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error
  ///  *         occurred in the middleware, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_take_serialized_message(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcl_serialized_message_t> serialized_message,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rcl_take_serialized_message(
      subscription,
      serialized_message,
      message_info,
      allocation,
    );
  }

  late final _rcl_take_serialized_messagePtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_subscription_t>,
                  ffi.Pointer<rcl_serialized_message_t>,
                  ffi.Pointer<rmw_message_info_t>,
                  ffi.Pointer<rmw_subscription_allocation_t>)>>(
      'rcl_take_serialized_message');
  late final _rcl_take_serialized_message =
      _rcl_take_serialized_messagePtr.asFunction<
          int Function(
              ffi.Pointer<rcl_subscription_t>,
              ffi.Pointer<rcl_serialized_message_t>,
              ffi.Pointer<rmw_message_info_t>,
              ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Take a loaned message from a topic using a rcl subscription.
  /// /**
  ///  * Depending on the middleware, incoming messages can be loaned to the user's callback
  ///  * without further copying.
  ///  * The implicit contract here is that the middleware owns the memory allocated for this message.
  ///  * The user must not destroy the message, but rather has to return it with a call to
  ///  * \sa rcl_return_loaned_message to the middleware.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription the handle to the subscription from which to take
  ///  * \param[inout] loaned_message a pointer to the loaned messages.
  ///  * \param[out] message_info rmw struct which contains meta-data for the message.
  ///  * \param[in] allocation structure pointer used for memory preallocation (may be NULL)
  ///  * \return #RCL_RET_OK if the loaned message sequence was taken, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_SUBSCRIPTION_TAKE_FAILED if take failed but no error
  ///  *         occurred in the middleware, or
  ///  * \return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_take_loaned_message(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rcl_take_loaned_message(
      subscription,
      loaned_message,
      message_info,
      allocation,
    );
  }

  late final _rcl_take_loaned_messagePtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_subscription_t>,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>,
                  ffi.Pointer<rmw_message_info_t>,
                  ffi.Pointer<rmw_subscription_allocation_t>)>>(
      'rcl_take_loaned_message');
  late final _rcl_take_loaned_message = _rcl_take_loaned_messagePtr.asFunction<
      int Function(
          ffi.Pointer<rcl_subscription_t>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>,
          ffi.Pointer<rmw_message_info_t>,
          ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Return a loaned message from a topic using a rcl subscription.
  /// /**
  ///  * If a loaned message was previously obtained from the middleware with a call to
  ///  * \sa rcl_take_loaned_message, this message has to be returned to indicate to the middleware
  ///  * that the user no longer needs that memory.
  ///  * The user must not delete the message.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription the handle to the subscription from which to take
  ///  * \param[in] loaned_message a pointer to the loaned messages.
  ///  * \return #RCL_RET_OK if the message was published, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or
  ///  * \return #RCL_RET_UNSUPPORTED if the middleware does not support that feature, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_return_loaned_message_from_subscription(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return _rcl_return_loaned_message_from_subscription(
      subscription,
      loaned_message,
    );
  }

  late final _rcl_return_loaned_message_from_subscriptionPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(
                  ffi.Pointer<rcl_subscription_t>, ffi.Pointer<ffi.Void>)>>(
      'rcl_return_loaned_message_from_subscription');
  late final _rcl_return_loaned_message_from_subscription =
      _rcl_return_loaned_message_from_subscriptionPtr.asFunction<
          int Function(
              ffi.Pointer<rcl_subscription_t>, ffi.Pointer<ffi.Void>)>();

  /// Get the topic name for the subscription.
  /// /**
  ///  * This function returns the subscription's internal topic name string.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - subscription is `NULL`
  ///  *   - subscription is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned string is only valid as long as the subscription is valid.
  ///  * The value of the string may change if the topic name changes, and therefore
  ///  * copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription the pointer to the subscription
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Char> rcl_subscription_get_topic_name(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_get_topic_name(
      subscription,
    );
  }

  late final _rcl_subscription_get_topic_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcl_subscription_t>)>>(
      'rcl_subscription_get_topic_name');
  late final _rcl_subscription_get_topic_name =
      _rcl_subscription_get_topic_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcl_subscription_t>)>();

  /// Return the rcl subscription options.
  /// /**
  ///  * This function returns the subscription's internal options struct.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - subscription is `NULL`
  ///  *   - subscription is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned struct is only valid as long as the subscription is valid.
  ///  * The values in the struct may change if the subscription's options change,
  ///  * and therefore copying the struct is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription pointer to the subscription
  ///  * \return options struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_subscription_options_t> rcl_subscription_get_options(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_get_options(
      subscription,
    );
  }

  late final _rcl_subscription_get_optionsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rcl_subscription_options_t> Function(
                  ffi.Pointer<rcl_subscription_t>)>>(
      'rcl_subscription_get_options');
  late final _rcl_subscription_get_options =
      _rcl_subscription_get_optionsPtr.asFunction<
          ffi.Pointer<rcl_subscription_options_t> Function(
              ffi.Pointer<rcl_subscription_t>)>();

  /// Return the rmw subscription handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - subscription is `NULL`
  ///  *   - subscription is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned handle is made invalid if the subscription is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * subscription as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the subscription using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription pointer to the rcl subscription
  ///  * \return rmw subscription handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_subscription_t> rcl_subscription_get_rmw_handle(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_get_rmw_handle(
      subscription,
    );
  }

  late final _rcl_subscription_get_rmw_handlePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rmw_subscription_t> Function(
                  ffi.Pointer<rcl_subscription_t>)>>(
      'rcl_subscription_get_rmw_handle');
  late final _rcl_subscription_get_rmw_handle =
      _rcl_subscription_get_rmw_handlePtr.asFunction<
          ffi.Pointer<rmw_subscription_t> Function(
              ffi.Pointer<rcl_subscription_t>)>();

  /// Check that the subscription is valid.
  /// /**
  ///  * The bool returned is `false` if `subscription` is invalid.
  ///  * The bool returned is `true` otherwise.
  ///  * In the case where `false` is to be returned, an error message is set.
  ///  * This function cannot fail.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription pointer to the rcl subscription
  ///  * \return `true` if `subscription` is valid, otherwise `false`
  ///  */
  bool rcl_subscription_is_valid(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_is_valid(
      subscription,
    );
  }

  late final _rcl_subscription_is_validPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_subscription_t>)>>(
      'rcl_subscription_is_valid');
  late final _rcl_subscription_is_valid = _rcl_subscription_is_validPtr
      .asFunction<bool Function(ffi.Pointer<rcl_subscription_t>)>();

  /// Get the number of publishers matched to a subscription.
  /// /**
  ///  * Used to get the internal count of publishers matched to a subscription.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] only if the underlying rmw doesn't make use of this feature </i>
  ///  *
  ///  * \param[in] subscription pointer to the rcl subscription
  ///  * \param[out] publisher_count number of matched publishers
  ///  * \return #RCL_RET_OK if the count was retrieved, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_SUBSCRIPTION_INVALID if the subscription is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_subscription_get_publisher_count(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Size> publisher_count,
  ) {
    return _rcl_subscription_get_publisher_count(
      subscription,
      publisher_count,
    );
  }

  late final _rcl_subscription_get_publisher_countPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rcl_subscription_t>,
              ffi.Pointer<ffi.Size>)>>('rcl_subscription_get_publisher_count');
  late final _rcl_subscription_get_publisher_count =
      _rcl_subscription_get_publisher_countPtr.asFunction<
          int Function(
              ffi.Pointer<rcl_subscription_t>, ffi.Pointer<ffi.Size>)>();

  /// Get the actual qos settings of the subscription.
  /// /**
  ///  * Used to get the actual qos settings of the subscription.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the subscription, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  * The returned struct is only valid as long as the rcl_subscription_t is valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription pointer to the rcl subscription
  ///  * \return qos struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_qos_profile_t> rcl_subscription_get_actual_qos(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_get_actual_qos(
      subscription,
    );
  }

  late final _rcl_subscription_get_actual_qosPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rmw_qos_profile_t> Function(
                  ffi.Pointer<rcl_subscription_t>)>>(
      'rcl_subscription_get_actual_qos');
  late final _rcl_subscription_get_actual_qos =
      _rcl_subscription_get_actual_qosPtr.asFunction<
          ffi.Pointer<rmw_qos_profile_t> Function(
              ffi.Pointer<rcl_subscription_t>)>();

  /// Check if subscription instance can loan messages.
  /// /**
  ///  * Depending on the middleware and the message type, this will return true if the middleware
  ///  * can allocate a ROS message instance.
  ///  *
  ///  * \param[in] subscription The subscription instance to check for the ability to loan messages
  ///  * \return `true` if the subscription instance can loan messages, `false` otherwise.
  ///  */
  bool rcl_subscription_can_loan_messages(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_can_loan_messages(
      subscription,
    );
  }

  late final _rcl_subscription_can_loan_messagesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_subscription_t>)>>(
      'rcl_subscription_can_loan_messages');
  late final _rcl_subscription_can_loan_messages =
      _rcl_subscription_can_loan_messagesPtr
          .asFunction<bool Function(ffi.Pointer<rcl_subscription_t>)>();

  /// Set the on new message callback function for the subscription.
  /// /**
  ///  * This API sets the callback function to be called whenever the
  ///  * subscription is notified about a new message.
  ///  *
  ///  * \sa rmw_subscription_set_on_new_message_callback for details about this
  ///  * function.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined</i>
  ///  *
  ///  * \param[in] subscription The subscription on which to set the callback
  ///  * \param[in] callback The callback to be called when new messages arrive, may be NULL
  ///  * \param[in] user_data Given to the callback when called later, may be NULL
  ///  * \return `RCL_RET_OK` if successful, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RCL_RET_UNSUPPORTED` if the API is not implemented in the dds implementation
  ///  */
  int rcl_subscription_set_on_new_message_callback(
    ffi.Pointer<rcl_subscription_t> subscription,
    rcl_event_callback_t callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rcl_subscription_set_on_new_message_callback(
      subscription,
      callback,
      user_data,
    );
  }

  late final _rcl_subscription_set_on_new_message_callbackPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_subscription_t>,
                  rcl_event_callback_t, ffi.Pointer<ffi.Void>)>>(
      'rcl_subscription_set_on_new_message_callback');
  late final _rcl_subscription_set_on_new_message_callback =
      _rcl_subscription_set_on_new_message_callbackPtr.asFunction<
          int Function(ffi.Pointer<rcl_subscription_t>, rcl_event_callback_t,
              ffi.Pointer<ffi.Void>)>();

  /// Get the service type support handle specific to this identifier.
  /// /**
  ///  * The handle's message typesupport identifier function is returned or if the parameters are NULL
  ///  * then an assert will happen.
  ///  *
  ///  * \param handle Handle to service type support
  ///  * \param identifier The typesupport identifier to get the handle function for
  ///  * \return The associated service typesupport handle function.
  ///  */
  ffi.Pointer<rosidl_service_type_support_t> get_service_typesupport_handle(
    ffi.Pointer<rosidl_service_type_support_t> handle,
    ffi.Pointer<ffi.Char> identifier,
  ) {
    return _get_service_typesupport_handle(
      handle,
      identifier,
    );
  }

  late final _get_service_typesupport_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rosidl_service_type_support_t> Function(
              ffi.Pointer<rosidl_service_type_support_t>,
              ffi.Pointer<ffi.Char>)>>('get_service_typesupport_handle');
  late final _get_service_typesupport_handle =
      _get_service_typesupport_handlePtr.asFunction<
          ffi.Pointer<rosidl_service_type_support_t> Function(
              ffi.Pointer<rosidl_service_type_support_t>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the service type support handle function specific to this identifier.
  /// /**
  /// * If the identifier is the same as this handle's typesupport_identifier the handle is simply
  /// * returned or if the parameters are NULL then an assert will happen.
  ///  *
  ///  * \param handle Handle to service type support
  ///  * \param identifier The typesupport identifier to get the handle function for
  ///  * \return if the identifier match's the handle's identifier then the handle's function
  ///  *   is returned.
  ///  */
  ffi.Pointer<rosidl_service_type_support_t>
      get_service_typesupport_handle_function(
    ffi.Pointer<rosidl_service_type_support_t> handle,
    ffi.Pointer<ffi.Char> identifier,
  ) {
    return _get_service_typesupport_handle_function(
      handle,
      identifier,
    );
  }

  late final _get_service_typesupport_handle_functionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rosidl_service_type_support_t> Function(
                  ffi.Pointer<rosidl_service_type_support_t>,
                  ffi.Pointer<ffi.Char>)>>(
      'get_service_typesupport_handle_function');
  late final _get_service_typesupport_handle_function =
      _get_service_typesupport_handle_functionPtr.asFunction<
          ffi.Pointer<rosidl_service_type_support_t> Function(
              ffi.Pointer<rosidl_service_type_support_t>,
              ffi.Pointer<ffi.Char>)>();

  /// Return a rcl_client_t struct with members set to `NULL`.
  /// /**
  ///  * Should be called to get a null rcl_client_t before passing to
  ///  * rcl_client_init().
  ///  */
  rcl_client_t rcl_get_zero_initialized_client() {
    return _rcl_get_zero_initialized_client();
  }

  late final _rcl_get_zero_initialized_clientPtr =
      _lookup<ffi.NativeFunction<rcl_client_t Function()>>(
          'rcl_get_zero_initialized_client');
  late final _rcl_get_zero_initialized_client =
      _rcl_get_zero_initialized_clientPtr.asFunction<rcl_client_t Function()>();

  /// Initialize a rcl client.
  /// /**
  ///  * After calling this function on a rcl_client_t, it can be used to send
  ///  * requests of the given type by calling rcl_send_request().
  ///  * If the request is received by a (possibly remote) service and if the service
  ///  * sends a response, the client can access the response through
  ///  * rcl_take_response() once the response is available to the client.
  ///  *
  ///  * The given rcl_node_t must be valid and the resulting rcl_client_t is only
  ///  * valid as long as the given rcl_node_t remains valid.
  ///  *
  ///  * The rosidl_service_type_support_t is obtained on a per `.srv` type basis.
  ///  * When the user defines a ROS service, code is generated which provides the
  ///  * required rosidl_service_type_support_t object.
  ///  * This object can be obtained using a language appropriate mechanism.
  ///  * \todo TODO(wjwwood) write these instructions once and link to it instead
  ///  *
  ///  * For C, a macro can be used (for example `example_interfaces/AddTwoInts`):
  ///  *
  ///  * ```c
  ///  * #include <rosidl_runtime_c/service_type_support_struct.h>
  ///  * #include <example_interfaces/srv/add_two_ints.h>
  ///  *
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  ///  * ```
  ///  *
  ///  * For C++, a template function is used:
  ///  *
  ///  * ```cpp
  ///  * #include <rosidl_typesupport_cpp/service_type_support.hpp>
  ///  * #include <example_interfaces/srv/add_two_ints.hpp>
  ///  *
  ///  * using rosidl_typesupport_cpp::get_service_type_support_handle;
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   get_service_type_support_handle<example_interfaces::srv::AddTwoInts>();
  ///  * ```
  ///  *
  ///  * The rosidl_service_type_support_t object contains service type specific
  ///  * information used to send or take requests and responses.
  ///  *
  ///  * The topic name must be a c string which follows the topic and service name
  ///  * format rules for unexpanded names, also known as non-fully qualified names:
  ///  *
  ///  * \see rcl_expand_topic_name
  ///  *
  ///  * The options struct allows the user to set the quality of service settings as
  ///  * well as a custom allocator which is used when initializing/finalizing the
  ///  * client to allocate space for incidentals, e.g. the service name string.
  ///  *
  ///  * Expected usage (for C services):
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  * #include <rosidl_runtime_c/service_type_support_struct.h>
  ///  * #include <example_interfaces/srv/add_two_ints.h>
  ///  *
  ///  * rcl_node_t node = rcl_get_zero_initialized_node();
  ///  * rcl_node_options_t node_ops = rcl_node_get_default_options();
  ///  * rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  ///  * // ... error handling
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  ///  * rcl_client_t client = rcl_get_zero_initialized_client();
  ///  * rcl_client_options_t client_ops = rcl_client_get_default_options();
  ///  * ret = rcl_client_init(&client, &node, ts, "add_two_ints", &client_ops);
  ///  * // ... error handling, and on shutdown do finalization:
  ///  * ret = rcl_client_fini(&client, &node);
  ///  * // ... error handling for rcl_client_fini()
  ///  * ret = rcl_node_fini(&node);
  ///  * // ... error handling for rcl_node_fini()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] client preallocated rcl_client_t structure
  ///  * \param[in] node valid rcl_node_t
  ///  * \param[in] type_support type support object for the service's type
  ///  * \param[in] service_name the name of the service to request
  ///  * \param[in] options client options, including quality of service settings
  ///  * \return #RCL_RET_OK if the client was initialized successfully, or
  ///  * \return #RCL_RET_NODE_INVALID if the node is invalid, or
  ///  * \return #RCL_RET_ALREADY_INIT if the client is already initialized, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory fails, or
  ///  * \return #RCL_RET_SERVICE_NAME_INVALID if the given service name is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_client_init(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Char> service_name,
    ffi.Pointer<rcl_client_options_t> options,
  ) {
    return _rcl_client_init(
      client,
      node,
      type_support,
      service_name,
      options,
    );
  }

  late final _rcl_client_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_client_t>,
              ffi.Pointer<rcl_node_t>,
              ffi.Pointer<rosidl_service_type_support_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<rcl_client_options_t>)>>('rcl_client_init');
  late final _rcl_client_init = _rcl_client_initPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_client_t>,
          ffi.Pointer<rcl_node_t>,
          ffi.Pointer<rosidl_service_type_support_t>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<rcl_client_options_t>)>();

  /// Finalize a rcl_client_t.
  /// /**
  ///  * After calling this function, calls to rcl_send_request() and
  ///  * rcl_take_response() will fail when using this client.
  ///  * However, the given node handle is still valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] client handle to the client to be finalized
  ///  * \param[in] node a valid (not finalized) handle to the node used to create the client
  ///  * \return #RCL_RET_OK if client was finalized successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_NODE_INVALID if the node is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_client_fini(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_client_fini(
      client,
      node,
    );
  }

  late final _rcl_client_finiPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_client_t>,
              ffi.Pointer<rcl_node_t>)>>('rcl_client_fini');
  late final _rcl_client_fini = _rcl_client_finiPtr.asFunction<
      int Function(ffi.Pointer<rcl_client_t>, ffi.Pointer<rcl_node_t>)>();

  /// Return the default client options in a rcl_client_options_t.
  /// /**
  ///  * The defaults are:
  ///  *
  ///  * - qos = rmw_qos_profile_services_default
  ///  * - allocator = rcl_get_default_allocator()
  ///  */
  rcl_client_options_t rcl_client_get_default_options() {
    return _rcl_client_get_default_options();
  }

  late final _rcl_client_get_default_optionsPtr =
      _lookup<ffi.NativeFunction<rcl_client_options_t Function()>>(
          'rcl_client_get_default_options');
  late final _rcl_client_get_default_options =
      _rcl_client_get_default_optionsPtr
          .asFunction<rcl_client_options_t Function()>();

  /// Send a ROS request using a client.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the `ros_request`
  ///  * parameter and the type associate with the client (via the type support)
  ///  * match.
  ///  * Passing a different type to `send_request` produces undefined behavior and
  ///  * cannot be checked by this function and therefore no deliberate error will
  ///  * occur.
  ///  *
  ///  * rcl_send_request() is an non-blocking call.
  ///  *
  ///  * The ROS request message given by the `ros_request` void pointer is always
  ///  * owned by the calling code, but should remain constant during `send_request`.
  ///  *
  ///  * This function is thread safe so long as access to both the client and the
  ///  * `ros_request` is synchronized.
  ///  * That means that calling rcl_send_request() from multiple threads is allowed,
  ///  * but calling rcl_send_request() at the same time as non-thread safe client
  ///  * functions is not, e.g. calling rcl_send_request() and rcl_client_fini()
  ///  * concurrently is not allowed.
  ///  * Before calling rcl_send_request() the message can change and after calling
  ///  * rcl_send_request() the message can change, but it cannot be changed during
  ///  * the `send_request` call.
  ///  * The same `ros_request`, however, can be passed to multiple calls of
  ///  * rcl_send_request() simultaneously, even if the clients differ.
  ///  * The `ros_request` is unmodified by rcl_send_request().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] for unique pairs of clients and requests, see above for more</i>
  ///  *
  ///  * \param[in] client handle to the client which will make the response
  ///  * \param[in] ros_request type-erased pointer to the ROS request message
  ///  * \param[out] sequence_number the sequence number
  ///  * \return #RCL_RET_OK if the request was sent successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_CLIENT_INVALID if the client is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_send_request(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<ffi.Void> ros_request,
    ffi.Pointer<ffi.Int64> sequence_number,
  ) {
    return _rcl_send_request(
      client,
      ros_request,
      sequence_number,
    );
  }

  late final _rcl_send_requestPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_client_t>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int64>)>>('rcl_send_request');
  late final _rcl_send_request = _rcl_send_requestPtr.asFunction<
      int Function(ffi.Pointer<rcl_client_t>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Int64>)>();

  /// Take a ROS response using a client
  /// /**
  ///  * It is the job of the caller to ensure that the type of the `ros_response`
  ///  * parameter and the type associate with the client (via the type support)
  ///  * match.
  ///  * Passing a different type to take_response produces undefined behavior and
  ///  * cannot be checked by this function and therefore no deliberate error will
  ///  * occur.
  ///  * The request_header is an rmw struct for meta-information about the request
  ///  * sent (e.g. the sequence number).
  ///  * The caller must provide a pointer to an allocated struct.
  ///  * This function will populate the struct's fields.
  ///  * `ros_response` should point to an already allocated ROS response message
  ///  * struct of the correct type, into which the response from the service will be
  ///  * copied.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] only if required when filling the message, avoided for fixed sizes</i>
  ///  *
  ///  * \param[in] client handle to the client which will take the response
  ///  * \param[inout] request_header pointer to the request header
  ///  * \param[inout] ros_response type-erased pointer to the ROS response message
  ///  * \return #RCL_RET_OK if the response was taken successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_CLIENT_INVALID if the client is invalid, or
  ///  * \return #RCL_RET_CLIENT_TAKE_FAILED if take failed but no error occurred
  ///  *         in the middleware, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_take_response_with_info(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<rmw_service_info_t> request_header,
    ffi.Pointer<ffi.Void> ros_response,
  ) {
    return _rcl_take_response_with_info(
      client,
      request_header,
      ros_response,
    );
  }

  late final _rcl_take_response_with_infoPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_client_t>,
              ffi.Pointer<rmw_service_info_t>,
              ffi.Pointer<ffi.Void>)>>('rcl_take_response_with_info');
  late final _rcl_take_response_with_info =
      _rcl_take_response_with_infoPtr.asFunction<
          int Function(ffi.Pointer<rcl_client_t>,
              ffi.Pointer<rmw_service_info_t>, ffi.Pointer<ffi.Void>)>();

  /// backwards compatibility function that takes a rmw_request_id_t only
  int rcl_take_response(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<rmw_request_id_t> request_header,
    ffi.Pointer<ffi.Void> ros_response,
  ) {
    return _rcl_take_response(
      client,
      request_header,
      ros_response,
    );
  }

  late final _rcl_take_responsePtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_client_t>,
              ffi.Pointer<rmw_request_id_t>,
              ffi.Pointer<ffi.Void>)>>('rcl_take_response');
  late final _rcl_take_response = _rcl_take_responsePtr.asFunction<
      int Function(ffi.Pointer<rcl_client_t>, ffi.Pointer<rmw_request_id_t>,
          ffi.Pointer<ffi.Void>)>();

  /// Get the name of the service that this client will request a response from.
  /// /**
  ///  * This function returns the client's internal service name string.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - client is `NULL`
  ///  *   - client is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned string is only valid as long as the rcl_client_t is valid.
  ///  * The value of the string may change if the service name changes, and therefore
  ///  * copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] client pointer to the client
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Char> rcl_client_get_service_name(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return _rcl_client_get_service_name(
      client,
    );
  }

  late final _rcl_client_get_service_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<rcl_client_t>)>>('rcl_client_get_service_name');
  late final _rcl_client_get_service_name = _rcl_client_get_service_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcl_client_t>)>();

  /// Return the rcl client options.
  /// /**
  ///  * This function returns the client's internal options struct.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - client is `NULL`
  ///  *   - client is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned struct is only valid as long as the rcl_client_t is valid.
  ///  * The values in the struct may change if the options of the client change,
  ///  * and therefore copying the struct is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] client pointer to the client
  ///  * \return options struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_client_options_t> rcl_client_get_options(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return _rcl_client_get_options(
      client,
    );
  }

  late final _rcl_client_get_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rcl_client_options_t> Function(
              ffi.Pointer<rcl_client_t>)>>('rcl_client_get_options');
  late final _rcl_client_get_options = _rcl_client_get_optionsPtr.asFunction<
      ffi.Pointer<rcl_client_options_t> Function(ffi.Pointer<rcl_client_t>)>();

  /// Return the rmw client handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - client is `NULL`
  ///  *   - client is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned handle is made invalid if the client is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * client as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the client using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] client pointer to the rcl client
  ///  * \return rmw client handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_client_t> rcl_client_get_rmw_handle(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return _rcl_client_get_rmw_handle(
      client,
    );
  }

  late final _rcl_client_get_rmw_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_client_t> Function(
              ffi.Pointer<rcl_client_t>)>>('rcl_client_get_rmw_handle');
  late final _rcl_client_get_rmw_handle =
      _rcl_client_get_rmw_handlePtr.asFunction<
          ffi.Pointer<rmw_client_t> Function(ffi.Pointer<rcl_client_t>)>();

  /// Check that the client is valid.
  /// /**
  ///  * The bool returned is `false` if client is invalid.
  ///  * The bool returned is `true` otherwise.
  ///  * In the case where `false` is to be returned, an error message is set.
  ///  * This function cannot fail.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] client pointer to the rcl client
  ///  * \return `true` if `client` is valid, otherwise `false`
  ///  */
  bool rcl_client_is_valid(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return _rcl_client_is_valid(
      client,
    );
  }

  late final _rcl_client_is_validPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_client_t>)>>(
          'rcl_client_is_valid');
  late final _rcl_client_is_valid = _rcl_client_is_validPtr
      .asFunction<bool Function(ffi.Pointer<rcl_client_t>)>();

  /// Get the actual qos settings of the client's request publisher.
  /// /**
  ///  * Used to get the actual qos settings of the client's request publisher.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the client, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  * The returned struct is only valid as long as the rcl_client_t is valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] client pointer to the rcl client
  ///  * \return qos struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_qos_profile_t> rcl_client_request_publisher_get_actual_qos(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return _rcl_client_request_publisher_get_actual_qos(
      client,
    );
  }

  late final _rcl_client_request_publisher_get_actual_qosPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rmw_qos_profile_t> Function(
                  ffi.Pointer<rcl_client_t>)>>(
      'rcl_client_request_publisher_get_actual_qos');
  late final _rcl_client_request_publisher_get_actual_qos =
      _rcl_client_request_publisher_get_actual_qosPtr.asFunction<
          ffi.Pointer<rmw_qos_profile_t> Function(ffi.Pointer<rcl_client_t>)>();

  /// Get the actual qos settings of the client's response subscription.
  /// /**
  ///  * Used to get the actual qos settings of the client's response subscription.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the client, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  * The returned struct is only valid as long as the rcl_client_t is valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] client pointer to the rcl client
  ///  * \return qos struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_qos_profile_t>
      rcl_client_response_subscription_get_actual_qos(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return _rcl_client_response_subscription_get_actual_qos(
      client,
    );
  }

  late final _rcl_client_response_subscription_get_actual_qosPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rmw_qos_profile_t> Function(
                  ffi.Pointer<rcl_client_t>)>>(
      'rcl_client_response_subscription_get_actual_qos');
  late final _rcl_client_response_subscription_get_actual_qos =
      _rcl_client_response_subscription_get_actual_qosPtr.asFunction<
          ffi.Pointer<rmw_qos_profile_t> Function(ffi.Pointer<rcl_client_t>)>();

  /// Set the on new response callback function for the client.
  /// /**
  ///  * This API sets the callback function to be called whenever the
  ///  * client is notified about a new response.
  ///  *
  ///  * \sa rmw_client_set_on_new_response_callback for details about this function.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined</i>
  ///  *
  ///  * \param[in] client The client on which to set the callback
  ///  * \param[in] callback The callback to be called when new responses arrive, may be NULL
  ///  * \param[in] user_data Given to the callback when called later, may be NULL
  ///  * \return `RCL_RET_OK` if callback was set to the listener, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if `client` is NULL, or
  ///  * \return `RCL_RET_UNSUPPORTED` if the API is not implemented in the dds implementation
  ///  */
  int rcl_client_set_on_new_response_callback(
    ffi.Pointer<rcl_client_t> client,
    rcl_event_callback_t callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rcl_client_set_on_new_response_callback(
      client,
      callback,
      user_data,
    );
  }

  late final _rcl_client_set_on_new_response_callbackPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_client_t>,
                  rcl_event_callback_t, ffi.Pointer<ffi.Void>)>>(
      'rcl_client_set_on_new_response_callback');
  late final _rcl_client_set_on_new_response_callback =
      _rcl_client_set_on_new_response_callbackPtr.asFunction<
          int Function(ffi.Pointer<rcl_client_t>, rcl_event_callback_t,
              ffi.Pointer<ffi.Void>)>();

  /// Return a rcl_service_t struct with members set to `NULL`.
  /// /**
  ///  * Should be called to get a null rcl_service_t before passing to
  ///  * rcl_service_init().
  ///  *
  ///  * \return A structure with a zero initialized service.
  ///  */
  rcl_service_t rcl_get_zero_initialized_service() {
    return _rcl_get_zero_initialized_service();
  }

  late final _rcl_get_zero_initialized_servicePtr =
      _lookup<ffi.NativeFunction<rcl_service_t Function()>>(
          'rcl_get_zero_initialized_service');
  late final _rcl_get_zero_initialized_service =
      _rcl_get_zero_initialized_servicePtr
          .asFunction<rcl_service_t Function()>();

  /// Initialize a rcl service.
  /// /**
  ///  * After calling this function on a rcl_service_t, it can be used to take
  ///  * requests of the given type to the given topic using rcl_take_request().
  ///  * It can also send a response to a request using rcl_send_response().
  ///  *
  ///  * The given rcl_node_t must be valid and the resulting rcl_service_t is
  ///  * only valid as long as the given rcl_node_t remains valid.
  ///  *
  ///  * The rosidl_service_type_support_t is obtained on a per .srv type basis.
  ///  * When the user defines a ROS service, code is generated which provides the
  ///  * required rosidl_service_type_support_t object.
  ///  * This object can be obtained using a language appropriate mechanism.
  ///  * \todo TODO(wjwwood) write these instructions once and link to it instead
  ///  *
  ///  * For C, a macro can be used (for example `example_interfaces/AddTwoInts`):
  ///  *
  ///  * ```c
  ///  * #include <rosidl_runtime_c/service_type_support_struct.h>
  ///  * #include <example_interfaces/srv/add_two_ints.h>
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  ///  * ```
  ///  *
  ///  * For C++, a template function is used:
  ///  *
  ///  * ```cpp
  ///  * #include <rosidl_runtime_cpp/service_type_support.hpp>
  ///  * #include <example_interfaces/srv/add_two_ints.h>
  ///  * using rosidl_typesupport_cpp::get_service_type_support_handle;
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   get_service_type_support_handle<example_interfaces::srv::AddTwoInts>();
  ///  * ```
  ///  *
  ///  * The rosidl_service_type_support_t object contains service type specific
  ///  * information used to send or take requests and responses.
  ///  *
  ///  * The topic name must be a c string which follows the topic and service name
  ///  * format rules for unexpanded names, also known as non-fully qualified names:
  ///  *
  ///  * \see rcl_expand_topic_name
  ///  *
  ///  * The options struct allows the user to set the quality of service settings as
  ///  * well as a custom allocator which is used when initializing/finalizing the
  ///  * client to allocate space for incidentals, e.g. the service name string.
  ///  *
  ///  * Expected usage (for C services):
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  * #include <rosidl_runtime_c/service_type_support_struct.h>
  ///  * #include <example_interfaces/srv/add_two_ints.h>
  ///  *
  ///  * rcl_node_t node = rcl_get_zero_initialized_node();
  ///  * rcl_node_options_t node_ops = rcl_node_get_default_options();
  ///  * rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  ///  * // ... error handling
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  ///  * rcl_service_t service = rcl_get_zero_initialized_service();
  ///  * rcl_service_options_t service_ops = rcl_service_get_default_options();
  ///  * ret = rcl_service_init(&service, &node, ts, "add_two_ints", &service_ops);
  ///  * // ... error handling, and on shutdown do finalization:
  ///  * ret = rcl_service_fini(&service, &node);
  ///  * // ... error handling for rcl_service_fini()
  ///  * ret = rcl_node_fini(&node);
  ///  * // ... error handling for rcl_node_fini()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[out] service preallocated service structure
  ///  * \param[in] node valid rcl node handle
  ///  * \param[in] type_support type support object for the service's type
  ///  * \param[in] service_name the name of the service
  ///  * \param[in] options service options, including quality of service settings
  ///  * \return #RCL_RET_OK if service was initialized successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ALREADY_INIT if the service is already initialized, or
  ///  * \return #RCL_RET_NODE_INVALID if the node is invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_SERVICE_NAME_INVALID if the given service name is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_service_init(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Char> service_name,
    ffi.Pointer<rcl_service_options_t> options,
  ) {
    return _rcl_service_init(
      service,
      node,
      type_support,
      service_name,
      options,
    );
  }

  late final _rcl_service_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_service_t>,
              ffi.Pointer<rcl_node_t>,
              ffi.Pointer<rosidl_service_type_support_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<rcl_service_options_t>)>>('rcl_service_init');
  late final _rcl_service_init = _rcl_service_initPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_service_t>,
          ffi.Pointer<rcl_node_t>,
          ffi.Pointer<rosidl_service_type_support_t>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<rcl_service_options_t>)>();

  /// Finalize a rcl_service_t.
  /// /**
  ///  * After calling, the node will no longer listen for requests for this service.
  ///  * (assuming this is the only service of this type in this node).
  ///  *
  ///  * After calling, calls to rcl_wait(), rcl_take_request(), and
  ///  * rcl_send_response() will fail when using this service.
  ///  * Additionally rcl_wait() will be interrupted if currently blocking.
  ///  * However, the given node handle is still valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] service handle to the service to be deinitialized
  ///  * \param[in] node a valid (not finalized) handle to the node used to create the service
  ///  * \return #RCL_RET_OK if service was deinitialized successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_SERVICE_INVALID if the service is invalid, or
  ///  * \return #RCL_RET_NODE_INVALID if the node is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_service_fini(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_service_fini(
      service,
      node,
    );
  }

  late final _rcl_service_finiPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_service_t>,
              ffi.Pointer<rcl_node_t>)>>('rcl_service_fini');
  late final _rcl_service_fini = _rcl_service_finiPtr.asFunction<
      int Function(ffi.Pointer<rcl_service_t>, ffi.Pointer<rcl_node_t>)>();

  /// Return the default service options in a rcl_service_options_t.
  /// /**
  ///  * The defaults are:
  ///  *
  ///  * - qos = rmw_qos_profile_services_default
  ///  * - allocator = rcl_get_default_allocator()
  ///  */
  rcl_service_options_t rcl_service_get_default_options() {
    return _rcl_service_get_default_options();
  }

  late final _rcl_service_get_default_optionsPtr =
      _lookup<ffi.NativeFunction<rcl_service_options_t Function()>>(
          'rcl_service_get_default_options');
  late final _rcl_service_get_default_options =
      _rcl_service_get_default_optionsPtr
          .asFunction<rcl_service_options_t Function()>();

  /// Take a pending ROS request using a rcl service.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the ros_request
  ///  * argument and the type associate with the service, via the type
  ///  * support, match.
  ///  * Passing a different type to rcl_take produces undefined behavior and cannot
  ///  * be checked by this function and therefore no deliberate error will occur.
  ///  *
  ///  * TODO(jacquelinekay) blocking of take?
  ///  * TODO(jacquelinekay) pre-, during-, and post-conditions for message ownership?
  ///  * TODO(jacquelinekay) is rcl_take_request thread-safe?
  ///  * TODO(jacquelinekay) Should there be an rcl_request_id_t?
  ///  *
  ///  * The ros_request pointer should point to an already allocated ROS request message
  ///  * struct of the correct type, into which the taken ROS request will be copied
  ///  * if one is available.
  ///  * If taken is false after calling, then the ROS request will be unmodified.
  ///  *
  ///  * If allocation is required when taking the request, e.g. if space needs to
  ///  * be allocated for a dynamically sized array in the target message, then the
  ///  * allocator given in the service options is used.
  ///  *
  ///  * request_header is a pointer to pre-allocated a rmw struct containing
  ///  * meta-information about the request (e.g. the sequence number).
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] only if required when filling the request, avoided for fixed sizes</i>
  ///  *
  ///  * \param[in] service the handle to the service from which to take
  ///  * \param[inout] request_header ptr to the struct holding metadata about the request
  ///  * \param[inout] ros_request type-erased ptr to an allocated ROS request message
  ///  * \return #RCL_RET_OK if the request was taken, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_SERVICE_INVALID if the service is invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_SERVICE_TAKE_FAILED if take failed but no error occurred
  ///  *         in the middleware, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_take_request_with_info(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rmw_service_info_t> request_header,
    ffi.Pointer<ffi.Void> ros_request,
  ) {
    return _rcl_take_request_with_info(
      service,
      request_header,
      ros_request,
    );
  }

  late final _rcl_take_request_with_infoPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_service_t>,
              ffi.Pointer<rmw_service_info_t>,
              ffi.Pointer<ffi.Void>)>>('rcl_take_request_with_info');
  late final _rcl_take_request_with_info =
      _rcl_take_request_with_infoPtr.asFunction<
          int Function(ffi.Pointer<rcl_service_t>,
              ffi.Pointer<rmw_service_info_t>, ffi.Pointer<ffi.Void>)>();

  /// Backwards compatibility function to take a pending ROS request using a rcl service.
  /// /**
  ///  * This version takes a request ID only.  See rcl_take_request_with_info() for a full
  ///  * explanation of what this does.
  ///  *
  ///  * \param[in] service the handle to the service from which to take
  ///  * \param[inout] request_header ptr to the struct holding the id of the request
  ///  * \param[inout] ros_request type-erased ptr to an allocated ROS request message
  ///  * \return #RCL_RET_OK if the request was taken, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_SERVICE_INVALID if the service is invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_SERVICE_TAKE_FAILED if take failed but no error occurred
  ///  *         in the middleware, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_take_request(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rmw_request_id_t> request_header,
    ffi.Pointer<ffi.Void> ros_request,
  ) {
    return _rcl_take_request(
      service,
      request_header,
      ros_request,
    );
  }

  late final _rcl_take_requestPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_service_t>,
              ffi.Pointer<rmw_request_id_t>,
              ffi.Pointer<ffi.Void>)>>('rcl_take_request');
  late final _rcl_take_request = _rcl_take_requestPtr.asFunction<
      int Function(ffi.Pointer<rcl_service_t>, ffi.Pointer<rmw_request_id_t>,
          ffi.Pointer<ffi.Void>)>();

  /// Send a ROS response to a client using a service.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the `ros_response`
  ///  * parameter and the type associate with the service (via the type support)
  ///  * match.
  ///  * Passing a different type to send_response produces undefined behavior and
  ///  * cannot be checked by this function and therefore no deliberate error will
  ///  * occur.
  ///  *
  ///  * send_response() is an non-blocking call.
  ///  *
  ///  * The ROS response message given by the `ros_response` void pointer is always
  ///  * owned by the calling code, but should remain constant during
  ///  * rcl_send_response().
  ///  *
  ///  * This function is thread safe so long as access to both the service and the
  ///  * `ros_response` is synchronized.
  ///  * That means that calling rcl_send_response() from multiple threads is
  ///  * allowed, but calling rcl_send_response() at the same time as non-thread safe
  ///  * service functions is not, e.g. calling rcl_send_response() and
  ///  * rcl_service_fini() concurrently is not allowed.
  ///  * Before calling rcl_send_response() the message can change and after calling
  ///  * rcl_send_response() the message can change, but it cannot be changed during
  ///  * the rcl_send_response() call.
  ///  * The same `ros_response`, however, can be passed to multiple calls of
  ///  * rcl_send_response() simultaneously, even if the services differ.
  ///  * The `ros_response` is unmodified by rcl_send_response().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] for unique pairs of services and responses, see above for more</i>
  ///  *
  ///  * \param[in] service handle to the service which will make the response
  ///  * \param[inout] response_header ptr to the struct holding metadata about the request ID
  ///  * \param[in] ros_response type-erased pointer to the ROS response message
  ///  * \return #RCL_RET_OK if the response was sent successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_SERVICE_INVALID if the service is invalid, or
  ///  * \return #RCL_RET_TIMEOUT if a response reader is not ready yet, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_send_response(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rmw_request_id_t> response_header,
    ffi.Pointer<ffi.Void> ros_response,
  ) {
    return _rcl_send_response(
      service,
      response_header,
      ros_response,
    );
  }

  late final _rcl_send_responsePtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_service_t>,
              ffi.Pointer<rmw_request_id_t>,
              ffi.Pointer<ffi.Void>)>>('rcl_send_response');
  late final _rcl_send_response = _rcl_send_responsePtr.asFunction<
      int Function(ffi.Pointer<rcl_service_t>, ffi.Pointer<rmw_request_id_t>,
          ffi.Pointer<ffi.Void>)>();

  /// Get the topic name for the service.
  /// /**
  ///  * This function returns the service's internal topic name string.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - service is `NULL`
  ///  *   - service is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned string is only valid as long as the service is valid.
  ///  * The value of the string may change if the topic name changes, and therefore
  ///  * copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] service the pointer to the service
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Char> rcl_service_get_service_name(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return _rcl_service_get_service_name(
      service,
    );
  }

  late final _rcl_service_get_service_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<rcl_service_t>)>>('rcl_service_get_service_name');
  late final _rcl_service_get_service_name = _rcl_service_get_service_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<rcl_service_t>)>();

  /// Return the rcl service options.
  /// /**
  ///  * This function returns the service's internal options struct.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - service is `NULL`
  ///  *   - service is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned struct is only valid as long as the service is valid.
  ///  * The values in the struct may change if the service's options change,
  ///  * and therefore copying the struct is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] service pointer to the service
  ///  * \return options struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_service_options_t> rcl_service_get_options(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return _rcl_service_get_options(
      service,
    );
  }

  late final _rcl_service_get_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rcl_service_options_t> Function(
              ffi.Pointer<rcl_service_t>)>>('rcl_service_get_options');
  late final _rcl_service_get_options = _rcl_service_get_optionsPtr.asFunction<
      ffi.Pointer<rcl_service_options_t> Function(
          ffi.Pointer<rcl_service_t>)>();

  /// Return the rmw service handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - service is `NULL`
  ///  *   - service is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned handle is made invalid if the service is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * service as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the service using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] service pointer to the rcl service
  ///  * \return rmw service handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_service_t> rcl_service_get_rmw_handle(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return _rcl_service_get_rmw_handle(
      service,
    );
  }

  late final _rcl_service_get_rmw_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_service_t> Function(
              ffi.Pointer<rcl_service_t>)>>('rcl_service_get_rmw_handle');
  late final _rcl_service_get_rmw_handle =
      _rcl_service_get_rmw_handlePtr.asFunction<
          ffi.Pointer<rmw_service_t> Function(ffi.Pointer<rcl_service_t>)>();

  /// Check that the service is valid.
  /// /**
  ///  * The bool returned is `false` if `service` is invalid.
  ///  * The bool returned is `true` otherwise.
  ///  * In the case where `false` is to be returned, an error message is set.
  ///  * This function cannot fail.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] service pointer to the rcl service
  ///  * \return `true` if `service` is valid, otherwise `false`
  ///  */
  bool rcl_service_is_valid(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return _rcl_service_is_valid(
      service,
    );
  }

  late final _rcl_service_is_validPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_service_t>)>>(
      'rcl_service_is_valid');
  late final _rcl_service_is_valid = _rcl_service_is_validPtr
      .asFunction<bool Function(ffi.Pointer<rcl_service_t>)>();

  /// Get the actual qos settings of the service's request subscription.
  /// /**
  ///  * Used to get the actual qos settings of the service's request subscription.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the service, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  * The returned struct is only valid as long as the rcl_service_t is valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] service pointer to the rcl service
  ///  * \return qos struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_qos_profile_t>
      rcl_service_request_subscription_get_actual_qos(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return _rcl_service_request_subscription_get_actual_qos(
      service,
    );
  }

  late final _rcl_service_request_subscription_get_actual_qosPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rmw_qos_profile_t> Function(
                  ffi.Pointer<rcl_service_t>)>>(
      'rcl_service_request_subscription_get_actual_qos');
  late final _rcl_service_request_subscription_get_actual_qos =
      _rcl_service_request_subscription_get_actual_qosPtr.asFunction<
          ffi.Pointer<rmw_qos_profile_t> Function(
              ffi.Pointer<rcl_service_t>)>();

  /// Get the actual qos settings of the service's response publisher.
  /// /**
  ///  * Used to get the actual qos settings of the service's response publisher.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the service, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  * The returned struct is only valid as long as the rcl_service_t is valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] service pointer to the rcl service
  ///  * \return qos struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_qos_profile_t> rcl_service_response_publisher_get_actual_qos(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return _rcl_service_response_publisher_get_actual_qos(
      service,
    );
  }

  late final _rcl_service_response_publisher_get_actual_qosPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rmw_qos_profile_t> Function(
                  ffi.Pointer<rcl_service_t>)>>(
      'rcl_service_response_publisher_get_actual_qos');
  late final _rcl_service_response_publisher_get_actual_qos =
      _rcl_service_response_publisher_get_actual_qosPtr.asFunction<
          ffi.Pointer<rmw_qos_profile_t> Function(
              ffi.Pointer<rcl_service_t>)>();

  /// Set the on new request callback function for the service.
  /// /**
  ///  * This API sets the callback function to be called whenever the
  ///  * service is notified about a new request.
  ///  *
  ///  * \sa rmw_service_set_on_new_request_callback for details about this function.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined</i>
  ///  *
  ///  * \param[in] service The service on which to set the callback
  ///  * \param[in] callback The callback to be called when new requests arrive, may be NULL
  ///  * \param[in] user_data Given to the callback when called later, may be NULL
  ///  * \return `RCL_RET_OK` if callback was set to the listener, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if `service` is NULL, or
  ///  * \return `RCL_RET_UNSUPPORTED` if the API is not implemented in the dds implementation
  ///  */
  int rcl_service_set_on_new_request_callback(
    ffi.Pointer<rcl_service_t> service,
    rcl_event_callback_t callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rcl_service_set_on_new_request_callback(
      service,
      callback,
      user_data,
    );
  }

  late final _rcl_service_set_on_new_request_callbackPtr = _lookup<
          ffi.NativeFunction<
              rcl_ret_t Function(ffi.Pointer<rcl_service_t>,
                  rcl_event_callback_t, ffi.Pointer<ffi.Void>)>>(
      'rcl_service_set_on_new_request_callback');
  late final _rcl_service_set_on_new_request_callback =
      _rcl_service_set_on_new_request_callbackPtr.asFunction<
          int Function(ffi.Pointer<rcl_service_t>, rcl_event_callback_t,
              ffi.Pointer<ffi.Void>)>();

  /// Get the message bounds handle specific to this identifier.
  /// /**
  ///  * The handle's sequence bound is simply returned or if the parameters are NULL then an assert
  ///  * will happen.
  ///  *
  ///  * \param handle Handle to service type support
  ///  * \param identifier The identifier to get the handle for
  ///  * \return The associated sequence bound handle function.
  ///  */
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> get_sequence_bound_handle(
    ffi.Pointer<rosidl_runtime_c__Sequence__bound> handle,
    ffi.Pointer<ffi.Char> identifier,
  ) {
    return _get_sequence_bound_handle(
      handle,
      identifier,
    );
  }

  late final _get_sequence_bound_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rosidl_runtime_c__Sequence__bound> Function(
              ffi.Pointer<rosidl_runtime_c__Sequence__bound>,
              ffi.Pointer<ffi.Char>)>>('get_sequence_bound_handle');
  late final _get_sequence_bound_handle =
      _get_sequence_bound_handlePtr.asFunction<
          ffi.Pointer<rosidl_runtime_c__Sequence__bound> Function(
              ffi.Pointer<rosidl_runtime_c__Sequence__bound>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the message bounds handle function specific to this identifier.
  /// /**
  ///  * If the identifier is the same as this handle function's identifier the handle is simply returned
  ///  * or if the parameters are NULL then an assert will happen.
  ///  *
  ///  * \param handle Handle to service type support
  ///  * \param identifier The identifier to get the handle function for
  ///  * \return if the identifier match's the handle's identifier then the handle's function
  ///  *   is returned.
  ///  */
  ffi.Pointer<rosidl_runtime_c__Sequence__bound>
      get_sequence_bound_handle_function(
    ffi.Pointer<rosidl_runtime_c__Sequence__bound> handle,
    ffi.Pointer<ffi.Char> identifier,
  ) {
    return _get_sequence_bound_handle_function(
      handle,
      identifier,
    );
  }

  late final _get_sequence_bound_handle_functionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rosidl_runtime_c__Sequence__bound> Function(
              ffi.Pointer<rosidl_runtime_c__Sequence__bound>,
              ffi.Pointer<ffi.Char>)>>('get_sequence_bound_handle_function');
  late final _get_sequence_bound_handle_function =
      _get_sequence_bound_handle_functionPtr.asFunction<
          ffi.Pointer<rosidl_runtime_c__Sequence__bound> Function(
              ffi.Pointer<rosidl_runtime_c__Sequence__bound>,
              ffi.Pointer<ffi.Char>)>();

  /// Return a zero initialized event structure.
  rmw_event_t rmw_get_zero_initialized_event() {
    return _rmw_get_zero_initialized_event();
  }

  late final _rmw_get_zero_initialized_eventPtr =
      _lookup<ffi.NativeFunction<rmw_event_t Function()>>(
          'rmw_get_zero_initialized_event');
  late final _rmw_get_zero_initialized_event =
      _rmw_get_zero_initialized_eventPtr.asFunction<rmw_event_t Function()>();

  /// Initialize a rmw publisher event.
  /// /**
  ///  * \param[inout] rmw_event to initialize
  ///  * \param[in] publisher to initialize with
  ///  * \param[inout] event_type for the event to initialize
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if invalid argument, or
  ///  * \return `RMW_RET_UNSUPPORTED` if event_type is not supported, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_publisher_event_init(
    ffi.Pointer<rmw_event_t> rmw_event,
    ffi.Pointer<rmw_publisher_t> publisher,
    int event_type,
  ) {
    return _rmw_publisher_event_init(
      rmw_event,
      publisher,
      event_type,
    );
  }

  late final _rmw_publisher_event_initPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<rmw_event_t>,
              ffi.Pointer<rmw_publisher_t>,
              ffi.Int32)>>('rmw_publisher_event_init');
  late final _rmw_publisher_event_init =
      _rmw_publisher_event_initPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_event_t>, ffi.Pointer<rmw_publisher_t>, int)>();

  /// Initialize a rmw subscription event.
  /// /**
  ///  * \param[inout] rmw_event to initialize
  ///  * \param[in] subscription to initialize with
  ///  * \param[inout] event_type for the event to handle
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if invalid argument, or
  ///  * \return `RMW_RET_UNSUPPORTED` if event_type is not supported, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_subscription_event_init(
    ffi.Pointer<rmw_event_t> rmw_event,
    ffi.Pointer<rmw_subscription_t> subscription,
    int event_type,
  ) {
    return _rmw_subscription_event_init(
      rmw_event,
      subscription,
      event_type,
    );
  }

  late final _rmw_subscription_event_initPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<rmw_event_t>,
              ffi.Pointer<rmw_subscription_t>,
              ffi.Int32)>>('rmw_subscription_event_init');
  late final _rmw_subscription_event_init =
      _rmw_subscription_event_initPtr.asFunction<
          int Function(ffi.Pointer<rmw_event_t>,
              ffi.Pointer<rmw_subscription_t>, int)>();

  /// Take an event from the event handle.
  /// /**
  ///  * \param[in] event_handle event object to take from
  ///  * \param[inout] event_info event info object to write taken data into
  ///  * \param[out] taken boolean flag indicating if an event was taken or not
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_event(
    ffi.Pointer<rmw_event_t> event_handle,
    ffi.Pointer<ffi.Void> event_info,
    ffi.Pointer<ffi.Bool> taken,
  ) {
    return _rmw_take_event(
      event_handle,
      event_info,
      taken,
    );
  }

  late final _rmw_take_eventPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_event_t>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Bool>)>>('rmw_take_event');
  late final _rmw_take_event = _rmw_take_eventPtr.asFunction<
      int Function(ffi.Pointer<rmw_event_t>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Bool>)>();

  /// Finalize an rmw_event_t.
  /// /**
  ///  * \param[in] event to finalize
  ///  */
  int rmw_event_fini(
    ffi.Pointer<rmw_event_t> event,
  ) {
    return _rmw_event_fini(
      event,
    );
  }

  late final _rmw_event_finiPtr =
      _lookup<ffi.NativeFunction<rmw_ret_t Function(ffi.Pointer<rmw_event_t>)>>(
          'rmw_event_fini');
  late final _rmw_event_fini =
      _rmw_event_finiPtr.asFunction<int Function(ffi.Pointer<rmw_event_t>)>();

  /// Return a rmw_publisher_options_t initialized with default values.
  rmw_publisher_options_t rmw_get_default_publisher_options() {
    return _rmw_get_default_publisher_options();
  }

  late final _rmw_get_default_publisher_optionsPtr =
      _lookup<ffi.NativeFunction<rmw_publisher_options_t Function()>>(
          'rmw_get_default_publisher_options');
  late final _rmw_get_default_publisher_options =
      _rmw_get_default_publisher_optionsPtr
          .asFunction<rmw_publisher_options_t Function()>();

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_sensor_data =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_sensor_data');

  rmw_qos_profile_t get rmw_qos_profile_sensor_data =>
      _rmw_qos_profile_sensor_data.ref;

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_parameters =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_parameters');

  rmw_qos_profile_t get rmw_qos_profile_parameters =>
      _rmw_qos_profile_parameters.ref;

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_default =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_default');

  rmw_qos_profile_t get rmw_qos_profile_default => _rmw_qos_profile_default.ref;

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_services_default =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_services_default');

  rmw_qos_profile_t get rmw_qos_profile_services_default =>
      _rmw_qos_profile_services_default.ref;

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_parameter_events =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_parameter_events');

  rmw_qos_profile_t get rmw_qos_profile_parameter_events =>
      _rmw_qos_profile_parameter_events.ref;

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_system_default =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_system_default');

  rmw_qos_profile_t get rmw_qos_profile_system_default =>
      _rmw_qos_profile_system_default.ref;

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_unknown =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_unknown');

  rmw_qos_profile_t get rmw_qos_profile_unknown => _rmw_qos_profile_unknown.ref;

  /// Check if two QoS profiles are compatible.
  /// /**
  ///  * Two QoS profiles are compatible if a publisher and subcription
  ///  * using the QoS policies can communicate with each other.
  ///  *
  ///  * If any of the profile policies has the value "system default" or "unknown", then it may not be
  ///  * possible to determine the compatibilty.
  ///  * In this case, the output parameter `compatibility` is set to `RMW_QOS_COMPATIBILITY_WARNING`
  ///  * and `reason` is populated.
  ///  *
  ///  * If there is a compatibility warning or error, and a buffer is provided for `reason`, then an
  ///  * explanation of all warnings and errors will be populated into the buffer, separated by
  ///  * semi-colons (`;`).
  ///  * Errors will appear before warnings in the string buffer.
  ///  * If the provided buffer is not large enough, this function will still write to the buffer, up to
  ///  * the `reason_size` number of characters.
  ///  * Therefore, it is possible that not all errors and warnings are communicated if the buffer size limit
  ///  * is reached.
  ///  * A buffer size of 2048 should be more than enough to capture all possible errors and warnings.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher_profile: The QoS profile used for a publisher.
  ///  * \param[in] subscription_profile: The QoS profile used for a subscription.
  ///  * \param[out] compatibility: `RMW_QOS_COMPATIBILITY_OK` if the QoS profiles are compatible, or
  ///  *   `RMW_QOS_COMPATIBILITY_WARNING` if the QoS profiles might be compatible, or
  ///  *   `RMW_QOS_COMPATIBILITY_ERROR` if the QoS profiles are not compatible.
  ///  * \param[out] reason: A detailed reason for a QoS incompatibility or potential incompatibility.
  ///  *   Must be pre-allocated by the caller.
  ///  *   This parameter is optional and may be set to `NULL` if the reason information is not
  ///  *   desired.
  ///  * \param[in] reason_size: Size of the string buffer `reason`, if one is provided.
  ///  *   If `reason` is `nullptr`, then this parameter must be zero.
  ///  * \return `RMW_RET_OK` if the check was successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `compatiblity` is `nullptr`, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `reason` is `NULL` and  `reason_size` is not zero, or
  ///  * \return `RMW_RET_ERROR` if there is an unexpected error.
  ///  */
  int rmw_qos_profile_check_compatible(
    rmw_qos_profile_t publisher_profile,
    rmw_qos_profile_t subscription_profile,
    ffi.Pointer<ffi.Int32> compatibility,
    ffi.Pointer<ffi.Char> reason,
    int reason_size,
  ) {
    return _rmw_qos_profile_check_compatible(
      publisher_profile,
      subscription_profile,
      compatibility,
      reason,
      reason_size,
    );
  }

  late final _rmw_qos_profile_check_compatiblePtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              rmw_qos_profile_t,
              rmw_qos_profile_t,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('rmw_qos_profile_check_compatible');
  late final _rmw_qos_profile_check_compatible =
      _rmw_qos_profile_check_compatiblePtr.asFunction<
          int Function(rmw_qos_profile_t, rmw_qos_profile_t,
              ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Char>, int)>();

  /// Return a rmw_subscription_options_t initialized with default values.
  rmw_subscription_options_t rmw_get_default_subscription_options() {
    return _rmw_get_default_subscription_options();
  }

  late final _rmw_get_default_subscription_optionsPtr =
      _lookup<ffi.NativeFunction<rmw_subscription_options_t Function()>>(
          'rmw_get_default_subscription_options');
  late final _rmw_get_default_subscription_options =
      _rmw_get_default_subscription_optionsPtr
          .asFunction<rmw_subscription_options_t Function()>();

  /// Get the name of the rmw implementation being used
  /// /**
  ///  * \return Name of rmw implementation
  ///  */
  ffi.Pointer<ffi.Char> rmw_get_implementation_identifier() {
    return _rmw_get_implementation_identifier();
  }

  late final _rmw_get_implementation_identifierPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'rmw_get_implementation_identifier');
  late final _rmw_get_implementation_identifier =
      _rmw_get_implementation_identifierPtr
          .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the unique serialization format for this middleware.
  /// /**
  ///  * Return the format in which binary data is serialized.
  ///  * One middleware can only have one encoding.
  ///  * In contrast to the implementation identifier, the serialization format can be equal between
  ///  * multiple RMW implementations.
  ///  * This means, that the same binary messages can be deserialized by RMW implementations with the
  ///  * same format.
  ///  * \sa rmw_serialize
  ///  * \sa rmw_deserialize
  ///  * \return serialization format
  ///  */
  ffi.Pointer<ffi.Char> rmw_get_serialization_format() {
    return _rmw_get_serialization_format();
  }

  late final _rmw_get_serialization_formatPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'rmw_get_serialization_format');
  late final _rmw_get_serialization_format = _rmw_get_serialization_formatPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// TODO(wjwwood): refactor this API to return a return code when updated to use an allocator
  /// Create a node and return a handle to that node.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - name is not a valid non-null node name
  ///  *   - namespace_ is not a valid non-null namespace
  ///  *   - context is not valid i.e. it is zero-initialized, or
  ///  *     its implementation identifier does not match that of
  ///  *     this API implementation, or has been invalidated by
  ///  *     `rmw_shutdown()`
  ///  *   - memory allocation fails during node creation
  ///  *   - an unspecified error occurs
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No [1]
  ///  * Lock-Free          | No [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[in] context init context that this node should be associated with
  ///  * \param[in] name the node name
  ///  * \param[in] namespace_ the node namespace
  ///  * \return rmw node handle, or `NULL` if there was an error
  ///  */
  ffi.Pointer<rmw_node_t> rmw_create_node(
    ffi.Pointer<rmw_context_t> context,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> namespace_,
  ) {
    return _rmw_create_node(
      context,
      name,
      namespace_,
    );
  }

  late final _rmw_create_nodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_node_t> Function(
              ffi.Pointer<rmw_context_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('rmw_create_node');
  late final _rmw_create_node = _rmw_create_nodePtr.asFunction<
      ffi.Pointer<rmw_node_t> Function(ffi.Pointer<rmw_context_t>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Finalize a given node handle, reclaim the resources, and deallocate the node handle.
  /// /**
  ///  * This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  ///  * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given node handle unchanged.
  ///  * Otherwise, it will proceed despite errors, freeing as many resources as it can, including
  ///  * the node handle. Usage of a deallocated node handle is undefined behavior.
  ///  *
  ///  * \pre All publishers, subscribers, services, and clients created from this node must
  ///  *   have been destroyed prior to this call. Some rmw implementations may verify this,
  ///  *   returning `RMW_RET_ERROR` and setting a human readable error message if any entity
  ///  *   created from this node has not yet been destroyed. However, this is not guaranteed
  ///  *   and so callers should ensure that this is the case before calling this function.
  ///  *
  ///  * \param[in] node the node handle to be destroyed
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if node is invalid, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  ///  *   identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_destroy_node(
    ffi.Pointer<rmw_node_t> node,
  ) {
    return _rmw_destroy_node(
      node,
    );
  }

  late final _rmw_destroy_nodePtr =
      _lookup<ffi.NativeFunction<rmw_ret_t Function(ffi.Pointer<rmw_node_t>)>>(
          'rmw_destroy_node');
  late final _rmw_destroy_node =
      _rmw_destroy_nodePtr.asFunction<int Function(ffi.Pointer<rmw_node_t>)>();

  /// \deprecated `rmw_node_assert_liveliness` implementation was removed.
  /// If manual liveliness assertion is needed, use MANUAL_BY_TOPIC.
  int rmw_node_assert_liveliness(
    ffi.Pointer<rmw_node_t> node,
  ) {
    return _rmw_node_assert_liveliness(
      node,
    );
  }

  late final _rmw_node_assert_livelinessPtr =
      _lookup<ffi.NativeFunction<rmw_ret_t Function(ffi.Pointer<rmw_node_t>)>>(
          'rmw_node_assert_liveliness');
  late final _rmw_node_assert_liveliness = _rmw_node_assert_livelinessPtr
      .asFunction<int Function(ffi.Pointer<rmw_node_t>)>();

  /// Return a guard condition which is triggered when the ROS graph changes.
  /// /**
  ///  * The guard condition will be triggered anytime a change to the ROS graph occurs.
  ///  * A ROS graph change occurs whenever:
  ///  * - A node joins or leaves the ROS graph.
  ///  *   This change will be reflected in rmw_get_node_names() and
  ///  *   rmw_get_node_names_with_enclaves() outcome.
  ///  * - A topic subscription joins or leaves the ROS graph.
  ///  *   This change will be reflected in rmw_get_topic_names_and_types(),
  ///  *   rmw_get_subscriber_names_and_types_by_node(), and
  ///  *   rmw_get_subscriptions_info_by_topic() outcome.
  ///  * - A topic publisher joins or leaves the ROS graph.
  ///  *   This change will be reflected in rmw_get_topic_names_and_types(),
  ///  *   rmw_get_publisher_names_and_types_by_node(), and
  ///  *   rmw_get_publishers_info_by_topic() outcome.
  ///  * - A topic subscription matches a topic publisher with compatible QoS policies.
  ///  *   This change will be reflected in rmw_subscription_count_matched_publishers() outcome.
  ///  * - A topic publisher matches a topic subscription with compatible QoS policies.
  ///  *   This change will be reflected in rmw_publisher_count_matched_subscriptions() outcome.
  ///  * - A service server joins or leaves the ROS graph.
  ///  *   This change will be reflected in rmw_get_service_names_and_types() and
  ///  *   rmw_get_service_names_and_types_by_node() outcome.
  ///  * - A service client joins or leaves the ROS graph.
  ///  *   This change will be reflected in rmw_get_service_names_and_types() and
  ///  *   rmw_get_client_names_and_types_by_node() outcome.
  ///  * - A service client matches a service server with compatible QoS policies.
  ///  *   This change will be reflected in rmw_service_server_is_available() outcome.
  ///  *
  ///  * \note The state of the ROS graph, and any changes that may take place,
  ///  *   are reported as seen by the associated `node`.
  ///  *
  ///  * The guard condition is owned and internally held by the `node`.
  ///  * It will be invalidated if `node` is finalized using rmw_destroy_node().
  ///  * It is undefined behavior to use an invalidated guard condition.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \pre Given `node` must be a valid node handle, as returned by rmw_create_node().
  ///  *
  ///  * \param[in] node Node to retrieve the guard condition from.
  ///  * \return Guard condition if successful, or `NULL` if
  ///  *   `node` is `NULL`, or an unspecified error occurs.
  ///  */
  ffi.Pointer<rmw_guard_condition_t> rmw_node_get_graph_guard_condition(
    ffi.Pointer<rmw_node_t> node,
  ) {
    return _rmw_node_get_graph_guard_condition(
      node,
    );
  }

  late final _rmw_node_get_graph_guard_conditionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_guard_condition_t> Function(
              ffi.Pointer<rmw_node_t>)>>('rmw_node_get_graph_guard_condition');
  late final _rmw_node_get_graph_guard_condition =
      _rmw_node_get_graph_guard_conditionPtr.asFunction<
          ffi.Pointer<rmw_guard_condition_t> Function(
              ffi.Pointer<rmw_node_t>)>();

  /// Initialize a publisher allocation to be used with later publications.
  /// /**
  ///  * This creates an allocation object that can be used in conjunction with
  ///  * the rmw_publish method to perform more carefully control memory allocations.
  ///  *
  ///  * This will allow the middleware to preallocate the correct amount of memory
  ///  * for a given message type and message bounds.
  ///  * As allocation is performed in this method, it will not be necessary to allocate
  ///  * in the `rmw_publish` method.
  ///  *
  ///  * \param[in] type_support Type support of the message to be preallocated.
  ///  * \param[in] message_bounds Bounds structure of the message to be preallocated.
  ///  * \param[out] allocation Allocation structure to be passed to `rmw_publish`.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_UNSUPPORTED` if it's unimplemented
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_init_publisher_allocation(
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rmw_init_publisher_allocation(
      type_support,
      message_bounds,
      allocation,
    );
  }

  late final _rmw_init_publisher_allocationPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rosidl_message_type_support_t>,
                  ffi.Pointer<rosidl_runtime_c__Sequence__bound>,
                  ffi.Pointer<rmw_publisher_allocation_t>)>>(
      'rmw_init_publisher_allocation');
  late final _rmw_init_publisher_allocation =
      _rmw_init_publisher_allocationPtr.asFunction<
          int Function(
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<rosidl_runtime_c__Sequence__bound>,
              ffi.Pointer<rmw_publisher_allocation_t>)>();

  /// Destroy a publisher allocation object.
  /// /**
  ///  * This deallocates any memory allocated by `rmw_init_publisher_allocation`.
  ///  *
  ///  * \param[in] allocation Allocation object to be destroyed.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_UNSUPPORTED` if it's unimplemented
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_fini_publisher_allocation(
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rmw_fini_publisher_allocation(
      allocation,
    );
  }

  late final _rmw_fini_publisher_allocationPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_publisher_allocation_t>)>>(
      'rmw_fini_publisher_allocation');
  late final _rmw_fini_publisher_allocation = _rmw_fini_publisher_allocationPtr
      .asFunction<int Function(ffi.Pointer<rmw_publisher_allocation_t>)>();

  /// Create a publisher and return a handle to that publisher.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is not a valid non-null handle for this rmw implementation,
  ///  *     as returned by `rmw_create_node()`
  ///  *   - type_support is a not valid non-null message type support, as returned by
  ///  *     `ROSIDL_GET_MSG_TYPE_SUPPORT()`
  ///  *   - topic_name is not a valid non-null topic name, according to
  ///  *     `rmw_validate_full_topic_name()`
  ///  *   - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies
  ///  *   - publisher_options is not a valid non-null option set, as returned by
  ///  *     `rmw_get_default_publisher_options()`
  ///  *   - memory allocation fails during publisher creation
  ///  *   - an unspecified error occurs
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] node Handle to node with which to register this publisher
  ///  * \param[in] type_support Type support for the messages to be published
  ///  * \param[in] topic_name Name of the topic to publish to, often a fully qualified
  ///  *   topic name unless `qos_profile` is configured to avoid ROS namespace conventions
  ///  *   i.e. to create a native topic publisher
  ///  * \param[in] qos_profile QoS policies for this publisher
  ///  * \param[in] publisher_options Options to configure this publisher
  ///  * \return rmw publisher handle, or `NULL` if there was an error
  ///  */
  ffi.Pointer<rmw_publisher_t> rmw_create_publisher(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Char> topic_name,
    ffi.Pointer<rmw_qos_profile_t> qos_profile,
    ffi.Pointer<rmw_publisher_options_t> publisher_options,
  ) {
    return _rmw_create_publisher(
      node,
      type_support,
      topic_name,
      qos_profile,
      publisher_options,
    );
  }

  late final _rmw_create_publisherPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_publisher_t> Function(
              ffi.Pointer<rmw_node_t>,
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<rmw_qos_profile_t>,
              ffi.Pointer<rmw_publisher_options_t>)>>('rmw_create_publisher');
  late final _rmw_create_publisher = _rmw_create_publisherPtr.asFunction<
      ffi.Pointer<rmw_publisher_t> Function(
          ffi.Pointer<rmw_node_t>,
          ffi.Pointer<rosidl_message_type_support_t>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<rmw_qos_profile_t>,
          ffi.Pointer<rmw_publisher_options_t>)>();

  /// Finalize a given publisher handle, reclaim the resources, and deallocate the publisher handle.
  /// /**
  ///  * This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  ///  * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given publisher handle unchanged.
  ///  * Otherwise, it will proceed despite errors, freeing as many resources as it can, including
  ///  * the publisher handle. Usage of a deallocated publisher handle is undefined behavior.
  ///  *
  ///  * \pre Given node must be the one the publisher was registered with.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] node Handle to node with which the given publisher is registered
  ///  * \param[in] publisher Handle to publisher to be finalized
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if node or publisher is `NULL`, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or publisher
  ///  *   implementation identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_destroy_publisher(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_publisher_t> publisher,
  ) {
    return _rmw_destroy_publisher(
      node,
      publisher,
    );
  }

  late final _rmw_destroy_publisherPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_node_t>,
              ffi.Pointer<rmw_publisher_t>)>>('rmw_destroy_publisher');
  late final _rmw_destroy_publisher = _rmw_destroy_publisherPtr.asFunction<
      int Function(ffi.Pointer<rmw_node_t>, ffi.Pointer<rmw_publisher_t>)>();

  /// Borrow a loaned ROS message.
  /// /**
  ///  * This ROS message is owned by the middleware, that will keep it alive (i.e. in valid
  ///  * memory space) until the caller publishes it using rmw_publish_loaned_message() or
  ///  * returns it using rmw_return_loaned_message_from_publisher().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To borrow a ROS message is a synchronous operation.
  ///  *   It is also non-blocking, but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on borrow or not.
  ///  *   Check the implementation documentation to learn about memory allocation
  ///  *   guarantees when using ROS message loaning support.
  ///  *
  ///  * \par Thread-safety
  ///  *   Publishers are thread-safe objects, and so are all operations on them except for finalization.
  ///  *   Therefore, it is safe to borrow ROS messages from the same publisher concurrently.
  ///  *
  ///  * \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  ///  * \pre Given `type_support` must be a valid `rosidl` message type support, matching the
  ///  *   one registered with the `publisher` on creation.
  ///  *
  ///  * \param[in] publisher Publisher to which the loaned ROS message will be associated.
  ///  * \param[in] type_support Message type support of the loaned ROS message.
  ///  * \param[out] ros_message Pointer to type erased ROS message loaned by the middleware.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `type_support` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `*ros_message` is not NULL (to prevent leaks), or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation identifier
  ///  *   does not match this implementation, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occured.
  ///  */
  int rmw_borrow_loaned_message(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
  ) {
    return _rmw_borrow_loaned_message(
      publisher,
      type_support,
      ros_message,
    );
  }

  late final _rmw_borrow_loaned_messagePtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_publisher_t>,
                  ffi.Pointer<rosidl_message_type_support_t>,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'rmw_borrow_loaned_message');
  late final _rmw_borrow_loaned_message =
      _rmw_borrow_loaned_messagePtr.asFunction<
          int Function(
              ffi.Pointer<rmw_publisher_t>,
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Return a loaned message previously borrowed from a publisher.
  /// /**
  ///  * Tells the middleware that a borrowed ROS message is no longer needed by the caller.
  ///  * Ownership of the ROS message is given back to the middleware.
  ///  * If this function fails early due to a logical error, such as an invalid argument,
  ///  * the loaned ROS message will be left unchanged.
  ///  * Otherwise, ownership of the ROS message will be given back to the middleware.
  ///  * It is up to the middleware what will be made of the returned ROS message.
  ///  * It is undefined behavior to use a loaned ROS message after returning it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To return a ROS message is a synchronous operation.
  ///  *   It is also non-blocking, but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Thread-safety
  ///  *   Publishers are thread-safe objects, and so are all operations on them except for finalization.
  ///  *   Therefore, it is safe to return borrowed ROS messages to the same publisher concurrently.
  ///  *   However, since ownership of the loaned ROS message is given back to the middleware and
  ///  *   this transfer is not synchronized, it is not safe to return the same loaned ROS message
  ///  *   concurrently.
  ///  *
  ///  * \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  ///  * \pre Given `loaned_message` must have been previously borrowed from the same publisher
  ///  *   using rmw_borrow_loaned_message().
  ///  *
  ///  * \param[in] publisher Publisher to which the loaned ROS message is associated.
  ///  * \param[in] loaned_message Type erased loaned ROS message to be returned.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation identifier
  ///  *   does not match this implementation, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs and no message can be initialized.
  ///  */
  int rmw_return_loaned_message_from_publisher(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return _rmw_return_loaned_message_from_publisher(
      publisher,
      loaned_message,
    );
  }

  late final _rmw_return_loaned_message_from_publisherPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_publisher_t>, ffi.Pointer<ffi.Void>)>>(
      'rmw_return_loaned_message_from_publisher');
  late final _rmw_return_loaned_message_from_publisher =
      _rmw_return_loaned_message_from_publisherPtr.asFunction<
          int Function(ffi.Pointer<rmw_publisher_t>, ffi.Pointer<ffi.Void>)>();

  /// Publish a ROS message.
  /// /**
  ///  * Send a ROS message to all subscriptions with matching QoS policies using the given publisher.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   It is implementation defined whether to publish a ROS message is a
  ///  *   synchronous or asynchronous, blocking or non-blocking operation.
  ///  *   However, asynchronous implementations are not allowed to access the
  ///  *   given ROS message after this function returns.
  ///  *   Check the implementation documentation to learn about publish behavior.
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on publish or not.
  ///  *   For instance, implementations that serialize ROS messages to send it over the
  ///  *   wire may need to perform additional memory allocations when dealing with
  ///  *   unbounded (dynamically-sized) fields.
  ///  *   A publisher allocation, if provided, may or may not be used.
  ///  *   Check the implementation documentation to learn about memory allocation
  ///  *   guarantees when publishing ROS messages with and without publisher allocations.
  ///  *
  ///  * \par Thread-safety
  ///  *   Publishers are thread-safe objects, and so are all operations on them except for finalization.
  ///  *   Therefore, it is safe to publish using the same publisher concurrently.
  ///  *   However, when publishing regular ROS messages:
  ///  *   - Access to the ROS message is read-only but it is not synchronized.
  ///  *     Concurrent `ros_message` reads are safe, but concurrent reads and writes are not.
  ///  *   - Access to the publisher allocation is not synchronized, unless specifically stated
  ///  *     otherwise by the implementation.
  ///  *     Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.
  ///  *     Check the implementation documentation to learn about publisher allocations' thread-safety.
  ///  *
  ///  * \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  ///  * \pre Given `ros_message` must be a valid message, whose type matches the message type
  ///  *   support the `publisher` was registered with on creation.
  ///  * \pre If not NULL, given `allocation` must be a valid publisher allocation, initialized
  ///  *   with rmw_publisher_allocation_init() with a message type support that matches the
  ///  *   one registered with `publisher` on creation.
  ///  *
  ///  * \param[in] publisher Publisher to be used to send message.
  ///  * \param[in] ros_message Type erased ROS message to be sent.
  ///  * \param[in] allocation Pre-allocated memory to be used. May be NULL.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_publish(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rmw_publish(
      publisher,
      ros_message,
      allocation,
    );
  }

  late final _rmw_publishPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<rmw_publisher_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<rmw_publisher_allocation_t>)>>('rmw_publish');
  late final _rmw_publish = _rmw_publishPtr.asFunction<
      int Function(ffi.Pointer<rmw_publisher_t>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<rmw_publisher_allocation_t>)>();

  /// Publish a loaned ROS message.
  /// /**
  ///  * Send a previously borrowed ROS message to all subscriptions with matching QoS policies
  ///  * using the given publisher, then return ROS message ownership to the middleware.
  ///  *
  ///  * If this function fails early due to a logical error, such as an invalid argument,
  ///  * the loaned ROS message will be left unchanged.
  ///  * Otherwise, ownership of the ROS message will be given back to the middleware.
  ///  * It is up to the middleware what will be made of the returned ROS message.
  ///  * It is undefined behavior to use a loaned ROS message after publishing it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check the implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   It is implementation defined whether to publish a loaned ROS message is a
  ///  *   synchronous or asynchronous, blocking or non-blocking operation.
  ///  *   Check the implementation documentation to learn about publish behavior.
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on publish or not.
  ///  *   For instance, implementations that serialize ROS messages to send it over the
  ///  *   wire may need to perform additional memory allocations when dealing with
  ///  *   unbounded (dynamically-sized) fields.
  ///  *   A publisher allocation, if provided, may or may not be used.
  ///  *   Check the implementation documentation to learn about memory allocation
  ///  *   guarantees when publishing loaned ROS messages with and without publisher allocations.
  ///  *
  ///  * \par Thread-safety
  ///  *   Publishers are thread-safe objects, and so are all operations on them except for finalization.
  ///  *   Therefore, it is safe to publish using the same publisher concurrently.
  ///  *   However, when publishing loaned ROS messages:
  ///  *   - Ownership of the loaned ROS message is given back to the middleware.
  ///  *     This transfer is not synchronized, and thus it is not safe to publish the
  ///  *     same loaned ROS message concurrently.
  ///  *   - Access to the publisher allocation is not synchronized, unless specifically stated
  ///  *     otherwise by the implementation.
  ///  *     Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.
  ///  *     Check the implementation documentation to learn about publisher allocations' thread-safety.
  ///  *
  ///  * \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  ///  * \pre Given `ros_message` must be a valid message, borrowed from the same publisher using
  ///  *   rmw_borrow_loaned_message().
  ///  * \pre If not NULL, given `allocation` must be a valid publisher allocation, initialized
  ///  *   with rmw_publisher_allocation_init() with a message type support that matches the
  ///  *   one registered with `publisher` on creation.
  ///  *
  ///  * \param[in] publisher Publisher to be used to send message.
  ///  * \param[in] ros_message Loaned type erased ROS message to be sent.
  ///  * \param[in] allocation Pre-allocated memory to be used. May be NULL.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_publish_loaned_message(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rmw_publish_loaned_message(
      publisher,
      ros_message,
      allocation,
    );
  }

  late final _rmw_publish_loaned_messagePtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_publisher_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<rmw_publisher_allocation_t>)>>(
      'rmw_publish_loaned_message');
  late final _rmw_publish_loaned_message =
      _rmw_publish_loaned_messagePtr.asFunction<
          int Function(ffi.Pointer<rmw_publisher_t>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<rmw_publisher_allocation_t>)>();

  /// Retrieve the number of matched subscriptions to a publisher.
  /// /**
  ///  * Query the underlying middleware to determine how many subscriptions are
  ///  * matched to a given publisher.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] publisher the publisher object to inspect
  ///  * \param[out] subscription_count the number of subscriptions matched
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if publisher
  ///  *   implementation identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_publisher_count_matched_subscriptions(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Size> subscription_count,
  ) {
    return _rmw_publisher_count_matched_subscriptions(
      publisher,
      subscription_count,
    );
  }

  late final _rmw_publisher_count_matched_subscriptionsPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_publisher_t>, ffi.Pointer<ffi.Size>)>>(
      'rmw_publisher_count_matched_subscriptions');
  late final _rmw_publisher_count_matched_subscriptions =
      _rmw_publisher_count_matched_subscriptionsPtr.asFunction<
          int Function(ffi.Pointer<rmw_publisher_t>, ffi.Pointer<ffi.Size>)>();

  /// Retrieve the actual qos settings of the publisher.
  /// /**
  ///  * Query the underlying middleware to determine the qos settings
  ///  * of the publisher.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the publisher, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  *
  ///  * \note The value of avoid_ros_namespace_conventions field is not resolved
  ///  *   with this function. The rcl function `rcl_publisher_get_actual_qos()`
  ///  *   resolves it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] publisher the publisher object to inspect
  ///  * \param[out] qos the actual qos settings
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if publisher
  ///  *   implementation identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_publisher_get_actual_qos(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rmw_qos_profile_t> qos,
  ) {
    return _rmw_publisher_get_actual_qos(
      publisher,
      qos,
    );
  }

  late final _rmw_publisher_get_actual_qosPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_publisher_t>,
              ffi.Pointer<rmw_qos_profile_t>)>>('rmw_publisher_get_actual_qos');
  late final _rmw_publisher_get_actual_qos =
      _rmw_publisher_get_actual_qosPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_publisher_t>, ffi.Pointer<rmw_qos_profile_t>)>();

  /// Publish a ROS message as a byte stream.
  /// /**
  ///  * Send a ROS message serialized as a byte stream to all subscriptions with
  ///  * matching QoS policies using the given publisher.
  ///  * A ROS message can be serialized manually using rmw_serialize().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check the implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   It is implementation defined whether to publish a loaned ROS message is a
  ///  *   synchronous or asynchronous, blocking or non-blocking operation.
  ///  *   However, asynchronous implementations are not allowed to access the
  ///  *   given byte stream after this function returns.
  ///  *   Check the implementation documentation to learn about publish behavior.
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on publish or not.
  ///  *   Even if a publisher allocation is provided, an implementation may ignore it.
  ///  *   Check the implementation documentation to learn about memory allocation
  ///  *   guarantees when publishing serialized messages with and without publisher allocations.
  ///  *
  ///  * \par Thread-safety
  ///  *   Publishers are thread-safe objects, and so are all operations on them except for finalization.
  ///  *   Therefore, it is safe to publish using the same publisher concurrently.
  ///  *   However, when publishing serialized ROS messages:
  ///  *   - Access to the byte stream is read-only but it is not synchronized.
  ///  *     Concurrent `serialized_message` reads are safe, but concurrent reads and writes are not.
  ///  *   - Access to the publisher allocation is not synchronized, unless specifically stated
  ///  *     otherwise by the implementation.
  ///  *     Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.
  ///  *     Check the implementation documentation to learn about publisher allocations' thread-safety.
  ///  *
  ///  * \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  ///  * \pre Given `serialized_message` must be a valid serialized message, initialized by
  ///  *   rmw_serialized_message_init() and containing the serialization of a ROS message whose
  ///  *   type matches the message type support the `publisher` was registered with on creation.
  ///  * \pre If not NULL, given `allocation` must be a valid publisher allocation, initialized
  ///  *   with rmw_publisher_allocation_init() with a message type support that matches the
  ///  *   one registered with `publisher` on creation.
  ///  *
  ///  * \param[in] publisher Publisher to be used to send message.
  ///  * \param[in] serialized_message Serialized ROS message to be sent.
  ///  * \param[in] allocation Pre-allocated memory to be used. May be NULL.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_publish_serialized_message(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rmw_serialized_message_t> serialized_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rmw_publish_serialized_message(
      publisher,
      serialized_message,
      allocation,
    );
  }

  late final _rmw_publish_serialized_messagePtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_publisher_t>,
                  ffi.Pointer<rmw_serialized_message_t>,
                  ffi.Pointer<rmw_publisher_allocation_t>)>>(
      'rmw_publish_serialized_message');
  late final _rmw_publish_serialized_message =
      _rmw_publish_serialized_messagePtr.asFunction<
          int Function(
              ffi.Pointer<rmw_publisher_t>,
              ffi.Pointer<rmw_serialized_message_t>,
              ffi.Pointer<rmw_publisher_allocation_t>)>();

  /// Compute the size of a serialized message.
  /// /**
  ///  * Given a message definition and bounds, compute the serialized size.
  ///  *
  ///  * \param[in] type_support The type support of the message to compute.
  ///  * \param[in] message_bounds Artifical bounds to use on unbounded fields.
  ///  * \param[out] size The computed size of the serialized message.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_UNSUPPORTED` if it's unimplemented, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_get_serialized_message_size(
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _rmw_get_serialized_message_size(
      type_support,
      message_bounds,
      size,
    );
  }

  late final _rmw_get_serialized_message_sizePtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<rosidl_runtime_c__Sequence__bound>,
              ffi.Pointer<ffi.Size>)>>('rmw_get_serialized_message_size');
  late final _rmw_get_serialized_message_size =
      _rmw_get_serialized_message_sizePtr.asFunction<
          int Function(
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<rosidl_runtime_c__Sequence__bound>,
              ffi.Pointer<ffi.Size>)>();

  /// Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)
  /// /**
  ///  * If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of
  ///  * this publisher may manually call `assert_liveliness` at some point in time to signal to the rest
  ///  * of the system that this Node is still alive.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher handle to the publisher that needs liveliness to be asserted
  ///  * \return `RMW_RET_OK` if the liveliness assertion was completed successfully, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the rmw implementation does not support asserting liveliness.
  ///  */
  int rmw_publisher_assert_liveliness(
    ffi.Pointer<rmw_publisher_t> publisher,
  ) {
    return _rmw_publisher_assert_liveliness(
      publisher,
    );
  }

  late final _rmw_publisher_assert_livelinessPtr = _lookup<
          ffi.NativeFunction<rmw_ret_t Function(ffi.Pointer<rmw_publisher_t>)>>(
      'rmw_publisher_assert_liveliness');
  late final _rmw_publisher_assert_liveliness =
      _rmw_publisher_assert_livelinessPtr
          .asFunction<int Function(ffi.Pointer<rmw_publisher_t>)>();

  /// Wait until all published message data is acknowledged or until the specified timeout elapses.
  /// /**
  ///  * This function waits until all published message data were acknowledged by peer node or timeout.
  ///  *
  ///  * This function only works effectively while QOS profile of publisher is set to RELIABLE.
  ///  * Otherwise this function will immediately return RMW_RET_OK.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   Waiting for all acknowledgments is synchronous operation.
  ///  *   So the calling thread is blocked until all published message data is acknowledged or specified
  ///  *   duration elapses.
  ///  *
  ///  * \par Thread-Safety
  ///  *   Publishers are thread-safe objects, and so are all operations on them except for finalization.
  ///  *   Therefore, it is safe to call this function using the same publisher concurrently.
  ///  *
  ///  * \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  ///  *
  ///  * \param[in] publisher handle to the publisher that needs to wait for all acked.
  ///  * \param[in] wait_timeout represents the maximum amount of time to wait for all published message
  ///  *   data were acknowledged.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_TIMEOUT` if wait timed out, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is `NULL`, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `publisher` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the rmw implementation is unimplemented.
  ///  */
  int rmw_publisher_wait_for_all_acked(
    ffi.Pointer<rmw_publisher_t> publisher,
    rmw_time_t wait_timeout,
  ) {
    return _rmw_publisher_wait_for_all_acked(
      publisher,
      wait_timeout,
    );
  }

  late final _rmw_publisher_wait_for_all_ackedPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_publisher_t>,
              rmw_time_t)>>('rmw_publisher_wait_for_all_acked');
  late final _rmw_publisher_wait_for_all_acked =
      _rmw_publisher_wait_for_all_ackedPtr
          .asFunction<int Function(ffi.Pointer<rmw_publisher_t>, rmw_time_t)>();

  /// Serialize a ROS message into a rmw_serialized_message_t.
  /// /**
  ///  * The ROS message is serialized into a byte stream contained within the
  ///  * rmw_serialized_message_t structure.
  ///  * The serialization format depends on the underlying implementation.
  ///  *
  ///  * \pre Given ROS message must be a valid non-null instance, initialized
  ///  *   by the caller and matching the provided typesupport.
  ///  * \pre Given typesupport must be a valid non-null instance, as provided
  ///  *   by `rosidl` APIs.
  ///  * \pre Given serialized message must be a valid non-null instance, initialized
  ///  *   by the caller.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [2]
  ///  * Lock-Free          | Maybe [2]
  ///  * <i>[1] if the given serialized message does not have enough capacity to hold
  ///  *        the ROS message serialization</i>
  ///  * <i>[2] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] ros_message the typed ROS message
  ///  * \param[in] type_support the typesupport for the ROS message
  ///  * \param[out] serialized_message the destination for the serialize ROS message
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_serialize(
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rmw_serialized_message_t> serialized_message,
  ) {
    return _rmw_serialize(
      ros_message,
      type_support,
      serialized_message,
    );
  }

  late final _rmw_serializePtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<rmw_serialized_message_t>)>>('rmw_serialize');
  late final _rmw_serialize = _rmw_serializePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<rosidl_message_type_support_t>,
          ffi.Pointer<rmw_serialized_message_t>)>();

  /// Deserialize a ROS message.
  /// /**
  ///  * The given rmw_serialized_message_t's internal byte stream buffer is deserialized
  ///  * into the given ROS message.
  ///  * The serialization format expected in the rmw_serialized_message_t depends on the
  ///  * underlying implementation.
  ///  *
  ///  * \pre Given serialized message must be a valid non-null instance, such
  ///  *   as that returned by `rmw_serialize()`, matching provided typesupport
  ///  *   and ROS message.
  ///  * \pre Given typesupport must be a valid non-null instance, as provided
  ///  *   by `rosidl` APIs.
  ///  * \pre Given ROS message must be a valid non-null instance, initialized
  ///  *   by the caller.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [2]
  ///  * Lock-Free          | Maybe [2]
  ///  * <i>[1] if the given ROS message contains unbounded fields</i>
  ///  * <i>[2] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] serialized_message the serialized message holding the byte stream
  ///  * \param[in] type_support the typesupport for the typed ros message
  ///  * \param[out] ros_message destination for the deserialized ROS message
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_deserialize(
    ffi.Pointer<rmw_serialized_message_t> serialized_message,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Void> ros_message,
  ) {
    return _rmw_deserialize(
      serialized_message,
      type_support,
      ros_message,
    );
  }

  late final _rmw_deserializePtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<rmw_serialized_message_t>,
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<ffi.Void>)>>('rmw_deserialize');
  late final _rmw_deserialize = _rmw_deserializePtr.asFunction<
      int Function(ffi.Pointer<rmw_serialized_message_t>,
          ffi.Pointer<rosidl_message_type_support_t>, ffi.Pointer<ffi.Void>)>();

  /// Initialize a subscription allocation to be used with later `take`s.
  /// /**
  ///  * This creates an allocation object that can be used in conjunction with
  ///  * the rmw_take method to perform more carefully control memory allocations.
  ///  *
  ///  * This will allow the middleware to preallocate the correct amount of memory
  ///  * for a given message type and message bounds.
  ///  * As allocation is performed in this method, it will not be necessary to allocate
  ///  * in the `rmw_take` method.
  ///  *
  ///  * \param[in] type_support Type support of the message to be preallocated.
  ///  * \param[in] message_bounds Bounds structure of the message to be preallocated.
  ///  * \param[out] allocation Allocation structure to be passed to `rmw_take`.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_UNSUPPORTED` if it's unimplemented
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_init_subscription_allocation(
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_init_subscription_allocation(
      type_support,
      message_bounds,
      allocation,
    );
  }

  late final _rmw_init_subscription_allocationPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rosidl_message_type_support_t>,
                  ffi.Pointer<rosidl_runtime_c__Sequence__bound>,
                  ffi.Pointer<rmw_subscription_allocation_t>)>>(
      'rmw_init_subscription_allocation');
  late final _rmw_init_subscription_allocation =
      _rmw_init_subscription_allocationPtr.asFunction<
          int Function(
              ffi.Pointer<rosidl_message_type_support_t>,
              ffi.Pointer<rosidl_runtime_c__Sequence__bound>,
              ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Destroy a publisher allocation object.
  /// /**
  ///  * This deallocates memory allocated by `rmw_init_subscription_allocation`.
  ///  *
  ///  * \param[in] allocation Allocation object to be destroyed.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_UNSUPPORTED` if it's unimplemented
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_fini_subscription_allocation(
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_fini_subscription_allocation(
      allocation,
    );
  }

  late final _rmw_fini_subscription_allocationPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_subscription_allocation_t>)>>(
      'rmw_fini_subscription_allocation');
  late final _rmw_fini_subscription_allocation =
      _rmw_fini_subscription_allocationPtr.asFunction<
          int Function(ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Create a subscription and return a handle to that subscription.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is not a valid non-null handle for this rmw implementation,
  ///  *     as returned by `rmw_create_node()`
  ///  *   - type_support is a not valid non-null message type support, as returned by
  ///  *     `ROSIDL_GET_MSG_TYPE_SUPPORT()`
  ///  *   - topic_name is not a valid non-null topic name, according to
  ///  *     `rmw_validate_full_topic_name()` if ROS namespace conventions apply
  ///  *   - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies
  ///  *   - subscription_options is not a valid non-null option set, such as the one
  ///  *     returned by `rmw_get_default_subscription_options()`
  ///  *   - memory allocation fails during subscription creation
  ///  *   - an unspecified error occurs
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] node Handle to node with which to register this subscription
  ///  * \param[in] type_support Type support for the messages to be subscribed to
  ///  * \param[in] topic_name Name of the topic to subscribe to, often a fully qualified
  ///  *   topic name unless `qos_profile` is configured to avoid ROS namespace conventions
  ///  *   i.e. to create a native topic subscription
  ///  * \param[in] qos_policies QoS policies for this subscription
  ///  * \param[in] subscription_options Options for configuring this subscription
  ///  * \return rmw subscription handle, or `NULL` if there was an error
  ///  */
  ffi.Pointer<rmw_subscription_t> rmw_create_subscription(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Char> topic_name,
    ffi.Pointer<rmw_qos_profile_t> qos_policies,
    ffi.Pointer<rmw_subscription_options_t> subscription_options,
  ) {
    return _rmw_create_subscription(
      node,
      type_support,
      topic_name,
      qos_policies,
      subscription_options,
    );
  }

  late final _rmw_create_subscriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rmw_subscription_t> Function(
                  ffi.Pointer<rmw_node_t>,
                  ffi.Pointer<rosidl_message_type_support_t>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<rmw_qos_profile_t>,
                  ffi.Pointer<rmw_subscription_options_t>)>>(
      'rmw_create_subscription');
  late final _rmw_create_subscription = _rmw_create_subscriptionPtr.asFunction<
      ffi.Pointer<rmw_subscription_t> Function(
          ffi.Pointer<rmw_node_t>,
          ffi.Pointer<rosidl_message_type_support_t>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<rmw_qos_profile_t>,
          ffi.Pointer<rmw_subscription_options_t>)>();

  /// Finalize a given subscription handle, reclaim the resources, and deallocate the subscription
  /// handle.
  /// /**
  ///  * This function will return early if a logical error, namely `RMW_RET_INVALID_ARGUMENT`
  ///  * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given subscription handle
  ///  * unchanged.
  ///  * Otherwise, it will proceed despite errors, freeing as many resources as it can, including
  ///  * the subscription handle, and return `RMW_RET_ERROR`. Usage of a deallocated subscription
  ///  * handle is undefined behavior.
  ///  *
  ///  * \pre Given node must be the one the subscription was registered with.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] node Handle to node with which the given subscription is registered
  ///  * \param[in] subscription Handle to subscription to be finalized
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if node or subscription is `NULL`, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or subscription
  ///  *   implementation identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_destroy_subscription(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_subscription_t> subscription,
  ) {
    return _rmw_destroy_subscription(
      node,
      subscription,
    );
  }

  late final _rmw_destroy_subscriptionPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_node_t>,
              ffi.Pointer<rmw_subscription_t>)>>('rmw_destroy_subscription');
  late final _rmw_destroy_subscription =
      _rmw_destroy_subscriptionPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_node_t>, ffi.Pointer<rmw_subscription_t>)>();

  /// Retrieve the number of matched publishers to a subscription.
  /// /**
  ///  * Query the underlying middleware to determine how many publishers are
  ///  * matched to a given subscription.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] subscription the subscription object to inspect
  ///  * \param[out] publisher_count the number of publishers matched
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription
  ///  *   implementation identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_subscription_count_matched_publishers(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Size> publisher_count,
  ) {
    return _rmw_subscription_count_matched_publishers(
      subscription,
      publisher_count,
    );
  }

  late final _rmw_subscription_count_matched_publishersPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_subscription_t>, ffi.Pointer<ffi.Size>)>>(
      'rmw_subscription_count_matched_publishers');
  late final _rmw_subscription_count_matched_publishers =
      _rmw_subscription_count_matched_publishersPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_subscription_t>, ffi.Pointer<ffi.Size>)>();

  /// Retrieve the actual qos settings of the subscription.
  /// /**
  ///  * Query the underlying middleware to determine the qos settings
  ///  * of the subscription.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the subscription, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  *
  ///  * \note The value of avoid_ros_namespace_conventions field is not resolved
  ///  *   with this function. The rcl function `rcl_subscription_get_actual_qos()`
  ///  *   resolves it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] subscription the subscription object to inspect
  ///  * \param[out] qos the actual qos settings
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription
  ///  *   implementation identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_subscription_get_actual_qos(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<rmw_qos_profile_t> qos,
  ) {
    return _rmw_subscription_get_actual_qos(
      subscription,
      qos,
    );
  }

  late final _rmw_subscription_get_actual_qosPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_subscription_t>,
                  ffi.Pointer<rmw_qos_profile_t>)>>(
      'rmw_subscription_get_actual_qos');
  late final _rmw_subscription_get_actual_qos =
      _rmw_subscription_get_actual_qosPtr.asFunction<
          int Function(ffi.Pointer<rmw_subscription_t>,
              ffi.Pointer<rmw_qos_profile_t>)>();

  /// Set the content filter options for the subscription.
  /// /**
  ///  * This function will set a filter expression and an array of expression parameters
  ///  * for the given subscription.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] subscription The subscription to set content filter options.
  ///  * \param[in] options The content filter options.
  ///  *   Use `options.filter_expression` with an empty("") string to
  ///  *   reset/clean content filtered topic for the subscription.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the implementation does not support content filtered topic, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_subscription_set_content_filter(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<rmw_subscription_content_filter_options_t> options,
  ) {
    return _rmw_subscription_set_content_filter(
      subscription,
      options,
    );
  }

  late final _rmw_subscription_set_content_filterPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_subscription_t>,
                  ffi.Pointer<rmw_subscription_content_filter_options_t>)>>(
      'rmw_subscription_set_content_filter');
  late final _rmw_subscription_set_content_filter =
      _rmw_subscription_set_content_filterPtr.asFunction<
          int Function(ffi.Pointer<rmw_subscription_t>,
              ffi.Pointer<rmw_subscription_content_filter_options_t>)>();

  /// Retrieve the content filter options of the subscription.
  /// /**
  ///  * This function will return a content filter options by the given subscription.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] subscription The subscription object to inspect.
  ///  * \param[in] allocator Allocator to be used when populating the content filter options.
  ///  * \param[out] options The content filter options.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the implementation does not support content filtered topic, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_subscription_get_content_filter(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<rcutils_allocator_t> allocator,
    ffi.Pointer<rmw_subscription_content_filter_options_t> options,
  ) {
    return _rmw_subscription_get_content_filter(
      subscription,
      allocator,
      options,
    );
  }

  late final _rmw_subscription_get_content_filterPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_subscription_t>,
                  ffi.Pointer<rcutils_allocator_t>,
                  ffi.Pointer<rmw_subscription_content_filter_options_t>)>>(
      'rmw_subscription_get_content_filter');
  late final _rmw_subscription_get_content_filter =
      _rmw_subscription_get_content_filterPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_subscription_t>,
              ffi.Pointer<rcutils_allocator_t>,
              ffi.Pointer<rmw_subscription_content_filter_options_t>)>();

  /// Take an incoming ROS message.
  /// /**
  ///  * Take a ROS message already received by the given subscription, removing it from internal queues.
  ///  * This function will succeed even if no ROS message was received, but `taken` will be false.
  ///  *
  ///  * \remarks The same ROS message cannot be taken twice.
  ///  *   Callers do not have to deal with duplicates.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To take a ROS message is a synchronous operation.
  ///  *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
  ///  *   but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on take or not.
  ///  *   For instance, implementations that deserialize ROS messages received over
  ///  *   the wire may need to perform additional memory allocations when dealing with
  ///  *   unbounded (dynamically-sized) fields.
  ///  *   A subscription allocation, if provided, may or may not be used.
  ///  *   Check the implementation documentation to learn about memory allocation
  ///  *   guarantees when taking ROS messages with and without subscription allocations.
  ///  *
  ///  * \par Thread-safety
  ///  *   Subscriptions are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to take from the same subscription concurrently.
  ///  *   However, when taking regular ROS messages:
  ///  *   - Access to the given ROS message is not synchronized.
  ///  *     It is not safe to read or write `ros_message` while rmw_take() uses it.
  ///  *   - Access to given primitive data-type arguments is not synchronized.
  ///  *     It is not safe to read or write `taken` while rmw_take() uses it.
  ///  *   - Access to the given subscription allocation is not synchronized,
  ///  *     unless specifically stated otherwise by the implementation.
  ///  *     Thus, it is generally not safe to read or write `allocation` while rmw_take() uses it.
  ///  *     Check the implementation documentation to learn about subscription allocations'
  ///  *     thread-safety.
  ///  *
  ///  * \pre Given `subscription` must be a valid subscription, as returned
  ///  *   by rmw_create_subscription().
  ///  * \pre Given `ros_message` must be a valid message, whose type matches the message type support
  ///  *   registered with the `subscription` on creation.
  ///  * \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  ///  *   with rmw_subscription_allocation_init() with a message type support that matches the
  ///  *   one registered with the `subscription` on creation.
  ///  * \post Given `ros_message` will remain a valid message.
  ///  *   It will be left unchanged if this function fails early due to a logical error, such as an
  ///  *   invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
  ///  *   It will also be left unchanged if this function succeeds but `taken` is false.
  ///  *
  ///  * \param[in] subscription Subscription to take message from.
  ///  * \param[out] ros_message Type erased ROS message to write to.
  ///  * \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  ///  * \param[in] allocation Pre-allocated memory to be used. May be NULL.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`
  ///  *   implementation identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<ffi.Bool> taken,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take(
      subscription,
      ros_message,
      taken,
      allocation,
    );
  }

  late final _rmw_takePtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<rmw_subscription_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Bool>,
              ffi.Pointer<rmw_subscription_allocation_t>)>>('rmw_take');
  late final _rmw_take = _rmw_takePtr.asFunction<
      int Function(ffi.Pointer<rmw_subscription_t>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Bool>, ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Take an incoming ROS message with its metadata.
  /// /**
  ///  * Same as rmw_take(), except it also takes ROS message metadata.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To take a ROS message with its metadata is a synchronous operation.
  ///  *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
  ///  *   but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on take or not.
  ///  *   For instance, implementations that deserialize ROS messages received over
  ///  *   the wire may need to perform additional memory allocations when dealing with
  ///  *   unbounded (dynamically-sized) fields.
  ///  *   A subscription allocation, if provided, may or may not be used.
  ///  *   Check the implementation documentation to learn about memory allocation
  ///  *   guarantees when taking ROS messages with and without subscription allocations.
  ///  *
  ///  * \par Thread-safety
  ///  *   Subscriptions are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to take from the same subscription concurrently.
  ///  *   However, when taking regular ROS messages with metadata:
  ///  *   - Access to the given ROS message is not synchronized.
  ///  *     It is not safe to read or write `ros_message` while rmw_take_with_info() uses it.
  ///  *   - Access to given primitive data-type arguments is not synchronized.
  ///  *     It is not safe to read or write `taken` while rmw_take_with_info() uses it.
  ///  *   - Access to the given ROS message metadata is not synchronized.
  ///  *     It is not safe to read or write `message_info` while rmw_take_with_info() uses it.
  ///  *   - Access to the given subscription allocation is not synchronized,
  ///  *     unless specifically stated otherwise by the implementation.
  ///  *     Thus, it is generally not safe to read or write `allocation` while rmw_take_with_info()
  ///  *     uses it.
  ///  *     Check the implementation documentation to learn about subscription allocations'
  ///  *     thread-safety.
  ///  *
  ///  * \pre Given `subscription` must be a valid subscription, as returned
  ///  *   by rmw_create_subscription().
  ///  * \pre Given `ros_message` must be a valid message, whose type matches
  ///  *   the message type support registered with the `subscription` on creation.
  ///  * \pre If not NULL, given `allocation` must be a valid subscription allocation
  ///  *   initialized with rmw_subscription_allocation_init() with a message type support
  ///  *   that matches the one registered with the `subscription` on creation.
  ///  * \post Given `ros_message` will remain a valid message, and
  ///  *   `message_info`, valid message metadata.
  ///  *   Both will be left unchanged if this function fails early due to a logical error, such as
  ///  *   an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
  ///  *   Both will also be left unchanged if this function succeeds but `taken` is false.
  ///  *
  ///  * \param[in] subscription Subscription to take ROS message from.
  ///  * \param[out] ros_message Type erased ROS message to write to.
  ///  * \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  ///  * \param[out] message_info Taken ROS message metadata.
  ///  * \param[in] allocation Pre-allocated memory to be used. May be NULL.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`
  ///  *   implementation identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_with_info(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<ffi.Bool> taken,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take_with_info(
      subscription,
      ros_message,
      taken,
      message_info,
      allocation,
    );
  }

  late final _rmw_take_with_infoPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_subscription_t>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Bool>,
                  ffi.Pointer<rmw_message_info_t>,
                  ffi.Pointer<rmw_subscription_allocation_t>)>>(
      'rmw_take_with_info');
  late final _rmw_take_with_info = _rmw_take_with_infoPtr.asFunction<
      int Function(
          ffi.Pointer<rmw_subscription_t>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Bool>,
          ffi.Pointer<rmw_message_info_t>,
          ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Take multiple incoming ROS messages with their metadata.
  /// /**
  ///  * Take a sequence of consecutive ROS messages already received by the given
  ///  * subscription, removing them from internal queues.
  ///  * While `count` ROS messages may be requested, fewer messages may have been
  ///  * received by the subscription.
  ///  * This function will only take what has been already received, and it will
  ///  * succeed even if fewer (or zero) messages were received.
  ///  * In this case, only currently available messages will be returned.
  ///  * The `taken` output variable indicates the number of ROS messages actually taken.
  ///  *
  ///  * \remarks Once taken, ROS messages in the sequence cannot be taken again.
  ///  *   Callers do not have to deal with duplicates.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To take a sequence of ROS messages is a synchronous operation.
  ///  *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
  ///  *   but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on take or not.
  ///  *   For instance, implementations that deserialize ROS messages received over
  ///  *   the wire may need to perform additional memory allocations when dealing with
  ///  *   unbounded (dynamically-sized) fields.
  ///  *   A subscription allocation, if provided, may or may not be used.
  ///  *   Check the implementation documentation to learn about memory allocation
  ///  *   guarantees when taking ROS messages with and without subscription allocations.
  ///  *
  ///  * \par Thread-safety
  ///  *   Subscriptions are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to take from the same subscription concurrently.
  ///  *   Moreover, the sequence of ROS messages taken is guaranteed to be consecutive and to
  ///  *   preserve the order in the subscription queues, despite any concurrent takes.
  ///  *   However, when taking a sequence of ROS messages with metadata:
  ///  *   - Access to the given ROS message sequence is not synchronized.
  ///  *     It is not safe to read or write `message_sequence` while rmw_take_sequence() uses it.
  ///  *   - Access to the given ROS message metadata sequence is not synchronized.
  ///  *     It is not safe to read or write `message_info_sequence` while rmw_take_sequence() uses it.
  ///  *   - Access to given primitive data-type arguments is not synchronized.
  ///  *     It is not safe to read or write `taken` while rmw_take_sequence() uses it.
  ///  *   - Access to the given subscription allocation is not synchronized,
  ///  *     unless specifically stated otherwise by the implementation.
  ///  *     Thus, it is generally not safe to read or write `allocation` while rmw_take_sequence()
  ///  *     uses it.
  ///  *     Check the implementation documentation to learn about subscription allocations'
  ///  *     thread-safety.
  ///  *
  ///  * \pre Given `subscription` must be a valid subscription, as returned
  ///  *   by rmw_create_subscription().
  ///  * \pre Given `message_sequence` must be a valid message sequence, initialized
  ///  *   by rmw_message_sequence_init() and populated with ROS messages whose
  ///  *   type matches the message type support registered with the `subscription`
  ///  *   on creation.
  ///  * \pre Given `message_info_sequence` must be a valid message metadata sequence,
  ///  *   initialized by rmw_message_info_sequence_init().
  ///  * \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  ///  *   with rmw_subscription_allocation_init() with a message type support that matches the
  ///  *   one registered with `subscription` on creation.
  ///  * \post Given `message_sequence` will remain a valid message sequence, and
  ///  *   `message_info_sequence`, a valid message metadata sequence.
  ///  *   Both will be left unchanged if this function fails early due to a logical error, such as
  ///  *   an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
  ///  *   Both will also be left unchanged if this function succeeds but `taken` is zero.
  ///  *
  ///  * \param[in] subscription Subscription to take ROS message from.
  ///  * \param[in] count Number of messages to attempt to take.
  ///  * \param[out] message_sequence Sequence of type erase ROS messages to write to.
  ///  *   Message sequence capacity has to be enough to hold all requested messages
  ///  *   i.e. capacity has to be equal or greater than `count`.
  ///  *   It does not have to match that of `message_info_sequence`.
  ///  * \param[out] message_info_sequence Sequence of additional message metadata.
  ///  *   Message info sequence capacity has to be enough to hold all requested messages
  ///  *   metadata i.e. capacity has to be equal or greater than `count`.
  ///  *   It does not have to match that of `message_sequence`.
  ///  * \param[out] taken Number of messages actually taken from subscription.
  ///  * \param[in] allocation Pre-allocated memory to use. May be NULL.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `message_sequence` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `count` is 0, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `message_sequence` capacity is less than `count`, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` capacity is less than `count`, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_sequence(
    ffi.Pointer<rmw_subscription_t> subscription,
    int count,
    ffi.Pointer<rmw_message_sequence_t> message_sequence,
    ffi.Pointer<rmw_message_info_sequence_t> message_info_sequence,
    ffi.Pointer<ffi.Size> taken,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take_sequence(
      subscription,
      count,
      message_sequence,
      message_info_sequence,
      taken,
      allocation,
    );
  }

  late final _rmw_take_sequencePtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_subscription_t>,
                  ffi.Size,
                  ffi.Pointer<rmw_message_sequence_t>,
                  ffi.Pointer<rmw_message_info_sequence_t>,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<rmw_subscription_allocation_t>)>>(
      'rmw_take_sequence');
  late final _rmw_take_sequence = _rmw_take_sequencePtr.asFunction<
      int Function(
          ffi.Pointer<rmw_subscription_t>,
          int,
          ffi.Pointer<rmw_message_sequence_t>,
          ffi.Pointer<rmw_message_info_sequence_t>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Take an incoming ROS message as a byte stream.
  /// /**
  ///  * Take a ROS message already received by the given subscription, removing it from internal queues.
  ///  * This function will succeed even if no ROS message was received, but `taken` will be false.
  ///  * Unlike rmw_take(), the ROS message is taken in its serialized form, as a byte stream.
  ///  * If needed, this byte stream can then be deserialized into a ROS message with rmw_deserialize().
  ///  *
  ///  * \remarks The same ROS message, serialized or not, cannot be taken twice.
  ///  *   Callers do not have to deal with duplicates.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To take a ROS message a byte stream is a synchronous operation.
  ///  *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
  ///  *   but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on take or not.
  ///  *   For instance, implementations may have to perform additional memory allocations
  ///  *   when dealing with ROS messages that contain unbounded (dynamically-sized) fields
  ///  *   i.e. these implementations may have to resize the given byte stream.
  ///  *   A subscription allocation, if provided, may or may not be used.
  ///  *   Check the implementation documentation to learn about memory allocation guarantees
  ///  *   when taking serialized ROS messages with and without subscription allocations.
  ///  * \par
  ///  *   For ROS messages that only contain bounded (fixed-size) fields, callers can query
  ///  *   their size using rmw_get_serialized_message_size() and resize `serialized_message`
  ///  *   using rmw_serialized_message_resize() accordingly to prevent byte stream resizing
  ///  *   on take.
  ///  *   Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.
  ///  *
  ///  * \par Thread-safety
  ///  *   Subscriptions are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to take from the same subscription concurrently.
  ///  *   However, when taking serialized ROS messages:
  ///  *   - Access to the given byte stream for serialized ROS messages is not synchronized.
  ///  *     It is not safe to read or write `serialized_message` while
  ///  *     rmw_take_serialized_message() uses it.
  ///  *   - Access to given primitive data-type arguments is not synchronized.
  ///  *     It is not safe to read or write `taken` while rmw_take_serialized_message() uses it.
  ///  *   - Access to the given subscription allocation is not synchronized,
  ///  *     unless specifically stated otherwise by the implementation.
  ///  *     Thus, it is generally not safe to read or write `allocation` while
  ///  *     rmw_take_serialized_message() uses it.
  ///  *     Check the implementation documentation to learn about subscription allocations'
  ///  *     thread-safety.
  ///  *
  ///  * \pre Given `subscription` must be a valid subscription, as returned by
  ///  *   rmw_create_subscription().
  ///  * \pre Given `serialized_message` must be a valid serialized message, initialized by
  ///  *   rmw_serialized_message_init().
  ///  * \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  ///  *   with rmw_subscription_allocation_init() with a message type support that matches the
  ///  *   one registered with `subscription` on creation.
  ///  * \post Given `serialized_message` will remain a valid serialized message.
  ///  *   It will be left unchanged if this function fails early due to a logical error,
  ///  *   such as an invalid argument, or in an unknown yet valid state if it fails due to a
  ///  *   runtime error.
  ///  *   It will also be left unchanged if this function succeeds but `taken` is false.
  ///  *
  ///  * \param[in] subscription Subscription to take ROS message from.
  ///  * \param[out] serialized_message Byte stream to write to.
  ///  * \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  ///  * \param[in] allocation Pre-allocated memory to use. May be NULL.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_serialized_message(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<rmw_serialized_message_t> serialized_message,
    ffi.Pointer<ffi.Bool> taken,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take_serialized_message(
      subscription,
      serialized_message,
      taken,
      allocation,
    );
  }

  late final _rmw_take_serialized_messagePtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_subscription_t>,
                  ffi.Pointer<rmw_serialized_message_t>,
                  ffi.Pointer<ffi.Bool>,
                  ffi.Pointer<rmw_subscription_allocation_t>)>>(
      'rmw_take_serialized_message');
  late final _rmw_take_serialized_message =
      _rmw_take_serialized_messagePtr.asFunction<
          int Function(
              ffi.Pointer<rmw_subscription_t>,
              ffi.Pointer<rmw_serialized_message_t>,
              ffi.Pointer<ffi.Bool>,
              ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Take an incoming ROS message as a byte stream with its metadata.
  /// /**
  ///  * Same as rmw_take_serialized_message(), except it also takes ROS message metadata.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To take a ROS message a byte stream with its metadata is a synchronous operation.
  ///  *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
  ///  *   but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on take or not.
  ///  *   For instance, implementations may have to perform additional memory allocations
  ///  *   when dealing with ROS messages that contain unbounded (dynamically-sized) fields
  ///  *   i.e. these implementations may have to resize the given byte stream.
  ///  *   A subscription allocation, if provided, may or may not be used.
  ///  *   Check the implementation documentation to learn about memory allocation guarantees
  ///  *   when taking serialized ROS messages with and without subscription allocations.
  ///  * \par
  ///  *   For ROS messages that only contain bounded (fixed-size) fields, callers can query
  ///  *   their size using rmw_get_serialized_message_size() and resize `serialized_message`
  ///  *   using rmw_serialized_message_resize() accordingly to prevent byte stream resizing
  ///  *   on take.
  ///  *   Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.
  ///  *
  ///  * \par Thread-safety
  ///  *   Subscriptions are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to take from the same subscription concurrently.
  ///  *   However, when taking serialized ROS messages with metadata:
  ///  *   - Access to the given byte stream for serialized ROS messages is not synchronized.
  ///  *     It is not safe to read or write `serialized_message` while
  ///  *     rmw_take_serialized_message_with_info() uses it.
  ///  *   - Access to the given ROS message metadata is not synchronized.
  ///  *     It is not safe to read or write `message_info` while
  ///  *     rmw_take_serialized_message_with_info() uses it.
  ///  *   - Access to given primitive data-type arguments is not synchronized.
  ///  *     It is not safe to read or write `taken` while rmw_take_serialized_message_with_info()
  ///  *     uses it.
  ///  *   - Access to the given subscription allocation is not synchronized,
  ///  *     unless specifically stated otherwise by the implementation.
  ///  *     Thus, it is generally not safe to read or write `allocation` while
  ///  *     rmw_take_serialized_message_with_info() uses it.
  ///  *     Check the implementation documentation to learn about subscription allocations'
  ///  *     thread-safety.
  ///  *
  ///  * \pre Given `serialized_message` must be a valid serialized message, initialized by
  ///  *   rmw_serialized_message_init().
  ///  * \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  ///  *   with rmw_subscription_allocation_init() with a message type support that matches the
  ///  *   one registered with `subscription` on creation.
  ///  * \post Given `serialized_message` will remain a valid serialized message, and `message_info`,
  ///  *   valid message metadata.
  ///  *   Both will be left unchanged if this function fails early due to a logical error,
  ///  *   such as an invalid argument, or in an unknown yet valid state if it fails due to a
  ///  *   runtime error.
  ///  *   It will also be left unchanged if this function succeeds but `taken` is false.
  ///  *
  ///  * \param[in] subscription Subscription to take ROS message from.
  ///  * \param[out] serialized_message Byte stream to write to.
  ///  * \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  ///  * \param[out] message_info Taken ROS message metadata.
  ///  * \param[in] allocation Pre-allocated memory to use. May be NULL.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_serialized_message_with_info(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<rmw_serialized_message_t> serialized_message,
    ffi.Pointer<ffi.Bool> taken,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take_serialized_message_with_info(
      subscription,
      serialized_message,
      taken,
      message_info,
      allocation,
    );
  }

  late final _rmw_take_serialized_message_with_infoPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_subscription_t>,
                  ffi.Pointer<rmw_serialized_message_t>,
                  ffi.Pointer<ffi.Bool>,
                  ffi.Pointer<rmw_message_info_t>,
                  ffi.Pointer<rmw_subscription_allocation_t>)>>(
      'rmw_take_serialized_message_with_info');
  late final _rmw_take_serialized_message_with_info =
      _rmw_take_serialized_message_with_infoPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_subscription_t>,
              ffi.Pointer<rmw_serialized_message_t>,
              ffi.Pointer<ffi.Bool>,
              ffi.Pointer<rmw_message_info_t>,
              ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Take an incoming ROS message, loaned by the middleware.
  /// /**
  ///  * Take a ROS message already received by the given subscription, removing it from internal queues.
  ///  * This function will succeed even if no ROS message was received, but `taken` will be false.
  ///  * The loaned ROS message is owned by the middleware, which will keep it alive (i.e. in valid
  ///  * memory space) until the caller returns it using rmw_return_loaned_message_from_subscription().
  ///  *
  ///  * \remarks The same ROS message, loaned or not, cannot be taken twice.
  ///  *   Callers do not have to deal with duplicates.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To take a loaned ROS message is a synchronous operation.
  ///  *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive
  ///  *   nor for internal memory loaning pools, if any, to be replenished, but it is not
  ///  *   guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on take or not.
  ///  *   For instance, implementations that deserialize ROS messages received over
  ///  *   the wire may need to perform additional memory allocations when dealing with
  ///  *   unbounded (dynamically-sized) fields.
  ///  *   A subscription allocation, if provided, may or may not be used.
  ///  *   Check the implementation documentation to learn about memory allocation
  ///  *   guarantees when taking loaned ROS messages with and without subscription allocations.
  ///  *
  ///  * \par Thread-safety
  ///  *   Subscriptions are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to take from the same subscription concurrently.
  ///  *   However, when taking loaned ROS messages:
  ///  *   - Access to given primitive data-type arguments is not synchronized.
  ///  *     It is not safe to read or write `taken` nor `loaned_message`
  ///  *     while rmw_take_loaned_message() uses them.
  ///  *   - Access to the given subscription allocation is not synchronized,
  ///  *     unless specifically stated otherwise by the implementation.
  ///  *     Thus, it is generally not safe to read or write `allocation` while
  ///  *     rmw_take_loaned_message() uses it.
  ///  *     Check the implementation documentation to learn about subscription allocations'
  ///  *     thread-safety.
  ///  *
  ///  * \pre Given `subscription` must be a valid subscription, as returned
  ///  *   by rmw_create_subscription().
  ///  * \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  ///  *   with rmw_subscription_allocation_init() with a message type support that matches the
  ///  *   one registered with `subscription` on creation.
  ///  * \post Given `loaned_message` will remain unchanged, or point to a valid message if
  ///  *   this function was successful and `taken` is true.
  ///  *
  ///  * \param[in] subscription Subscription to take ROS message from.
  ///  * \param[inout] loaned_message Pointer to type erased ROS message taken
  ///  *   and loaned by the middleware.
  ///  * \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  ///  * \param[in] allocation Pre-allocated memory to use. May be NULL.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL (to prevent leaks), or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_loaned_message(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
    ffi.Pointer<ffi.Bool> taken,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take_loaned_message(
      subscription,
      loaned_message,
      taken,
      allocation,
    );
  }

  late final _rmw_take_loaned_messagePtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_subscription_t>,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>,
                  ffi.Pointer<ffi.Bool>,
                  ffi.Pointer<rmw_subscription_allocation_t>)>>(
      'rmw_take_loaned_message');
  late final _rmw_take_loaned_message = _rmw_take_loaned_messagePtr.asFunction<
      int Function(
          ffi.Pointer<rmw_subscription_t>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>,
          ffi.Pointer<ffi.Bool>,
          ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Take a loaned message and with its additional message information.
  /// /**
  ///  * Same as rmw_take_loaned_message(), except it also takes ROS message metadata.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To take a loaned ROS message with its metadata is a synchronous operation.
  ///  *   It is also non-blocking, to the extent it will not wait for new ROS messages to arrive
  ///  *   nor for internal memory loaning pools, if any, to be replenished, but it is not
  ///  *   guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on take or not.
  ///  *   For instance, implementations that deserialize ROS messages received over
  ///  *   the wire may need to perform additional memory allocations when dealing with
  ///  *   unbounded (dynamically-sized) fields.
  ///  *   A subscription allocation, if provided, may or may not be used.
  ///  *   Check the implementation documentation to learn about memory allocation
  ///  *   guarantees when taking loaned ROS messages with and without subscription allocations.
  ///  *
  ///  * \par Thread-safety
  ///  *   Subscriptions are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to take from the same subscription concurrently.
  ///  *   However, when taking loaned ROS messages with metadata:
  ///  *   - Access to given primitive data-type arguments is not synchronized.
  ///  *     It is not safe to read or write `taken` nor `loaned_message`
  ///  *     while rmw_take_loaned_message_with_info() uses them.
  ///  *   - Access to the given ROS message metadata is not synchronized.
  ///  *     It is not safe to read or write `message_info` while
  ///  *     rmw_take_loaned_message_with_info() uses it.
  ///  *   - Access to the given subscription allocation is not synchronized,
  ///  *     unless specifically stated otherwise by the implementation.
  ///  *     Thus, it is generally not safe to read or write `allocation` while
  ///  *     rmw_take_loaned_message_with_info() uses it.
  ///  *     Check the implementation documentation to learn about subscription allocations'
  ///  *     thread-safety.
  ///  *
  ///  * \pre Given `subscription` must be a valid subscription, as returned
  ///  *   by rmw_create_subscription().
  ///  * \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  ///  *   with rmw_subscription_allocation_init() with a message type support that matches the
  ///  *   one registered with `subscription` on creation.
  ///  * \post Given `loaned_message` will remain unchanged, or point to a valid message if
  ///  *   this function was successful and `taken` is true.
  ///  * \post Given `message_info` will remain valid message metadata.
  ///  *   It will be left unchanged if this function fails early due to a logical error,
  ///  *   such as an invalid argument, or in an unknown yet valid state if it fails due to a
  ///  *   runtime error.
  ///  *   It will also be left unchanged if this function succeeds but `taken` is false.
  ///  *
  ///  * \param[in] subscription Subscription to take ROS message from.
  ///  * \param[inout] loaned_message Pointer to type erased ROS message taken
  ///  *   and loaned by the middleware.
  ///  * \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  ///  * \param[out] message_info Taken ROS message metadata.
  ///  * \param[in] allocation Pre-allocated memory to use. May be NULL.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL to prevent leaks, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_loaned_message_with_info(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
    ffi.Pointer<ffi.Bool> taken,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take_loaned_message_with_info(
      subscription,
      loaned_message,
      taken,
      message_info,
      allocation,
    );
  }

  late final _rmw_take_loaned_message_with_infoPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_subscription_t>,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>,
                  ffi.Pointer<ffi.Bool>,
                  ffi.Pointer<rmw_message_info_t>,
                  ffi.Pointer<rmw_subscription_allocation_t>)>>(
      'rmw_take_loaned_message_with_info');
  late final _rmw_take_loaned_message_with_info =
      _rmw_take_loaned_message_with_infoPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_subscription_t>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Bool>,
              ffi.Pointer<rmw_message_info_t>,
              ffi.Pointer<rmw_subscription_allocation_t>)>();

  /// Return a loaned ROS message previously taken from a subscription.
  /// /**
  ///  * Tells the middleware that previously loaned ROS message is no longer needed by the caller.
  ///  * If this function fails early due to a logical error, such as an invalid argument,
  ///  * the loaned ROS message will be left unchanged.
  ///  * Otherwise, ownership of the ROS message will be given back to the middleware.
  ///  * It is up to the middleware what will be made of the returned ROS message.
  ///  * It is undefined behavior to use a loaned ROS message after returning it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To return a loaned ROS message is a synchronous operation.
  ///  *   It is also non-blocking, but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Thread-safety
  ///  *   Subscriptions are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to return loaned ROS messages to the same subscription concurrently.
  ///  *   However, since ownership of the loaned ROS message is given back to middleware and this
  ///  *   transfer is not synchronized, it is not safe to return the same loaned ROS message
  ///  *   concurrently.
  ///  *
  ///  * \pre Given `subscription` must be a valid subscription, as returned
  ///  *   by rmw_create_subscription().
  ///  * \pre Given `loaned_message` must be a loaned ROS message, previously taken from
  ///  *   `subscription` using rmw_take_loaned_message() or rmw_take_loaned_message_with_info().
  ///  *
  ///  * \param[in] subscription Subscription the ROS message was taken and loaned from.
  ///  * \param[in] loaned_message Loaned type erased ROS message to be returned to the middleware.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_return_loaned_message_from_subscription(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return _rmw_return_loaned_message_from_subscription(
      subscription,
      loaned_message,
    );
  }

  late final _rmw_return_loaned_message_from_subscriptionPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_subscription_t>, ffi.Pointer<ffi.Void>)>>(
      'rmw_return_loaned_message_from_subscription');
  late final _rmw_return_loaned_message_from_subscription =
      _rmw_return_loaned_message_from_subscriptionPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_subscription_t>, ffi.Pointer<ffi.Void>)>();

  /// Create a service client that can send requests to and receive replies from a service server.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - `node` is `NULL`, or
  ///  *   - `node` does not belong to this implementation
  ///  *      i.e. it does not have a matching implementation identifier, or
  ///  *   - `type_support` is `NULL`, or
  ///  *   - `service_name` is `NULL`, or
  ///  *   - `service_name` is an empty string, or
  ///  *   - (if ROS namespace conventions apply) `service_name` is invalid by
  ///  *     rmw_validate_full_topic_name() definition, or
  ///  *   - `qos_profile` is `NULL`, or
  ///  *   - `qos_profile` has invalid or unknown policies, or
  ///  *   - memory allocation fails during service client creation, or
  ///  *   - an unspecified error occurs.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \pre Given `node` must be a valid node, as returned by rmw_create_node().
  ///  * \pre Given `type_support` must be a valid `rosidl` service type support, as
  ///  *   returned by ROSIDL_GET_SRV_TYPE_SUPPORT().
  ///  *
  ///  * \param[in] node Node with which to register this service client.
  ///  * \param[in] type_support Type support of the service to be used.
  ///  * \param[in] service_name Name of the service to be used, often a fully qualified
  ///  *   service name unless `qos_profile` is configured to avoid ROS namespace conventions
  ///  *   i.e. to create a native service client.
  ///  * \param[in] qos_policies QoS policies for this service client's connections.
  ///  * \return rmw service client handle, or `NULL` if there was an error.
  ///  */
  ffi.Pointer<rmw_client_t> rmw_create_client(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Char> service_name,
    ffi.Pointer<rmw_qos_profile_t> qos_policies,
  ) {
    return _rmw_create_client(
      node,
      type_support,
      service_name,
      qos_policies,
    );
  }

  late final _rmw_create_clientPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_client_t> Function(
              ffi.Pointer<rmw_node_t>,
              ffi.Pointer<rosidl_service_type_support_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<rmw_qos_profile_t>)>>('rmw_create_client');
  late final _rmw_create_client = _rmw_create_clientPtr.asFunction<
      ffi.Pointer<rmw_client_t> Function(
          ffi.Pointer<rmw_node_t>,
          ffi.Pointer<rosidl_service_type_support_t>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<rmw_qos_profile_t>)>();

  /// Destroy and unregister a service client from its node.
  /// /**
  ///  * This function will reclaim all associated resources, including the service client itself.
  ///  * Use of a destroyed service client is undefined behavior.
  ///  * This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  ///  * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given service client unchanged.
  ///  * Otherwise, it will proceed despite errors.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \pre Given `node` must be the one the service client was registered with.
  ///  * \pre Given `client` must be a valid service client, as returned by rmw_create_service().
  ///  *
  ///  * \param[in] node Node with which the given service client is registered.
  ///  * \param[in] client Service client to be destroyed.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `client` is `NULL`, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node`
  ///  *   implementation identifier does not match this implementation, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`
  ///  *   implementation identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_destroy_client(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_client_t> client,
  ) {
    return _rmw_destroy_client(
      node,
      client,
    );
  }

  late final _rmw_destroy_clientPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_node_t>,
              ffi.Pointer<rmw_client_t>)>>('rmw_destroy_client');
  late final _rmw_destroy_client = _rmw_destroy_clientPtr.asFunction<
      int Function(ffi.Pointer<rmw_node_t>, ffi.Pointer<rmw_client_t>)>();

  /// Send a ROS service request.
  /// /**
  ///  * Send a ROS service request to one or more service servers, with matching QoS policies,
  ///  * using the given client.
  ///  *
  ///  * \note It is implementation defined how many service servers may get, and potentially react to,
  ///  *   the same request, considering there may be more than one server for the same service
  ///  *   in the ROS graph.
  ///  *
  ///  * On success, this function will return a sequence number.
  ///  * It is up to callers to save the returned sequence number to pair the ROS service request
  ///  * just sent with future ROS service responses (taken using rmw_take_response()).
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   It is implementation defined whether sending a ROS service request is a
  ///  *   synchronous or asynchronous, and blocking or non-blocking, operation.
  ///  *   However, asynchronous implementations are not allowed to access the
  ///  *   given ROS service request after this function returns.
  ///  *   Check the implementation documentation to learn about request behavior.
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on send or not.
  ///  *   For instance, implementations that serialize ROS service requests may need to
  ///  *   perform additional memory allocations when dealing with unbounded (dynamically-sized)
  ///  *   fields.
  ///  *
  ///  * \par Thread-safety
  ///  *   Service clients are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to send requests using the same service client concurrently.
  ///  *   However:
  ///  *   - Access to the given ROS service request is read-only but it is not synchronized.
  ///  *     Concurrent `ros_request` reads are safe, but concurrent reads and writes are not.
  ///  *   - Access to given primitive data-type arguments is not synchronized.
  ///  *     It is not safe to read or write `sequence_id` while rmw_send_request() uses it.
  ///  *
  ///  * \pre Given `client` must be a valid client, as returned by rmw_create_client().
  ///  * \pre Given `ros_request` must be a valid service request, whose type matches the
  ///  *   service type support registered with the `client` on creation.
  ///  *
  ///  * \param[in] client Service client to send a request with.
  ///  * \param[in] ros_request ROS service request to be sent.
  ///  * \param[out] sequence_id Sequence number for the `ros_request` just sent
  ///  *   i.e. a unique identification number for it, populated on success.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `ros_request` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `sequence_id` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`
  ///  *   implementation identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_send_request(
    ffi.Pointer<rmw_client_t> client,
    ffi.Pointer<ffi.Void> ros_request,
    ffi.Pointer<ffi.Int64> sequence_id,
  ) {
    return _rmw_send_request(
      client,
      ros_request,
      sequence_id,
    );
  }

  late final _rmw_send_requestPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_client_t>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int64>)>>('rmw_send_request');
  late final _rmw_send_request = _rmw_send_requestPtr.asFunction<
      int Function(ffi.Pointer<rmw_client_t>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Int64>)>();

  /// Take an incoming ROS service response.
  /// /**
  ///  * Take a ROS service response already received by the given service server, removing
  ///  * it from internal queues.
  ///  * The response header (i.e. its metadata), containing at least the writer guid and
  ///  * sequence number, is also retrieved.
  ///  * Both writer guid and sequence number allow callers to pair, potentially for each
  ///  * remote service server, a ROS service response with its corresponding ROS service
  ///  * request, previously sent using rmw_send_request().
  ///  *
  ///  * \note It is implementation defined how many responses a given request may get,
  ///  *   considering there may be more than one server for the same service in the ROS graph.
  ///  *
  ///  * This function will succeed even if no ROS service request was received,
  ///  * but `taken` will be false.
  ///  *
  ///  * \remarks The same ROS service response cannot be taken twice.
  ///  *   Callers do not have to deal with duplicates.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   Taking a ROS service response is a synchronous operation.
  ///  *   It is also non-blocking, to the extent it will not wait for new ROS service responses
  ///  *   to arrive, but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on take or not.
  ///  *   For instance, implementations that deserialize ROS service responses received over
  ///  *   the wire may need to perform additional memory allocations when dealing with
  ///  *   unbounded (dynamically-sized) fields.
  ///  *
  ///  * \par Thread-safety
  ///  *   Service clients are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to take responses from the same service client concurrently.
  ///  *   However:
  ///  *   - Access to the given ROS service response is not synchronized.
  ///  *     It is not safe to read or write `ros_response` while rmw_take_request() uses it.
  ///  *   - Access to the given ROS service response header is not synchronized.
  ///  *     It is not safe to read or write `response_header` while rmw_take_response() uses it.
  ///  *   - Access to given primitive data-type arguments is not synchronized.
  ///  *     It is not safe to read or write `taken` while rmw_take_response() uses it.
  ///  *
  ///  * \pre Given `client` must be a valid client, as returned by rmw_create_client().
  ///  * \pre Given `ros_response` must be a valid service response, whose type matches the
  ///  *   service type support registered with the `client` on creation.
  ///  * \post Given `ros_response` will remain a valid service response.
  ///  *   It will be left unchanged if this function fails early due to a logical error, such as an
  ///  *   invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
  ///  *   It will also be left unchanged if this function succeeds but `taken` is false.
  ///  *
  ///  * \param[in] client Service client to take response from.
  ///  * \param[out] request_header Service response header to write to.
  ///  * \param[out] ros_response Type erased ROS service response to write to.
  ///  * \param[out] taken Boolean flag indicating if a ROS service response was taken or not.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `response_header` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `ros_response` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`
  ///  *   implementation identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_response(
    ffi.Pointer<rmw_client_t> client,
    ffi.Pointer<rmw_service_info_t> request_header,
    ffi.Pointer<ffi.Void> ros_response,
    ffi.Pointer<ffi.Bool> taken,
  ) {
    return _rmw_take_response(
      client,
      request_header,
      ros_response,
      taken,
    );
  }

  late final _rmw_take_responsePtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<rmw_client_t>,
              ffi.Pointer<rmw_service_info_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Bool>)>>('rmw_take_response');
  late final _rmw_take_response = _rmw_take_responsePtr.asFunction<
      int Function(ffi.Pointer<rmw_client_t>, ffi.Pointer<rmw_service_info_t>,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Bool>)>();

  /// Retrieve the actual qos settings of the client's request publisher.
  /// /**
  ///  * Query the underlying middleware to determine the qos settings
  ///  * of the client's request publisher.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the client, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  *
  ///  * \note The value of avoid_ros_namespace_conventions field is not resolved
  ///  *   with this function. The rcl function `rcl_client_request_publisher_get_actual_qos()`
  ///  *   resolves it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] client the client object to inspect
  ///  * \param[out] qos the actual qos settings
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if client
  ///  *   implementation identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_client_request_publisher_get_actual_qos(
    ffi.Pointer<rmw_client_t> client,
    ffi.Pointer<rmw_qos_profile_t> qos,
  ) {
    return _rmw_client_request_publisher_get_actual_qos(
      client,
      qos,
    );
  }

  late final _rmw_client_request_publisher_get_actual_qosPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_client_t>, ffi.Pointer<rmw_qos_profile_t>)>>(
      'rmw_client_request_publisher_get_actual_qos');
  late final _rmw_client_request_publisher_get_actual_qos =
      _rmw_client_request_publisher_get_actual_qosPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_client_t>, ffi.Pointer<rmw_qos_profile_t>)>();

  /// Retrieve the actual qos settings of the client's response subscription.
  /// /**
  ///  * Query the underlying middleware to determine the qos settings
  ///  * of the client's response subscription.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the client, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  *
  ///  * \note The value of avoid_ros_namespace_conventions field is not resolved
  ///  *   with this function. The rcl function `rcl_client_request_publisher_get_actual_qos()`
  ///  *   resolves it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] client the client object to inspect
  ///  * \param[out] qos the actual qos settings
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if client
  ///  *   implementation identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_client_response_subscription_get_actual_qos(
    ffi.Pointer<rmw_client_t> client,
    ffi.Pointer<rmw_qos_profile_t> qos,
  ) {
    return _rmw_client_response_subscription_get_actual_qos(
      client,
      qos,
    );
  }

  late final _rmw_client_response_subscription_get_actual_qosPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_client_t>, ffi.Pointer<rmw_qos_profile_t>)>>(
      'rmw_client_response_subscription_get_actual_qos');
  late final _rmw_client_response_subscription_get_actual_qos =
      _rmw_client_response_subscription_get_actual_qosPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_client_t>, ffi.Pointer<rmw_qos_profile_t>)>();

  /// Create a service server that can receive requests from and send replies to a service client.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - `node` is `NULL`, or
  ///  *   - `node` does not belong to this implementation
  ///  *     i.e. it does not have a matching implementation identifier, or
  ///  *   - `type_support` is `NULL`, or
  ///  *   - `service_name` is `NULL`, or
  ///  *   - `service_name` is an empty string, or
  ///  *   - (if ROS namespace conventions apply) `service_name` is invalid by
  ///  *     rmw_validate_full_topic_name() definition, or
  ///  *   - `qos_profile` is `NULL`, or
  ///  *   - `qos_profile` has invalid or unknown policies, or
  ///  *   - memory allocation fails during service server creation, or
  ///  *   - an unspecified error occurs
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \pre Given `node` must be a valid node, as returned by rmw_create_node().
  ///  * \pre Given `type_support` must be a valid `rosidl` service type support, as
  ///  *   returned by ROSIDL_GET_SRV_TYPE_SUPPORT().
  ///  *
  ///  * \param[in] node Node with which to register this service server.
  ///  * \param[in] type_support Type support of the service to be served.
  ///  * \param[in] service_name Name of the service to be served, often a fully qualified
  ///  *   service name unless `qos_profile` is configured to avoid ROS namespace conventions
  ///  *   i.e. to create a native service server.
  ///  * \param[in] qos_profile QoS policies for this service server's connections.
  ///  * \return rmw service handle, or `NULL` if there was an error.
  ///  */
  ffi.Pointer<rmw_service_t> rmw_create_service(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Char> service_name,
    ffi.Pointer<rmw_qos_profile_t> qos_profile,
  ) {
    return _rmw_create_service(
      node,
      type_support,
      service_name,
      qos_profile,
    );
  }

  late final _rmw_create_servicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_service_t> Function(
              ffi.Pointer<rmw_node_t>,
              ffi.Pointer<rosidl_service_type_support_t>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<rmw_qos_profile_t>)>>('rmw_create_service');
  late final _rmw_create_service = _rmw_create_servicePtr.asFunction<
      ffi.Pointer<rmw_service_t> Function(
          ffi.Pointer<rmw_node_t>,
          ffi.Pointer<rosidl_service_type_support_t>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<rmw_qos_profile_t>)>();

  /// Destroy and unregister a service server from its node.
  /// /**
  ///  * This function will reclaim all associated resources, including the service server itself.
  ///  * Use of a destroyed service server is undefined behavior.
  ///  * This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  ///  * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given service server unchanged.
  ///  * Otherwise, it will proceed despite errors.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \pre Given `node` must be the one the service server was registered with.
  ///  * \pre Given `service` must be a valid service server, as returned by rmw_create_service().
  ///  *
  ///  * \param[in] node Node with which the given service server is registered.
  ///  * \param[in] service Service server to be destroyed.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `service` is `NULL`, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node`
  ///  *   implementation identifier does not match this implementation, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`
  ///  *   implementation identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_destroy_service(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_service_t> service,
  ) {
    return _rmw_destroy_service(
      node,
      service,
    );
  }

  late final _rmw_destroy_servicePtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_node_t>,
              ffi.Pointer<rmw_service_t>)>>('rmw_destroy_service');
  late final _rmw_destroy_service = _rmw_destroy_servicePtr.asFunction<
      int Function(ffi.Pointer<rmw_node_t>, ffi.Pointer<rmw_service_t>)>();

  /// Take an incoming ROS service request.
  /// /**
  ///  * Take a ROS service request already received by the given service server, removing
  ///  * it from internal queues.
  ///  * The request header (i.e. its metadata), containing at least the writer guid and
  ///  * sequence number, is also retrieved.
  ///  * Both writer guid and sequence number allow callers to pair, for each remote service
  ///  * client, a ROS service request with its corresponding ROS service response, to be later
  ///  * sent using rmw_send_response().
  ///  *
  ///  * This function will succeed even if no ROS service request was received,
  ///  * but `taken` will be false.
  ///  *
  ///  * \remarks The same ROS service request cannot be taken twice.
  ///  *   Callers do not have to deal with duplicates.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   Taking a ROS service request is a synchronous operation.
  ///  *   It is also non-blocking, to the extent it will not wait for new ROS service requests
  ///  *   to arrive, but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on take or not.
  ///  *   For instance, implementations that deserialize ROS service requests received over
  ///  *   the wire may need to perform additional memory allocations when dealing with
  ///  *   unbounded (dynamically-sized) fields.
  ///  *
  ///  * \par Thread-safety
  ///  *   Service servers are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to take requests from the same service server concurrently.
  ///  *   However:
  ///  *   - Access to the given ROS service request is not synchronized.
  ///  *     It is not safe to read or write `ros_request` while rmw_take_request() uses it.
  ///  *   - Access to the given ROS service request header is not synchronized.
  ///  *     It is not safe to read or write `request_header` while rmw_take_request() uses it.
  ///  *   - Access to given primitive data-type arguments is not synchronized.
  ///  *     It is not safe to read or write `taken` while rmw_take_request() uses it.
  ///  *
  ///  * \pre Given `service` must be a valid service, as returned by rmw_create_service().
  ///  * \pre Given `ros_request` must be a valid service request, whose type matches the
  ///  *   service type support registered with the `service` on creation.
  ///  * \post Given `ros_request` will remain a valid service request.
  ///  *   It will be left unchanged if this function fails early due to a logical error, such as an
  ///  *   invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
  ///  *   It will also be left unchanged if this function succeeds but `taken` is false.
  ///  *
  ///  * \param[in] service Service server to take request from.
  ///  * \param[out] request_header Service request header to write to.
  ///  * \param[out] ros_request Type erased ROS service request to write to.
  ///  * \param[out] taken Boolean flag indicating if a ROS service request was taken or not.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `request_header` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `ros_request` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`
  ///  *   implementation identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_request(
    ffi.Pointer<rmw_service_t> service,
    ffi.Pointer<rmw_service_info_t> request_header,
    ffi.Pointer<ffi.Void> ros_request,
    ffi.Pointer<ffi.Bool> taken,
  ) {
    return _rmw_take_request(
      service,
      request_header,
      ros_request,
      taken,
    );
  }

  late final _rmw_take_requestPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<rmw_service_t>,
              ffi.Pointer<rmw_service_info_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Bool>)>>('rmw_take_request');
  late final _rmw_take_request = _rmw_take_requestPtr.asFunction<
      int Function(ffi.Pointer<rmw_service_t>, ffi.Pointer<rmw_service_info_t>,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Bool>)>();

  /// Send a ROS service response.
  /// /**
  ///  * Send a ROS service response to the service client, with matching QoS policies,
  ///  * from which the previously taken ROS service request was originally sent.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   It is implementation defined whether sending a ROS service response is a
  ///  *   synchronous or asynchronous, and blocking or non-blocking, operation.
  ///  *   However, asynchronous implementations are not allowed to access the
  ///  *   given ROS service request after this function returns.
  ///  *   Check the implementation documentation to learn about request behavior.
  ///  *
  ///  * \par Memory allocation
  ///  *   It is implementation defined whether memory will be allocated on send or not.
  ///  *   For instance, implementations that serialize ROS service responses may need to
  ///  *   perform additional memory allocations when dealing with unbounded (dynamically-sized)
  ///  *   fields.
  ///  *
  ///  * \par Thread-safety
  ///  *   Service servers are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to send responses using the same service server concurrently.
  ///  *   However:
  ///  *   - Access to the given ROS service request header is read-only but it is not synchronized.
  ///  *     Concurrent `request_header` reads are safe, but concurrent reads and writes are not.
  ///  *   - Access to the given ROS service response is read-only but it is not synchronized.
  ///  *     Concurrent `ros_request` reads are safe, but concurrent reads and writes are not.
  ///  *
  ///  * \pre Given `service` must be a valid service server, as returned by rmw_create_service().
  ///  * \pre Given `request_header` must be the one previously taken along with the ROS service
  ///  *   request to which we reply.
  ///  * \pre Given `ros_response` must be a valid service response, whose type matches the
  ///  *   service type support registered with the `service` on creation.
  ///  *
  ///  * \param[in] service Service server to send a response with.
  ///  * \param[in] request_header Service response header, same as the one taken
  ///  *   with the corresponding ROS service request.
  ///  * \param[in] ros_response ROS service response to be sent.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `request_header` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `ros_response` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`
  ///  *   implementation identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_send_response(
    ffi.Pointer<rmw_service_t> service,
    ffi.Pointer<rmw_request_id_t> request_header,
    ffi.Pointer<ffi.Void> ros_response,
  ) {
    return _rmw_send_response(
      service,
      request_header,
      ros_response,
    );
  }

  late final _rmw_send_responsePtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<rmw_service_t>,
              ffi.Pointer<rmw_request_id_t>,
              ffi.Pointer<ffi.Void>)>>('rmw_send_response');
  late final _rmw_send_response = _rmw_send_responsePtr.asFunction<
      int Function(ffi.Pointer<rmw_service_t>, ffi.Pointer<rmw_request_id_t>,
          ffi.Pointer<ffi.Void>)>();

  /// Retrieve the actual qos settings of the service's request subscription.
  /// /**
  ///  * Query the underlying middleware to determine the qos settings
  ///  * of the service's request subscription.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the service, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  *
  ///  * \note The value of avoid_ros_namespace_conventions field is not resolved
  ///  *   with this function. The rcl function `rcl_service_request_subscription_get_actual_qos()`
  ///  *   resolves it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] service the service object to inspect
  ///  * \param[out] qos the actual qos settings
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if service
  ///  *   implementation identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_service_request_subscription_get_actual_qos(
    ffi.Pointer<rmw_service_t> service,
    ffi.Pointer<rmw_qos_profile_t> qos,
  ) {
    return _rmw_service_request_subscription_get_actual_qos(
      service,
      qos,
    );
  }

  late final _rmw_service_request_subscription_get_actual_qosPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_service_t>, ffi.Pointer<rmw_qos_profile_t>)>>(
      'rmw_service_request_subscription_get_actual_qos');
  late final _rmw_service_request_subscription_get_actual_qos =
      _rmw_service_request_subscription_get_actual_qosPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_service_t>, ffi.Pointer<rmw_qos_profile_t>)>();

  /// Retrieve the actual qos settings of the service's response publisher.
  /// /**
  ///  * Query the underlying middleware to determine the qos settings
  ///  * of the service's response publisher.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the service, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  *
  ///  * \note The value of avoid_ros_namespace_conventions field is not resolved
  ///  *   with this function. The rcl function `rcl_service_request_subscription_get_actual_qos()`
  ///  *   resolves it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \param[in] service the service object to inspect
  ///  * \param[out] qos the actual qos settings
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if service
  ///  *   implementation identifier does not match, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_service_response_publisher_get_actual_qos(
    ffi.Pointer<rmw_service_t> service,
    ffi.Pointer<rmw_qos_profile_t> qos,
  ) {
    return _rmw_service_response_publisher_get_actual_qos(
      service,
      qos,
    );
  }

  late final _rmw_service_response_publisher_get_actual_qosPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_service_t>, ffi.Pointer<rmw_qos_profile_t>)>>(
      'rmw_service_response_publisher_get_actual_qos');
  late final _rmw_service_response_publisher_get_actual_qos =
      _rmw_service_response_publisher_get_actual_qosPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_service_t>, ffi.Pointer<rmw_qos_profile_t>)>();

  /// TODO(wjwwood): refactor this API to return a return code when updated to use an allocator
  /// Create a guard condition and return a handle to that guard condition.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - context is `NULL`
  ///  *   - context is invalid
  ///  *   - memory allocation fails during guard condition creation
  ///  *   - an unspecified error occurs
  ///  *
  ///  * The context must be non-null and valid, i.e. it has been initialized
  ///  * by `rmw_init()` and has not been finalized by `rmw_shutdown()`.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No [1]
  ///  * Lock-Free          | No [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[in] context init context that this node should be associated with
  ///  * \return rmw guard condition handle or `NULL` if there was an error
  ///  */
  ffi.Pointer<rmw_guard_condition_t> rmw_create_guard_condition(
    ffi.Pointer<rmw_context_t> context,
  ) {
    return _rmw_create_guard_condition(
      context,
    );
  }

  late final _rmw_create_guard_conditionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_guard_condition_t> Function(
              ffi.Pointer<rmw_context_t>)>>('rmw_create_guard_condition');
  late final _rmw_create_guard_condition =
      _rmw_create_guard_conditionPtr.asFunction<
          ffi.Pointer<rmw_guard_condition_t> Function(
              ffi.Pointer<rmw_context_t>)>();

  /// Finalize a given guard condition handle, reclaim the resources, and deallocate the handle.
  /// /**
  ///  * \param[in] guard_condition the guard condition handle to be destroyed
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if guard_condition is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_destroy_guard_condition(
    ffi.Pointer<rmw_guard_condition_t> guard_condition,
  ) {
    return _rmw_destroy_guard_condition(
      guard_condition,
    );
  }

  late final _rmw_destroy_guard_conditionPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_guard_condition_t>)>>(
      'rmw_destroy_guard_condition');
  late final _rmw_destroy_guard_condition = _rmw_destroy_guard_conditionPtr
      .asFunction<int Function(ffi.Pointer<rmw_guard_condition_t>)>();

  int rmw_trigger_guard_condition(
    ffi.Pointer<rmw_guard_condition_t> guard_condition,
  ) {
    return _rmw_trigger_guard_condition(
      guard_condition,
    );
  }

  late final _rmw_trigger_guard_conditionPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_guard_condition_t>)>>(
      'rmw_trigger_guard_condition');
  late final _rmw_trigger_guard_condition = _rmw_trigger_guard_conditionPtr
      .asFunction<int Function(ffi.Pointer<rmw_guard_condition_t>)>();

  /// Create a wait set to store conditions that the middleware can wait on.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - context is `NULL`
  ///  *   - context is zero initialized, as provided by rmw_get_zero_initialized_context()
  ///  *   - context does not belong to this implementation i.e. does not have a matching
  ///  *     implementation identifier
  ///  *   - memory allocation fails during wait set creation
  ///  *   - an unspecified error occurs
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \par Thread-safety
  ///  *   Contexts are thread-safe objects, and so are all operations on them except for finalization.
  ///  *   Therefore, it is safe to create multiple wait sets in the same context concurrently.
  ///  *
  ///  * \pre Given `context` must be a valid context, initialized by rmw_init().
  ///  *
  ///  * \param[in] context Context to associate the wait set with.
  ///  * \param[in] max_conditions
  ///  *   The maximum number of conditions that can be attached to, and stored by, the wait set.
  ///  *   Can be set to zero (0) for the wait set to support an unbounded number of conditions.
  ///  * \return An rmw wait set, or `NULL` if an error occurred.
  ///  */
  ffi.Pointer<rmw_wait_set_t> rmw_create_wait_set(
    ffi.Pointer<rmw_context_t> context,
    int max_conditions,
  ) {
    return _rmw_create_wait_set(
      context,
      max_conditions,
    );
  }

  late final _rmw_create_wait_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_wait_set_t> Function(
              ffi.Pointer<rmw_context_t>, ffi.Size)>>('rmw_create_wait_set');
  late final _rmw_create_wait_set = _rmw_create_wait_setPtr.asFunction<
      ffi.Pointer<rmw_wait_set_t> Function(ffi.Pointer<rmw_context_t>, int)>();

  /// Destroy a wait set.
  /// /**
  ///  * This function will reclaim all associated resources, including the wait set.
  ///  * Use of a wait set after destruction is undefined behavior.
  ///  * This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  ///  * or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given wait set unchanged.
  ///  * Otherwise, it will proceed despite errors.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \pre Given `wait_set` must be a valid wait set, as returned by rmw_create_wait_set().
  ///  *
  ///  * \param[in] wait_set Wait set to be finalized.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `wait_set` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `wait_set` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_destroy_wait_set(
    ffi.Pointer<rmw_wait_set_t> wait_set,
  ) {
    return _rmw_destroy_wait_set(
      wait_set,
    );
  }

  late final _rmw_destroy_wait_setPtr = _lookup<
          ffi.NativeFunction<rmw_ret_t Function(ffi.Pointer<rmw_wait_set_t>)>>(
      'rmw_destroy_wait_set');
  late final _rmw_destroy_wait_set = _rmw_destroy_wait_setPtr
      .asFunction<int Function(ffi.Pointer<rmw_wait_set_t>)>();

  /// Waits on sets of different entities and returns when one is ready.
  /// /**
  ///  * This function adds middleware-specific conditions to the wait set and waits
  ///  * until one or more become ready, or until the timeout is reached.
  ///  *
  ///  * \remark Elapsed time should be measured using a monotonic clock,
  ///  *   though rmw implementations could use a different one.
  ///  *   Timeout granularity is thus bound to that of the clock used by the underlying implementation,
  ///  *   and to the platform-specific APIs used to sleep and/or wait.
  ///  *
  ///  * \remark
  ///  *   The amount of time this function actually waits may be either above or
  ///  *   below the specified timeout.
  ///  *
  ///  * Arrays contain type-erased, middleware-specific conditions associated with
  ///  * waitable entities, which this function casts and adds to the wait set.
  ///  * `NULL` entries in arrays prior to wait are considered invalid.
  ///  * When the wait is over, entries in each array that correspond to
  ///  * conditions that were \b not triggered are set to `NULL`.
  ///  *
  ///  * \remark Arrays' memory management is external to this function.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \par Thread-safety
  ///  *   To wait is a reentrant procedure, but:
  ///  *   - It is not safe to use the same wait set to wait in two or more threads concurrently.
  ///  *   - It is not safe to wait for the same entity using different wait sets in two or
  ///  *     more threads concurrently.
  ///  *   - Access to the given timeout is read-only but it is not synchronized.
  ///  *     Concurrent `wait_timeout` reads are safe, but concurrent reads and writes are not.
  ///  *
  ///  * \pre Given `wait_set` must be a valid wait set, as returned by rmw_create_wait_set().
  ///  * \pre All given entities must be associated with nodes that, in turn, were registered
  ///  *   with the same context the given `wait_set` was registered with on creation.
  ///  *
  ///  * \param[inout] subscriptions Array of subscriptions to wait on.
  ///  *   Can be `NULL` if there are no subscriptions to wait on.
  ///  * \param[inout] guard_conditions Array of guard conditions to wait on
  ///  *   Can be `NULL` if there are no guard conditions to wait on.
  ///  * \param[inout] services Array of services to wait on.
  ///  *   Can be `NULL` if there are no services to wait on.
  ///  * \param[inout] clients Array of clients to wait on.
  ///  *   Can be `NULL` if there are no clients to wait on.
  ///  * \param[inout] events Array of events to wait on.
  ///  *   Can be `NULL` if there are no events to wait on.
  ///  * \param[in] wait_set Wait set to use for waiting.
  ///  * \param[in] wait_timeout If `NULL`, block indefinitely until an entity becomes ready.
  ///  *   If zero, do not block -- check only for immediately available entities.
  ///  *   Else, this represents the maximum amount of time to wait for an entity to become ready.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_TIMEOUT` if wait timed out, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `wait_set` is `NULL`, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if an array entry is `NULL`, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `wait_set` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_wait(
    ffi.Pointer<rmw_subscriptions_t> subscriptions,
    ffi.Pointer<rmw_guard_conditions_t> guard_conditions,
    ffi.Pointer<rmw_services_t> services,
    ffi.Pointer<rmw_clients_t> clients,
    ffi.Pointer<rmw_events_t> events,
    ffi.Pointer<rmw_wait_set_t> wait_set,
    ffi.Pointer<rmw_time_t> wait_timeout,
  ) {
    return _rmw_wait(
      subscriptions,
      guard_conditions,
      services,
      clients,
      events,
      wait_set,
      wait_timeout,
    );
  }

  late final _rmw_waitPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<rmw_subscriptions_t>,
              ffi.Pointer<rmw_guard_conditions_t>,
              ffi.Pointer<rmw_services_t>,
              ffi.Pointer<rmw_clients_t>,
              ffi.Pointer<rmw_events_t>,
              ffi.Pointer<rmw_wait_set_t>,
              ffi.Pointer<rmw_time_t>)>>('rmw_wait');
  late final _rmw_wait = _rmw_waitPtr.asFunction<
      int Function(
          ffi.Pointer<rmw_subscriptions_t>,
          ffi.Pointer<rmw_guard_conditions_t>,
          ffi.Pointer<rmw_services_t>,
          ffi.Pointer<rmw_clients_t>,
          ffi.Pointer<rmw_events_t>,
          ffi.Pointer<rmw_wait_set_t>,
          ffi.Pointer<rmw_time_t>)>();

  /// Return the name and namespace of all nodes in the ROS graph.
  /// /**
  ///  * This function will return an array of node names and an array of node namespaces,
  ///  * as discovered so far by the given node.
  ///  * The two arrays represent name and namespace pairs for each discovered node.
  ///  * Both arrays will be the same length and the same index will refer to the same node.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To query the ROS graph is a synchronous operation.
  ///  *   It is also non-blocking, but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Thread-safety
  ///  *   Nodes are thread-safe objects, and so are all operations on them except for finalization.
  ///  *   Therefore, it is safe to query the ROS graph using the same node concurrently.
  ///  *   However, access to string arrays is not synchronized.
  ///  *   It is not safe to read or write `node_names` nor `node_namespaces`
  ///  *   while rmw_get_node_names() uses them.
  ///  *
  ///  * \pre Given `node` must be a valid node handle, as returned by rmw_create_node().
  ///  * \pre Given `node_names` must be a valid string array, zero-initialized
  ///  *   as returned by rcutils_get_zero_initialized_string_array().
  ///  * \pre Given `node_namespaces` must be a valid string array, zero-initialized
  ///  *   as returned by rcutils_get_zero_initialized_string_array().
  ///  * \post Given `node_names` and `node_namespaces` will remain valid arrays.
  ///  *   These will be left unchanged if this function fails early due to a logical error,
  ///  *   such as an invalid argument, or in an unknown yet valid state if it fails due to
  ///  *   a runtime error.
  ///  *
  ///  * \param[in] node Node to query the ROS graph.
  ///  * \param[out] node_names Array of discovered node names, populated on success.
  ///  *   It is up to the caller to finalize this array later on, using rcutils_string_array_fini().
  ///  * \param[out] node_namespaces Array of discovered node namespaces, populated on success.
  ///  *   It is up to the caller to finalize this array later on, using rcutils_string_array_fini().
  ///  * \return `RMW_RET_OK` if the query was successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node_names` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node_names` is not a zero-initialized array, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is not a zero-initialized array, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_get_node_names(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rcutils_string_array_t> node_names,
    ffi.Pointer<rcutils_string_array_t> node_namespaces,
  ) {
    return _rmw_get_node_names(
      node,
      node_names,
      node_namespaces,
    );
  }

  late final _rmw_get_node_namesPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(
              ffi.Pointer<rmw_node_t>,
              ffi.Pointer<rcutils_string_array_t>,
              ffi.Pointer<rcutils_string_array_t>)>>('rmw_get_node_names');
  late final _rmw_get_node_names = _rmw_get_node_namesPtr.asFunction<
      int Function(ffi.Pointer<rmw_node_t>, ffi.Pointer<rcutils_string_array_t>,
          ffi.Pointer<rcutils_string_array_t>)>();

  /// Return the name, namespae, and enclave name of all nodes in the ROS graph.
  /// /**
  ///  * This is similar to rmw_get_node_names(), but it also provides enclave names.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To query the ROS graph is a synchronous operation.
  ///  *   It is also non-blocking, but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Thread-safety
  ///  *   Nodes are thread-safe objects, and so are all operations on them except for finalization.
  ///  *   Therefore, it is safe to query the ROS graph using the same node concurrently.
  ///  *   However, access to string arrays is not synchronized.
  ///  *   It is not safe to read or write `node_names`, `node_namespaces`, nor `enclaves`
  ///  *   while rmw_get_node_names_with_enclaves() uses them.
  ///  *
  ///  * \pre Given `node` must be a valid node handle, as returned by rmw_create_node().
  ///  * \pre Given `node_names` must be a valid string array, zero-initialized
  ///  *   as returned by rcutils_get_zero_initialized_string_array().
  ///  * \pre Given `node_namespaces` must be a valid string array, zero-initialized
  ///  *   as returned by rcutils_get_zero_initialized_string_array().
  ///  * \pre Given `enclaves` must be a zero-initialized string array,
  ///  *   as returned by rcutils_get_zero_initialized_string_array().
  ///  * \post Given `node_names`, `node_namespaces`, and `enclaves` will remain valid arrays.
  ///  *   These will be left unchanged if this function fails early due to a logical error,
  ///  *   such as an invalid argument, or in an unknown yet valid state if it fails due to
  ///  *   a runtime error.
  ///  *
  ///  * \param[in] node Node to query the ROS graph.
  ///  * \param[out] node_names Array of discovered node names, populated on success.
  ///  *   It is up to the caller to finalize this array later on, using rcutils_string_array_fini().
  ///  * \param[out] node_namespaces Array of discovered node namespaces, populated on success.
  ///  *   It is up to the caller to finalize this array later on, using rcutils_string_array_fini().
  ///  * \param[out] enclaves Array of discovered node enclave names, populated on success.
  ///  *   It is up to the caller to finalize this array later on, using rcutils_string_array_fini().
  ///  * \return `RMW_RET_OK` if the query was successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node_names` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node_names` is not a zero-initialized array, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is not a zero-initialized array, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `enclaves` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `enclaves` is not a zero-initialized array, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_get_node_names_with_enclaves(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rcutils_string_array_t> node_names,
    ffi.Pointer<rcutils_string_array_t> node_namespaces,
    ffi.Pointer<rcutils_string_array_t> enclaves,
  ) {
    return _rmw_get_node_names_with_enclaves(
      node,
      node_names,
      node_namespaces,
      enclaves,
    );
  }

  late final _rmw_get_node_names_with_enclavesPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(
                  ffi.Pointer<rmw_node_t>,
                  ffi.Pointer<rcutils_string_array_t>,
                  ffi.Pointer<rcutils_string_array_t>,
                  ffi.Pointer<rcutils_string_array_t>)>>(
      'rmw_get_node_names_with_enclaves');
  late final _rmw_get_node_names_with_enclaves =
      _rmw_get_node_names_with_enclavesPtr.asFunction<
          int Function(
              ffi.Pointer<rmw_node_t>,
              ffi.Pointer<rcutils_string_array_t>,
              ffi.Pointer<rcutils_string_array_t>,
              ffi.Pointer<rcutils_string_array_t>)>();

  /// Count the number of known publishers matching a topic name.
  /// /**
  ///  * This function returns the numbers of publishers of a given topic in the ROS graph,
  ///  * as discovered so far by the given node.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To query the ROS graph is a synchronous operation.
  ///  *   It is also non-blocking, but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Thread-safety
  ///  *   Nodes are thread-safe objects, and so are all operations on them except for finalization.
  ///  *   Therefore, it is safe to query the ROS graph using the same node concurrently.
  ///  *   However, access to primitive data-type arguments is not synchronized.
  ///  *   It is not safe to read or write `topic_name` or `count` while rmw_count_publishers()
  ///  *   uses them.
  ///  *
  ///  * \pre Given `node` must be a valid node handle, as returned by rmw_create_node().
  ///  *
  ///  * \param[in] node Handle to node to use to query the ROS graph.
  ///  * \param[in] topic_name Fully qualified ROS topic name.
  ///  * \param[out] count Number of publishers matching the given topic name.
  ///  * \return `RMW_RET_OK` if the query was successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is not a fully qualified topic name,
  ///  *   by rmw_validate_full_topic_name() definition, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_count_publishers(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<ffi.Char> topic_name,
    ffi.Pointer<ffi.Size> count,
  ) {
    return _rmw_count_publishers(
      node,
      topic_name,
      count,
    );
  }

  late final _rmw_count_publishersPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_node_t>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Size>)>>('rmw_count_publishers');
  late final _rmw_count_publishers = _rmw_count_publishersPtr.asFunction<
      int Function(ffi.Pointer<rmw_node_t>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Size>)>();

  /// Count the number of known subscribers matching a topic name.
  /// /**
  ///  * This function returns the numbers of subscribers of a given topic in the ROS graph,
  ///  * as discovered so far by the given node.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] implementation defined, check the implementation documentation</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To query the ROS graph is a synchronous operation.
  ///  *   It is also non-blocking, but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \par Thread-safety
  ///  *   Nodes are thread-safe objects, and so are all operations on them except for finalization.
  ///  *   Therefore, it is to query the ROS graph using the same node concurrently.
  ///  *   However, access to primitive data-type arguments is not synchronized.
  ///  *   It is not safe to read or write `topic_name` or `count` while rmw_count_subscribers()
  ///  *   uses them.
  ///  *
  ///  * \pre Given `node` must be a valid node handle, as returned by rmw_create_node().
  ///  *
  ///  * \param[in] node Handle to node to use to query the ROS graph.
  ///  * \param[in] topic_name Fully qualified ROS topic name.
  ///  * \param[out] count Number of subscribers matching the given topic name.
  ///  * \return `RMW_RET_OK` if the query was successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is not a fully qualified topic name,
  ///  *   by rmw_validate_full_topic_name() definition, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_count_subscribers(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<ffi.Char> topic_name,
    ffi.Pointer<ffi.Size> count,
  ) {
    return _rmw_count_subscribers(
      node,
      topic_name,
      count,
    );
  }

  late final _rmw_count_subscribersPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_node_t>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Size>)>>('rmw_count_subscribers');
  late final _rmw_count_subscribers = _rmw_count_subscribersPtr.asFunction<
      int Function(ffi.Pointer<rmw_node_t>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Size>)>();

  /// Get the unique identifier (gid) of a publisher.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Thread-safety
  ///  *   Publishers are thread-safe objects, and so are all operations on them except for
  ///  *   finalization.
  ///  *   Therefore, it is safe to get the unique identifier from the same publisher concurrently.
  ///  *   However, access to the gid is not synchronized.
  ///  *   It is not safe to read or write `gid` while rmw_get_gid_for_publisher() uses it.
  ///  *
  ///  * \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  ///  *
  ///  * \param[in] publisher Publisher to get a gid from.
  ///  * \param[out] gid Publisher's unique identifier, populated on success
  ///  *   but left unchanged on failure.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `gid` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `publisher` implementation
  ///  *   identifier does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_get_gid_for_publisher(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rmw_gid_t> gid,
  ) {
    return _rmw_get_gid_for_publisher(
      publisher,
      gid,
    );
  }

  late final _rmw_get_gid_for_publisherPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_publisher_t>,
              ffi.Pointer<rmw_gid_t>)>>('rmw_get_gid_for_publisher');
  late final _rmw_get_gid_for_publisher =
      _rmw_get_gid_for_publisherPtr.asFunction<
          int Function(ffi.Pointer<rmw_publisher_t>, ffi.Pointer<rmw_gid_t>)>();

  /// Check if two unique identifiers (gids) are equal.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Thread-safety
  ///  *   Unique identifier comparison is a reentrant function, but:
  ///  *   - Access to both gids is read-only but it is not synchronized.
  ///  *     Concurrent `gid1` and `gid2` reads are safe, but concurrent reads and writes are not.
  ///  *   - Access to primitive data-type arguments is not synchronized.
  ///  *     It is not safe to read or write `result` while rmw_compare_gids_equal() uses it.
  ///  *
  ///  * \param[in] gid1 First unique identifier to compare.
  ///  * \param[in] gid2 Second unique identifier to compare.
  ///  * \param[out] result true if both gids are equal, false otherwise.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `gid1` or `gid2` is NULL, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  ///  *   identifier of `gid1` or `gid2` does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_compare_gids_equal(
    ffi.Pointer<rmw_gid_t> gid1,
    ffi.Pointer<rmw_gid_t> gid2,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _rmw_compare_gids_equal(
      gid1,
      gid2,
      result,
    );
  }

  late final _rmw_compare_gids_equalPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_gid_t>, ffi.Pointer<rmw_gid_t>,
              ffi.Pointer<ffi.Bool>)>>('rmw_compare_gids_equal');
  late final _rmw_compare_gids_equal = _rmw_compare_gids_equalPtr.asFunction<
      int Function(ffi.Pointer<rmw_gid_t>, ffi.Pointer<rmw_gid_t>,
          ffi.Pointer<ffi.Bool>)>();

  /// Check if a service server is available for the given service client.
  /// /**
  ///  * This function checks whether one or more service services matching the
  ///  * given service client exist in the ROS graph, as discovered so far by the
  ///  * given local node.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  *
  ///  * <i>[1] implementation defined, check implementation documentation.</i>
  ///  *
  ///  * \par Runtime behavior
  ///  *   To query the ROS graph is a synchronous operation.
  ///  *   It is also non-blocking, but it is not guaranteed to be lock-free.
  ///  *   Generally speaking, implementations may synchronize access to internal resources using
  ///  *   locks but are not allowed to wait for events with no guaranteed time bound (barring
  ///  *   the effects of starvation due to OS scheduling).
  ///  *
  ///  * \pre Given `node` must be a valid node, as returned by rmw_create_node().
  ///  * \pre Given `client` must be a valid client, as returned by rmw_create_client().
  ///  * \pre Given `node` must be the one the `client` was registered with.
  ///  *
  ///  * \param[in] node Node to query the ROS graph.
  ///  * \param[in] client Service client to look for matching service servers.
  ///  * \param[out] is_available True if there is a service server available, else false.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `client` is `NULL`, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `is_available` is `NULL`, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  ///  *   identifier of `node` or `client` does not match this implementation, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_service_server_is_available(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_client_t> client,
    ffi.Pointer<ffi.Bool> is_available,
  ) {
    return _rmw_service_server_is_available(
      node,
      client,
      is_available,
    );
  }

  late final _rmw_service_server_is_availablePtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_node_t>, ffi.Pointer<rmw_client_t>,
              ffi.Pointer<ffi.Bool>)>>('rmw_service_server_is_available');
  late final _rmw_service_server_is_available =
      _rmw_service_server_is_availablePtr.asFunction<
          int Function(ffi.Pointer<rmw_node_t>, ffi.Pointer<rmw_client_t>,
              ffi.Pointer<ffi.Bool>)>();

  /// Set the current log severity
  /// /**
  ///  * \param[in] severity The log severity to set
  ///  * \return RMW_RET_OK if successful, otherwise an appropriate error code
  ///  */
  int rmw_set_log_severity(
    int severity,
  ) {
    return _rmw_set_log_severity(
      severity,
    );
  }

  late final _rmw_set_log_severityPtr =
      _lookup<ffi.NativeFunction<rmw_ret_t Function(ffi.Int32)>>(
          'rmw_set_log_severity');
  late final _rmw_set_log_severity =
      _rmw_set_log_severityPtr.asFunction<int Function(int)>();

  /// Set the on new message callback function for the subscription.
  /// /**
  ///  * This API sets the callback function to be called whenever the
  ///  * subscription is notified about a new message.
  ///  *
  ///  * This callback is called for each new message received by the subscription.
  ///  * If messages arrive before the callback is registered, the number_of_events
  ///  * argument given to the callback may be > 1.
  ///  *
  ///  * The callback may be called from a thread that the rmw implementation
  ///  * created, rather than a thread owned by the user, i.e. some thread other
  ///  * than user owned threads calling rmw functions such as rmw_wait() or
  ///  * rmw_publish().
  ///  *
  ///  * This function is thread-safe.
  ///  * This is required of the rmw implementation because the callback may be called
  ///  * from any middleware thread, and this function could be called by the user
  ///  * at any time.
  ///  *
  ///  * \param[in] subscription The subscription on which to set the callback
  ///  * \param[in] callback The callback to be called when new messages arrive,
  ///  *   can be NULL to clear the registered callback
  ///  * \param[in] user_data Given to the callback when called later, may be NULL
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the API is not implemented in the dds implementation
  ///  */
  int rmw_subscription_set_on_new_message_callback(
    ffi.Pointer<rmw_subscription_t> subscription,
    rmw_event_callback_t callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rmw_subscription_set_on_new_message_callback(
      subscription,
      callback,
      user_data,
    );
  }

  late final _rmw_subscription_set_on_new_message_callbackPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_subscription_t>,
                  rmw_event_callback_t, ffi.Pointer<ffi.Void>)>>(
      'rmw_subscription_set_on_new_message_callback');
  late final _rmw_subscription_set_on_new_message_callback =
      _rmw_subscription_set_on_new_message_callbackPtr.asFunction<
          int Function(ffi.Pointer<rmw_subscription_t>, rmw_event_callback_t,
              ffi.Pointer<ffi.Void>)>();

  /// Set the on new request callback function for the service.
  /// /**
  ///  * This API sets the callback function to be called whenever the
  ///  * service is notified about a new request.
  ///  *
  ///  * This callback is called for each new request received by the service.
  ///  * If requests arrive before the callback is registered, the number_of_events
  ///  * argument given to the callback may be > 1.
  ///  *
  ///  * The callback may be called from a thread that the rmw implementation
  ///  * created, rather than a thread owned by the user, i.e. some thread other
  ///  * than user owned threads calling rmw functions such as rmw_wait() or
  ///  * rmw_send_request().
  ///  *
  ///  * This function is thread-safe.
  ///  * This is required of the rmw implementation because the callback may be called
  ///  * from any middleware thread, and this function could be called by the user
  ///  * at any time.
  ///  *
  ///  * \param[in] service The service on which to set the callback
  ///  * \param[in] callback The callback to be called when new requests arrive,
  ///  *   can be NULL to clear the registered callback
  ///  * \param[in] user_data Given to the callback when called later, may be NULL
  ///  * \return `RMW_RET_OK` if callback was set to the listener, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the API is not implemented in the dds implementation
  ///  */
  int rmw_service_set_on_new_request_callback(
    ffi.Pointer<rmw_service_t> service,
    rmw_event_callback_t callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rmw_service_set_on_new_request_callback(
      service,
      callback,
      user_data,
    );
  }

  late final _rmw_service_set_on_new_request_callbackPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_service_t>,
                  rmw_event_callback_t, ffi.Pointer<ffi.Void>)>>(
      'rmw_service_set_on_new_request_callback');
  late final _rmw_service_set_on_new_request_callback =
      _rmw_service_set_on_new_request_callbackPtr.asFunction<
          int Function(ffi.Pointer<rmw_service_t>, rmw_event_callback_t,
              ffi.Pointer<ffi.Void>)>();

  /// Set the on new response callback function for the client.
  /// /**
  ///  * This API sets the callback function to be called whenever the
  ///  * client is notified about a new response.
  ///  *
  ///  * This callback is called for each new response received by the client.
  ///  * If responses arrive before the callback is registered, the number_of_events
  ///  * argument given to the callback may be > 1.
  ///  *
  ///  * The callback may be called from a thread that the rmw implementation
  ///  * created, rather than a thread owned by the user, i.e. some thread other
  ///  * than user owned threads calling rmw functions such as rmw_wait() or
  ///  * rmw_take_response().
  ///  *
  ///  * This function is thread-safe.
  ///  * This is required of the rmw implementation because the callback may be called
  ///  * from any middleware thread, and this function could be called by the user
  ///  * at any time.
  ///  *
  ///  * \param[in] client The client on which to set the callback
  ///  * \param[in] callback The callback to be called when new responses arrive,
  ///  *   can be NULL to clear the registered callback
  ///  * \param[in] user_data Given to the callback when called later, may be NULL
  ///  * \return `RMW_RET_OK` if callback was set to the listener, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the API is not implemented in the dds implementation
  ///  */
  int rmw_client_set_on_new_response_callback(
    ffi.Pointer<rmw_client_t> client,
    rmw_event_callback_t callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rmw_client_set_on_new_response_callback(
      client,
      callback,
      user_data,
    );
  }

  late final _rmw_client_set_on_new_response_callbackPtr = _lookup<
          ffi.NativeFunction<
              rmw_ret_t Function(ffi.Pointer<rmw_client_t>,
                  rmw_event_callback_t, ffi.Pointer<ffi.Void>)>>(
      'rmw_client_set_on_new_response_callback');
  late final _rmw_client_set_on_new_response_callback =
      _rmw_client_set_on_new_response_callbackPtr.asFunction<
          int Function(ffi.Pointer<rmw_client_t>, rmw_event_callback_t,
              ffi.Pointer<ffi.Void>)>();

  /// Set the callback function for the event.
  /// /**
  ///  * This API sets the callback function to be called whenever the
  ///  * event is notified about a new instance of the event.
  ///  *
  ///  * For example, this could be called when incompatible QoS is detected, or
  ///  * a deadline is missed, or any other QoS event.
  ///  *
  ///  * This callback is called for each new event that occurs for this rmw_event_t
  ///  * instance.
  ///  * If events occur before the callback is registered, the number_of_events
  ///  * argument given to the callback may be > 1.
  ///  *
  ///  * The callback may be called from a thread that the rmw implementation
  ///  * created, rather than a thread owned by the user, i.e. some thread other
  ///  * than user owned threads calling rmw functions such as rmw_wait() or
  ///  * rmw_publish().
  ///  *
  ///  * This function is thread-safe.
  ///  * This is required of the rmw implementation because the callback may be called
  ///  * from any middleware thread, and this function could be called by the user
  ///  * at any time.
  ///  *
  ///  * \param[in] event The event on which to set the callback
  ///  * \param[in] callback The callback to be called when new events occur,
  ///  *   can be NULL to clear the registered callback
  ///  * \param[in] user_data Given to the callback when called later, may be NULL
  ///  * \return `RMW_RET_OK` if callback was set to the listener, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if `event` is NULL, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the API is not implemented in the dds implementation
  ///  */
  int rmw_event_set_callback(
    ffi.Pointer<rmw_event_t> event,
    rmw_event_callback_t callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rmw_event_set_callback(
      event,
      callback,
      user_data,
    );
  }

  late final _rmw_event_set_callbackPtr = _lookup<
      ffi.NativeFunction<
          rmw_ret_t Function(ffi.Pointer<rmw_event_t>, rmw_event_callback_t,
              ffi.Pointer<ffi.Void>)>>('rmw_event_set_callback');
  late final _rmw_event_set_callback = _rmw_event_set_callbackPtr.asFunction<
      int Function(ffi.Pointer<rmw_event_t>, rmw_event_callback_t,
          ffi.Pointer<ffi.Void>)>();

  /// Return a zero initialized timer.
  rcl_timer_t rcl_get_zero_initialized_timer() {
    return _rcl_get_zero_initialized_timer();
  }

  late final _rcl_get_zero_initialized_timerPtr =
      _lookup<ffi.NativeFunction<rcl_timer_t Function()>>(
          'rcl_get_zero_initialized_timer');
  late final _rcl_get_zero_initialized_timer =
      _rcl_get_zero_initialized_timerPtr.asFunction<rcl_timer_t Function()>();

  /// Initialize a timer.
  /// /**
  ///  * A timer consists of a clock, a callback function and a period.
  ///  * A timer can be added to a wait set and waited on, such that the wait set
  ///  * will wake up when a timer is ready to be executed.
  ///  *
  ///  * A timer simply holds state and does not automatically call callbacks.
  ///  * It does not create any threads, register interrupts, or consume signals.
  ///  * For blocking behavior it can be used in conjunction with a wait set and
  ///  * rcl_wait().
  ///  * When rcl_timer_is_ready() returns true, the timer must still be called
  ///  * explicitly using rcl_timer_call().
  ///  *
  ///  * The timer handle must be a pointer to an allocated and zero initialized
  ///  * rcl_timer_t struct.
  ///  * Calling this function on an already initialized timer will fail.
  ///  * Calling this function on a timer struct which has been allocated but not
  ///  * zero initialized is undefined behavior.
  ///  *
  ///  * The clock handle must be a pointer to an initialized rcl_clock_t struct.
  ///  * The life time of the clock must exceed the life time of the timer.
  ///  *
  ///  * The period is a non-negative duration (rather an absolute time in the
  ///  * future).
  ///  * If the period is `0` then it will always be ready.
  ///  *
  ///  * The callback is an optional argument.
  ///  * Valid inputs are either a pointer to the function callback, or `NULL` to
  ///  * indicate that no callback will be stored in rcl.
  ///  * If the callback is `NULL`, the caller client library is responsible for
  ///  * firing the timer callback.
  ///  * Else, it must be a function which returns void and takes two arguments,
  ///  * the first being a pointer to the associated timer, and the second a int64_t
  ///  * which is the time since the previous call, or since the timer was created
  ///  * if it is the first call to the callback.
  ///  *
  ///  * Expected usage:
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  *
  ///  * void my_timer_callback(rcl_timer_t * timer, int64_t last_call_time)
  ///  * {
  ///  *   // Do timer work...
  ///  *   // Optionally reconfigure, cancel, or reset the timer...
  ///  * }
  ///  *
  ///  * rcl_context_t * context;  // initialized previously by rcl_init()...
  ///  * rcl_clock_t clock;
  ///  * rcl_allocator_t allocator = rcl_get_default_allocator();
  ///  * rcl_ret_t ret = rcl_clock_init(RCL_STEADY_TIME, &clock, &allocator);
  ///  * // ... error handling
  ///  *
  ///  * rcl_timer_t timer = rcl_get_zero_initialized_timer();
  ///  * ret = rcl_timer_init(
  ///  *   &timer, &clock, context, RCL_MS_TO_NS(100), my_timer_callback, allocator);
  ///  * // ... error handling, use the timer with a wait set, or poll it manually, then cleanup
  ///  * ret = rcl_timer_fini(&timer);
  ///  * // ... error handling
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1][2][3]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`</i>
  ///  *
  ///  * <i>[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * <i>[3] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>
  ///  *
  ///  * \param[inout] timer the timer handle to be initialized
  ///  * \param[in] clock the clock providing the current time
  ///  * \param[in] context the context that this timer is to be associated with
  ///  * \param[in] period the duration between calls to the callback in nanoseconds
  ///  * \param[in] callback the user defined function to be called every period
  ///  * \param[in] allocator the allocator to use for allocations
  ///  * \return #RCL_RET_OK if the timer was initialized successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_ALREADY_INIT if the timer was already initialized, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_timer_init(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcl_context_t> context,
    int period,
    rcl_timer_callback_t callback,
    rcl_allocator_t allocator,
  ) {
    return _rcl_timer_init(
      timer,
      clock,
      context,
      period,
      callback,
      allocator,
    );
  }

  late final _rcl_timer_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_timer_t>,
              ffi.Pointer<rcl_clock_t>,
              ffi.Pointer<rcl_context_t>,
              ffi.Int64,
              rcl_timer_callback_t,
              rcl_allocator_t)>>('rcl_timer_init');
  late final _rcl_timer_init = _rcl_timer_initPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_timer_t>,
          ffi.Pointer<rcl_clock_t>,
          ffi.Pointer<rcl_context_t>,
          int,
          rcl_timer_callback_t,
          rcl_allocator_t)>();

  /// Finalize a timer.
  /// /**
  ///  * This function will deallocate any memory and make the timer invalid.
  ///  *
  ///  * A timer that is already invalid (zero initialized) or `NULL` will not fail.
  ///  *
  ///  * This function is not thread-safe with any rcl_timer_* functions used on the
  ///  * same timer object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1][2][3]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`</i>
  ///  *
  ///  * <i>[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * <i>[3] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>
  ///  *
  ///  * \param[inout] timer the handle to the timer to be finalized.
  ///  * \return #RCL_RET_OK if the timer was finalized successfully, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_timer_fini(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_fini(
      timer,
    );
  }

  late final _rcl_timer_finiPtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_timer_t>)>>(
          'rcl_timer_fini');
  late final _rcl_timer_fini =
      _rcl_timer_finiPtr.asFunction<int Function(ffi.Pointer<rcl_timer_t>)>();

  /// Call the timer's callback and set the last call time.
  /// /**
  ///  * This function will call the callback and change the last call time even if
  ///  * the timer's period has not yet elapsed.
  ///  * It is up to the calling code to make sure the period has elapsed by first
  ///  * calling rcl_timer_is_ready().
  ///  * If the callback pointer is `NULL` (either set in init or exchanged after
  ///  * initialized), no callback is fired.
  ///  * However, this function should still be called by the client library to
  ///  * update the state of the timer.
  ///  * The order of operations in this command are as follows:
  ///  *
  ///  *  - Ensure the timer has not been canceled.
  ///  *  - Get the current time into a temporary rcl_steady_time_point_t.
  ///  *  - Exchange the current time with the last call time of the timer.
  ///  *  - Call the callback, passing this timer and the time since the last call.
  ///  *  - Return after the callback has completed.
  ///  *
  ///  * During the callback the timer can be canceled or have its period and/or
  ///  * callback modified.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [2]
  ///  * <i>[1] user callback might not be thread-safe</i>
  ///  *
  ///  * <i>[2] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[inout] timer the handle to the timer to call
  ///  * \return #RCL_RET_OK if the timer was called successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or
  ///  * \return #RCL_RET_TIMER_CANCELED if the timer has been canceled, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_timer_call(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_call(
      timer,
    );
  }

  late final _rcl_timer_callPtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_timer_t>)>>(
          'rcl_timer_call');
  late final _rcl_timer_call =
      _rcl_timer_callPtr.asFunction<int Function(ffi.Pointer<rcl_timer_t>)>();

  /// Retrieve the clock of the timer.
  /// /**
  ///  * This function retrieves the clock pointer and copies it into the given variable.
  ///  *
  ///  * The clock argument must be a pointer to an already allocated rcl_clock_t *.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] timer the handle to the timer which is being queried
  ///  * \param[out] clock the rcl_clock_t * in which the clock is stored
  ///  * \return #RCL_RET_OK if the clock was retrieved successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_TIMER_INVALID if the timer is invalid.
  ///  */
  int rcl_timer_clock(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Pointer<rcl_clock_t>> clock,
  ) {
    return _rcl_timer_clock(
      timer,
      clock,
    );
  }

  late final _rcl_timer_clockPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_timer_t>,
              ffi.Pointer<ffi.Pointer<rcl_clock_t>>)>>('rcl_timer_clock');
  late final _rcl_timer_clock = _rcl_timer_clockPtr.asFunction<
      int Function(
          ffi.Pointer<rcl_timer_t>, ffi.Pointer<ffi.Pointer<rcl_clock_t>>)>();

  /// Calculates whether or not the timer should be called.
  /// /**
  ///  * The result is true if the time until next call is less than, or equal to, 0
  ///  * and the timer has not been canceled.
  ///  * Otherwise the result is false, indicating the timer should not be called.
  ///  *
  ///  * The is_ready argument must point to an allocated bool object, as the result
  ///  * is copied into it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer the handle to the timer which is being checked
  ///  * \param[out] is_ready the bool used to store the result of the calculation
  ///  * \return #RCL_RET_OK if the last call time was retrieved successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_timer_is_ready(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Bool> is_ready,
  ) {
    return _rcl_timer_is_ready(
      timer,
      is_ready,
    );
  }

  late final _rcl_timer_is_readyPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_timer_t>,
              ffi.Pointer<ffi.Bool>)>>('rcl_timer_is_ready');
  late final _rcl_timer_is_ready = _rcl_timer_is_readyPtr.asFunction<
      int Function(ffi.Pointer<rcl_timer_t>, ffi.Pointer<ffi.Bool>)>();

  /// Calculate and retrieve the time until the next call in nanoseconds.
  /// /**
  ///  * This function calculates the time until the next call by adding the timer's
  ///  * period to the last call time and subtracting that sum from the current time.
  ///  * The calculated time until the next call can be positive, indicating that it
  ///  * is not ready to be called as the period has not elapsed since the last call.
  ///  * The calculated time until the next call can also be 0 or negative,
  ///  * indicating that the period has elapsed since the last call and the timer
  ///  * should be called.
  ///  * A negative value indicates the timer call is overdue by that amount.
  ///  *
  ///  * The `time_until_next_call` argument must point to an allocated int64_t, as
  ///  * the time until is copied into that instance.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer the handle to the timer that is being queried
  ///  * \param[out] time_until_next_call the output variable for the result
  ///  * \return #RCL_RET_OK if the timer until next call was successfully calculated, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or
  ///  * \return #RCL_RET_TIMER_CANCELED if the timer is canceled, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_timer_get_time_until_next_call(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Int64> time_until_next_call,
  ) {
    return _rcl_timer_get_time_until_next_call(
      timer,
      time_until_next_call,
    );
  }

  late final _rcl_timer_get_time_until_next_callPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_timer_t>,
              ffi.Pointer<ffi.Int64>)>>('rcl_timer_get_time_until_next_call');
  late final _rcl_timer_get_time_until_next_call =
      _rcl_timer_get_time_until_next_callPtr.asFunction<
          int Function(ffi.Pointer<rcl_timer_t>, ffi.Pointer<ffi.Int64>)>();

  /// Retrieve the time since the previous call to rcl_timer_call() occurred.
  /// /**
  ///  * This function calculates the time since the last call and copies it into
  ///  * the given int64_t variable.
  ///  *
  ///  * Calling this function within a callback will not return the time since the
  ///  * previous call but instead the time since the current callback was called.
  ///  *
  ///  * The time_since_last_call argument must be a pointer to an already allocated
  ///  * int64_t.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer the handle to the timer which is being queried
  ///  * \param[out] time_since_last_call the struct in which the time is stored
  ///  * \return #RCL_RET_OK if the last call time was retrieved successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_timer_get_time_since_last_call(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Int64> time_since_last_call,
  ) {
    return _rcl_timer_get_time_since_last_call(
      timer,
      time_since_last_call,
    );
  }

  late final _rcl_timer_get_time_since_last_callPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_timer_t>,
              ffi.Pointer<ffi.Int64>)>>('rcl_timer_get_time_since_last_call');
  late final _rcl_timer_get_time_since_last_call =
      _rcl_timer_get_time_since_last_callPtr.asFunction<
          int Function(ffi.Pointer<rcl_timer_t>, ffi.Pointer<ffi.Int64>)>();

  /// Retrieve the period of the timer.
  /// /**
  ///  * This function retrieves the period and copies it into the given variable.
  ///  *
  ///  * The period argument must be a pointer to an already allocated int64_t.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer the handle to the timer which is being queried
  ///  * \param[out] period the int64_t in which the period is stored
  ///  * \return #RCL_RET_OK if the period was retrieved successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_timer_get_period(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Int64> period,
  ) {
    return _rcl_timer_get_period(
      timer,
      period,
    );
  }

  late final _rcl_timer_get_periodPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_timer_t>,
              ffi.Pointer<ffi.Int64>)>>('rcl_timer_get_period');
  late final _rcl_timer_get_period = _rcl_timer_get_periodPtr.asFunction<
      int Function(ffi.Pointer<rcl_timer_t>, ffi.Pointer<ffi.Int64>)>();

  /// Exchange the period of the timer and return the previous period.
  /// /**
  ///  * This function exchanges the period in the timer and copies the old one into
  ///  * the given variable.
  ///  *
  ///  * Exchanging (changing) the period will not affect already waiting wait sets.
  ///  *
  ///  * The old_period argument must be a pointer to an already allocated int64_t.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer the handle to the timer which is being modified
  ///  * \param[out] new_period the int64_t to exchange into the timer
  ///  * \param[out] old_period the int64_t in which the previous period is stored
  ///  * \return #RCL_RET_OK if the period was retrieved successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_timer_exchange_period(
    ffi.Pointer<rcl_timer_t> timer,
    int new_period,
    ffi.Pointer<ffi.Int64> old_period,
  ) {
    return _rcl_timer_exchange_period(
      timer,
      new_period,
      old_period,
    );
  }

  late final _rcl_timer_exchange_periodPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_timer_t>, ffi.Int64,
              ffi.Pointer<ffi.Int64>)>>('rcl_timer_exchange_period');
  late final _rcl_timer_exchange_period =
      _rcl_timer_exchange_periodPtr.asFunction<
          int Function(
              ffi.Pointer<rcl_timer_t>, int, ffi.Pointer<ffi.Int64>)>();

  /// Return the current timer callback.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - timer is `NULL`
  ///  *   - timer has not been initialized (the implementation is invalid)
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer handle to the timer from the callback should be returned
  ///  * \return function pointer to the callback, or `NULL` if an error occurred
  ///  */
  rcl_timer_callback_t rcl_timer_get_callback(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_get_callback(
      timer,
    );
  }

  late final _rcl_timer_get_callbackPtr = _lookup<
      ffi.NativeFunction<
          rcl_timer_callback_t Function(
              ffi.Pointer<rcl_timer_t>)>>('rcl_timer_get_callback');
  late final _rcl_timer_get_callback = _rcl_timer_get_callbackPtr
      .asFunction<rcl_timer_callback_t Function(ffi.Pointer<rcl_timer_t>)>();

  /// Exchange the current timer callback and return the current callback.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - timer is `NULL`
  ///  *   - timer has not been initialized (the implementation is invalid)
  ///  *
  ///  * This function can set callback to `NULL`, in which case the callback is
  ///  * ignored when rcl_timer_call is called.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[inout] timer handle to the timer from the callback should be exchanged
  ///  * \param[in] new_callback the callback to be exchanged into the timer
  ///  * \return function pointer to the old callback, or `NULL` if an error occurred
  ///  */
  rcl_timer_callback_t rcl_timer_exchange_callback(
    ffi.Pointer<rcl_timer_t> timer,
    rcl_timer_callback_t new_callback,
  ) {
    return _rcl_timer_exchange_callback(
      timer,
      new_callback,
    );
  }

  late final _rcl_timer_exchange_callbackPtr = _lookup<
      ffi.NativeFunction<
          rcl_timer_callback_t Function(ffi.Pointer<rcl_timer_t>,
              rcl_timer_callback_t)>>('rcl_timer_exchange_callback');
  late final _rcl_timer_exchange_callback =
      _rcl_timer_exchange_callbackPtr.asFunction<
          rcl_timer_callback_t Function(
              ffi.Pointer<rcl_timer_t>, rcl_timer_callback_t)>();

  /// Cancel a timer.
  /// /**
  ///  * When a timer is canceled, rcl_timer_is_ready() will return false for that
  ///  * timer, and rcl_timer_call() will fail with RCL_RET_TIMER_CANCELED.
  ///  *
  ///  * A canceled timer can be reset with rcl_timer_reset(), and then used again.
  ///  * Calling this function on an already canceled timer will succeed.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[inout] timer the timer to be canceled
  ///  * \return #RCL_RET_OK if the timer was canceled successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_TIMER_INVALID if the timer is invalid.
  ///  */
  int rcl_timer_cancel(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_cancel(
      timer,
    );
  }

  late final _rcl_timer_cancelPtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_timer_t>)>>(
          'rcl_timer_cancel');
  late final _rcl_timer_cancel =
      _rcl_timer_cancelPtr.asFunction<int Function(ffi.Pointer<rcl_timer_t>)>();

  /// Retrieve the canceled state of a timer.
  /// /**
  ///  * If the timer is canceled true will be stored in the is_canceled argument.
  ///  * Otherwise false will be stored in the is_canceled argument.
  ///  *
  ///  * The is_canceled argument must point to an allocated bool, as the result is
  ///  * copied into this variable.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>
  ///  *
  ///  * \param[in] timer the timer to be queried
  ///  * \param[out] is_canceled storage for the is canceled bool
  ///  * \return #RCL_RET_OK if the last call time was retrieved successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_TIMER_INVALID if the timer->impl is invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_timer_is_canceled(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Bool> is_canceled,
  ) {
    return _rcl_timer_is_canceled(
      timer,
      is_canceled,
    );
  }

  late final _rcl_timer_is_canceledPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_timer_t>,
              ffi.Pointer<ffi.Bool>)>>('rcl_timer_is_canceled');
  late final _rcl_timer_is_canceled = _rcl_timer_is_canceledPtr.asFunction<
      int Function(ffi.Pointer<rcl_timer_t>, ffi.Pointer<ffi.Bool>)>();

  /// Reset a timer.
  /// /**
  ///  * This function can be called on a timer, canceled or not.
  ///  * For all timers it will reset the last call time to now.
  ///  * For canceled timers it will additionally make the timer not canceled.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[inout] timer the timer to be reset
  ///  * \return #RCL_RET_OK if the timer was reset successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_TIMER_INVALID if the timer is invalid, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_timer_reset(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_reset(
      timer,
    );
  }

  late final _rcl_timer_resetPtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_timer_t>)>>(
          'rcl_timer_reset');
  late final _rcl_timer_reset =
      _rcl_timer_resetPtr.asFunction<int Function(ffi.Pointer<rcl_timer_t>)>();

  /// Return the allocator for the timer.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - timer is `NULL`
  ///  *   - timer has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned pointer is only valid as long as the timer object is valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] timer handle to the timer object
  ///  * \return pointer to the allocator, or `NULL` if an error occurred
  ///  */
  ffi.Pointer<rcl_allocator_t> rcl_timer_get_allocator(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_get_allocator(
      timer,
    );
  }

  late final _rcl_timer_get_allocatorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rcl_allocator_t> Function(
              ffi.Pointer<rcl_timer_t>)>>('rcl_timer_get_allocator');
  late final _rcl_timer_get_allocator = _rcl_timer_get_allocatorPtr.asFunction<
      ffi.Pointer<rcl_allocator_t> Function(ffi.Pointer<rcl_timer_t>)>();

  /// Retrieve a guard condition used by the timer to wake the waitset when using ROSTime.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] timer the timer to be queried
  ///  * \return `NULL` if the timer is invalid or does not have a guard condition, or
  ///  * \return a guard condition pointer.
  ///  */
  ffi.Pointer<rcl_guard_condition_t> rcl_timer_get_guard_condition(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_get_guard_condition(
      timer,
    );
  }

  late final _rcl_timer_get_guard_conditionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rcl_guard_condition_t> Function(
              ffi.Pointer<rcl_timer_t>)>>('rcl_timer_get_guard_condition');
  late final _rcl_timer_get_guard_condition =
      _rcl_timer_get_guard_conditionPtr.asFunction<
          ffi.Pointer<rcl_guard_condition_t> Function(
              ffi.Pointer<rcl_timer_t>)>();

  /// Return a rcl_event_t struct with members set to `NULL`.
  /// /**
  ///  * Should be called to get a null rcl_event_t before passing to
  ///  * rcl_event_init().
  ///  *
  ///  * \return Zero initialized rcl_event_t.
  ///  */
  rcl_event_t rcl_get_zero_initialized_event() {
    return _rcl_get_zero_initialized_event();
  }

  late final _rcl_get_zero_initialized_eventPtr =
      _lookup<ffi.NativeFunction<rcl_event_t Function()>>(
          'rcl_get_zero_initialized_event');
  late final _rcl_get_zero_initialized_event =
      _rcl_get_zero_initialized_eventPtr.asFunction<rcl_event_t Function()>();

  /// Initialize an rcl_event_t with a publisher.
  /// /**
  ///  * Fill the rcl_event_t with the publisher and desired event_type.
  ///  *
  ///  * \param[in,out] event pointer to fill
  ///  * \param[in] publisher to get events from
  ///  * \param[in] event_type to listen for
  ///  * \return #RCL_RET_OK if the rcl_event_t is filled, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory fails, or
  ///  * \return #RCL_RET_UNSUPPORTED if event_type is not supported, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_publisher_event_init(
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<rcl_publisher_t> publisher,
    int event_type,
  ) {
    return _rcl_publisher_event_init(
      event,
      publisher,
      event_type,
    );
  }

  late final _rcl_publisher_event_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_event_t>,
              ffi.Pointer<rcl_publisher_t>,
              ffi.Int32)>>('rcl_publisher_event_init');
  late final _rcl_publisher_event_init =
      _rcl_publisher_event_initPtr.asFunction<
          int Function(
              ffi.Pointer<rcl_event_t>, ffi.Pointer<rcl_publisher_t>, int)>();

  /// Initialize an rcl_event_t with a subscription.
  /// /**
  ///  * Fill the rcl_event_t with the subscription and desired event_type.
  ///  *
  ///  * \param[in,out] event pointer to fill
  ///  * \param[in] subscription to get events from
  ///  * \param[in] event_type to listen for
  ///  * \return #RCL_RET_OK if the rcl_event_t is filled, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory fails, or
  ///  * \return #RCL_RET_UNSUPPORTED if event_type is not supported, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_subscription_event_init(
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<rcl_subscription_t> subscription,
    int event_type,
  ) {
    return _rcl_subscription_event_init(
      event,
      subscription,
      event_type,
    );
  }

  late final _rcl_subscription_event_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_event_t>,
              ffi.Pointer<rcl_subscription_t>,
              ffi.Int32)>>('rcl_subscription_event_init');
  late final _rcl_subscription_event_init =
      _rcl_subscription_event_initPtr.asFunction<
          int Function(ffi.Pointer<rcl_event_t>,
              ffi.Pointer<rcl_subscription_t>, int)>();

  /// Take event using the event handle.
  /// /**
  ///  * Take an event from the event handle.
  ///  *
  ///  * \param[in] event event object to take from
  ///  * \param[in, out] event_info event info object to write taken data into
  ///  * \return #RCL_RET_OK if successful, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if memory allocation failed, or
  ///  * \return #RCL_RET_EVENT_TAKE_FAILED if the take event failed, or
  ///  * \return #RCL_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcl_take_event(
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<ffi.Void> event_info,
  ) {
    return _rcl_take_event(
      event,
      event_info,
    );
  }

  late final _rcl_take_eventPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_event_t>,
              ffi.Pointer<ffi.Void>)>>('rcl_take_event');
  late final _rcl_take_event = _rcl_take_eventPtr.asFunction<
      int Function(ffi.Pointer<rcl_event_t>, ffi.Pointer<ffi.Void>)>();

  /// Finalize an event.
  /// /**
  ///  * Finalize an event.
  ///  *
  ///  * \param[in] event to finalize
  ///  * \return #RCL_RET_OK if successful, or
  ///  * \return #RCL_RET_EVENT_INVALID if event is null, or
  ///  * \return #RCL_RET_ERROR if an unexpected error occurs.
  ///  */
  int rcl_event_fini(
    ffi.Pointer<rcl_event_t> event,
  ) {
    return _rcl_event_fini(
      event,
    );
  }

  late final _rcl_event_finiPtr =
      _lookup<ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_event_t>)>>(
          'rcl_event_fini');
  late final _rcl_event_fini =
      _rcl_event_finiPtr.asFunction<int Function(ffi.Pointer<rcl_event_t>)>();

  /// Return the rmw event handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - event is `NULL`
  ///  *   - event is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned handle is made invalid if the event is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * event as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the event using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] event pointer to the rcl event
  ///  * \return rmw event handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_event_t> rcl_event_get_rmw_handle(
    ffi.Pointer<rcl_event_t> event,
  ) {
    return _rcl_event_get_rmw_handle(
      event,
    );
  }

  late final _rcl_event_get_rmw_handlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rmw_event_t> Function(
              ffi.Pointer<rcl_event_t>)>>('rcl_event_get_rmw_handle');
  late final _rcl_event_get_rmw_handle =
      _rcl_event_get_rmw_handlePtr.asFunction<
          ffi.Pointer<rmw_event_t> Function(ffi.Pointer<rcl_event_t>)>();

  /// Check that the event is valid.
  /// /**
  ///  * The bool returned is `false` if `event` is invalid.
  ///  * The bool returned is `true` otherwise.
  ///  * In the case where `false` is to be returned, an error message is set.
  ///  * This function cannot fail.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] event pointer to the rcl event
  ///  * \return `true` if `event` is valid, otherwise `false`
  ///  */
  bool rcl_event_is_valid(
    ffi.Pointer<rcl_event_t> event,
  ) {
    return _rcl_event_is_valid(
      event,
    );
  }

  late final _rcl_event_is_validPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_event_t>)>>(
          'rcl_event_is_valid');
  late final _rcl_event_is_valid = _rcl_event_is_validPtr
      .asFunction<bool Function(ffi.Pointer<rcl_event_t>)>();

  /// Set the callback function for the event.
  /// /**
  ///  * This API sets the callback function to be called whenever the
  ///  * event is notified about a new instance of the event.
  ///  *
  ///  * \sa rmw_event_set_callback for more details about this function.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] rmw implementation defined</i>
  ///  *
  ///  * \param[in] event The event on which to set the callback
  ///  * \param[in] callback The callback to be called when new events occur, may be NULL
  ///  * \param[in] user_data Given to the callback when called later, may be NULL
  ///  * \return `RCL_RET_OK` if callback was set to the listener, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if `event` is NULL, or
  ///  * \return `RCL_RET_UNSUPPORTED` if the API is not implemented in the dds implementation
  ///  */
  int rcl_event_set_callback(
    ffi.Pointer<rcl_event_t> event,
    rcl_event_callback_t callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rcl_event_set_callback(
      event,
      callback,
      user_data,
    );
  }

  late final _rcl_event_set_callbackPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_event_t>, rcl_event_callback_t,
              ffi.Pointer<ffi.Void>)>>('rcl_event_set_callback');
  late final _rcl_event_set_callback = _rcl_event_set_callbackPtr.asFunction<
      int Function(ffi.Pointer<rcl_event_t>, rcl_event_callback_t,
          ffi.Pointer<ffi.Void>)>();

  /// Return a rcl_wait_set_t struct with members set to `NULL`.
  rcl_wait_set_t rcl_get_zero_initialized_wait_set() {
    return _rcl_get_zero_initialized_wait_set();
  }

  late final _rcl_get_zero_initialized_wait_setPtr =
      _lookup<ffi.NativeFunction<rcl_wait_set_t Function()>>(
          'rcl_get_zero_initialized_wait_set');
  late final _rcl_get_zero_initialized_wait_set =
      _rcl_get_zero_initialized_wait_setPtr
          .asFunction<rcl_wait_set_t Function()>();

  /// Initialize a rcl wait set with space for items to be waited on.
  /// /**
  ///  * This function allocates space for the subscriptions and other wait-able
  ///  * entities that can be stored in the wait set.
  ///  * It also sets the allocator to the given allocator and initializes the pruned
  ///  * member to be false.
  ///  *
  ///  * The wait_set struct should be allocated and initialized to `NULL`.
  ///  * If the wait_set is allocated but the memory is uninitialized the behavior is
  ///  * undefined.
  ///  * Calling this function on a wait set that has already been initialized will
  ///  * result in an error.
  ///  * A wait set can be reinitialized if rcl_wait_set_fini() was called on it.
  ///  *
  ///  * To use the default allocator use rcl_get_default_allocator().
  ///  *
  ///  * Expected usage:
  ///  *
  ///  * ```c
  ///  * #include <rcl/wait.h>
  ///  *
  ///  * rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();
  ///  * rcl_ret_t ret =
  ///  *   rcl_wait_set_init(&wait_set, 42, 42, 42, 42, 42, &context, rcl_get_default_allocator());
  ///  * // ... error handling, then use it, then call the matching fini:
  ///  * ret = rcl_wait_set_fini(&wait_set);
  ///  * // ... error handling
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] wait_set the wait set struct to be initialized
  ///  * \param[in] number_of_subscriptions non-zero size of the subscriptions set
  ///  * \param[in] number_of_guard_conditions non-zero size of the guard conditions set
  ///  * \param[in] number_of_timers non-zero size of the timers set
  ///  * \param[in] number_of_clients non-zero size of the clients set
  ///  * \param[in] number_of_services non-zero size of the services set
  ///  * \param[in] number_of_events non-zero size of the events set
  ///  * \param[in] context the context that the wait set should be associated with
  ///  * \param[in] allocator the allocator to use when allocating space in the sets
  ///  * \return #RCL_RET_OK if the wait set is initialized successfully, or
  ///  * \return #RCL_RET_ALREADY_INIT if the wait set is not zero initialized, or
  ///  * \return #RCL_RET_NOT_INIT if the given context is invalid, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_WAIT_SET_INVALID if the wait set is not destroyed properly, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_wait_set_init(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    int number_of_subscriptions,
    int number_of_guard_conditions,
    int number_of_timers,
    int number_of_clients,
    int number_of_services,
    int number_of_events,
    ffi.Pointer<rcl_context_t> context,
    rcl_allocator_t allocator,
  ) {
    return _rcl_wait_set_init(
      wait_set,
      number_of_subscriptions,
      number_of_guard_conditions,
      number_of_timers,
      number_of_clients,
      number_of_services,
      number_of_events,
      context,
      allocator,
    );
  }

  late final _rcl_wait_set_initPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_wait_set_t>,
              ffi.Size,
              ffi.Size,
              ffi.Size,
              ffi.Size,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<rcl_context_t>,
              rcl_allocator_t)>>('rcl_wait_set_init');
  late final _rcl_wait_set_init = _rcl_wait_set_initPtr.asFunction<
      int Function(ffi.Pointer<rcl_wait_set_t>, int, int, int, int, int, int,
          ffi.Pointer<rcl_context_t>, rcl_allocator_t)>();

  /// Finalize a rcl wait set.
  /// /**
  ///  * Deallocates any memory in the wait set that was allocated in
  ///  * rcl_wait_set_init() using the allocator given in the initialization.
  ///  *
  ///  * Calling this function on a zero initialized wait set will do nothing and
  ///  * return RCL_RET_OK.
  ///  * Calling this function on uninitialized memory results in undefined behavior.
  ///  * After calling this function the wait set will once again be zero initialized
  ///  * and so calling this function or rcl_wait_set_init() immediately after will
  ///  * succeed.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] wait_set the wait set struct to be finalized.
  ///  * \return #RCL_RET_OK if the finalization was successful, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_WAIT_SET_INVALID if the wait set is not destroyed properly, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_wait_set_fini(
    ffi.Pointer<rcl_wait_set_t> wait_set,
  ) {
    return _rcl_wait_set_fini(
      wait_set,
    );
  }

  late final _rcl_wait_set_finiPtr = _lookup<
          ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_wait_set_t>)>>(
      'rcl_wait_set_fini');
  late final _rcl_wait_set_fini = _rcl_wait_set_finiPtr
      .asFunction<int Function(ffi.Pointer<rcl_wait_set_t>)>();

  /// Retrieve the wait set's allocator.
  /// /**
  ///  * The allocator must be an allocated rcl_allocator_t struct, as the result is
  ///  * copied into this variable.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] wait_set the handle to the wait set
  ///  * \param[out] allocator the rcl_allocator_t struct to which the result is copied
  ///  * \return #RCL_RET_OK if the allocator was successfully retrieved, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_WAIT_SET_INVALID if the wait set is invalid, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_wait_set_get_allocator(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_allocator_t> allocator,
  ) {
    return _rcl_wait_set_get_allocator(
      wait_set,
      allocator,
    );
  }

  late final _rcl_wait_set_get_allocatorPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_wait_set_t>,
              ffi.Pointer<rcl_allocator_t>)>>('rcl_wait_set_get_allocator');
  late final _rcl_wait_set_get_allocator =
      _rcl_wait_set_get_allocatorPtr.asFunction<
          int Function(
              ffi.Pointer<rcl_wait_set_t>, ffi.Pointer<rcl_allocator_t>)>();

  /// Store a pointer to the given subscription in the next empty spot in the set.
  /// /**
  ///  * This function does not guarantee that the subscription is not already in the
  ///  * wait set.
  ///  *
  ///  * Also add the rmw representation to the underlying rmw array and increment
  ///  * the rmw array count.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] wait_set struct in which the subscription is to be stored
  ///  * \param[in] subscription the subscription to be added to the wait set
  ///  * \param[out] index the index of the added subscription in the storage container.
  ///  *   This parameter is optional and can be set to `NULL` to be ignored.
  ///  * \return #RCL_RET_OK if added successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_WAIT_SET_INVALID if the wait set is zero initialized, or
  ///  * \return #RCL_RET_WAIT_SET_FULL if the subscription set is full, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_wait_set_add_subscription(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Size> index,
  ) {
    return _rcl_wait_set_add_subscription(
      wait_set,
      subscription,
      index,
    );
  }

  late final _rcl_wait_set_add_subscriptionPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_wait_set_t>,
              ffi.Pointer<rcl_subscription_t>,
              ffi.Pointer<ffi.Size>)>>('rcl_wait_set_add_subscription');
  late final _rcl_wait_set_add_subscription =
      _rcl_wait_set_add_subscriptionPtr.asFunction<
          int Function(ffi.Pointer<rcl_wait_set_t>,
              ffi.Pointer<rcl_subscription_t>, ffi.Pointer<ffi.Size>)>();

  /// Remove (sets to `NULL`) all entities in the wait set.
  /// /**
  ///  * This function should be used after passing using rcl_wait, but before
  ///  * adding new entities to the set.
  ///  * Sets all of the entries in the underlying rmw array to `NULL`, and sets the
  ///  * count in the rmw array to `0`.
  ///  *
  ///  * Calling this on an uninitialized (zero initialized) wait set will fail.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] wait_set struct to have its entities cleared
  ///  * \return #RCL_RET_OK if cleared successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_WAIT_SET_INVALID if the wait set is zero initialized, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_wait_set_clear(
    ffi.Pointer<rcl_wait_set_t> wait_set,
  ) {
    return _rcl_wait_set_clear(
      wait_set,
    );
  }

  late final _rcl_wait_set_clearPtr = _lookup<
          ffi.NativeFunction<rcl_ret_t Function(ffi.Pointer<rcl_wait_set_t>)>>(
      'rcl_wait_set_clear');
  late final _rcl_wait_set_clear = _rcl_wait_set_clearPtr
      .asFunction<int Function(ffi.Pointer<rcl_wait_set_t>)>();

  /// Reallocate space for entities in the wait set.
  /// /**
  ///  * This function will deallocate and reallocate the memory for all entity sets.
  ///  *
  ///  * A size of 0 will just deallocate the memory and assign `NULL` to the array.
  ///  *
  ///  * Allocation and deallocation is done with the allocator given during the
  ///  * wait set's initialization.
  ///  *
  ///  * After calling this function all values in the set will be set to `NULL`,
  ///  * effectively the same as calling rcl_wait_set_clear().
  ///  * Similarly, the underlying rmw representation is reallocated and reset:
  ///  * all entries are set to `NULL` and the count is set to zero.
  ///  *
  ///  * If the requested size matches the current size, no allocation will be done.
  ///  *
  ///  * This can be called on an uninitialized (zero initialized) wait set.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] wait_set struct to be resized
  ///  * \param[in] subscriptions_size a size for the new subscriptions set
  ///  * \param[in] guard_conditions_size a size for the new guard conditions set
  ///  * \param[in] timers_size a size for the new timers set
  ///  * \param[in] clients_size a size for the new clients set
  ///  * \param[in] services_size a size for the new services set
  ///  * \param[in] events_size a size for the new events set
  ///  * \return #RCL_RET_OK if resized successfully, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_BAD_ALLOC if allocating memory failed, or
  ///  * \return #RCL_RET_ERROR if an unspecified error occurs.
  ///  */
  int rcl_wait_set_resize(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    int subscriptions_size,
    int guard_conditions_size,
    int timers_size,
    int clients_size,
    int services_size,
    int events_size,
  ) {
    return _rcl_wait_set_resize(
      wait_set,
      subscriptions_size,
      guard_conditions_size,
      timers_size,
      clients_size,
      services_size,
      events_size,
    );
  }

  late final _rcl_wait_set_resizePtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<rcl_wait_set_t>, ffi.Size, ffi.Size,
              ffi.Size, ffi.Size, ffi.Size, ffi.Size)>>('rcl_wait_set_resize');
  late final _rcl_wait_set_resize = _rcl_wait_set_resizePtr.asFunction<
      int Function(
          ffi.Pointer<rcl_wait_set_t>, int, int, int, int, int, int)>();

  /// Store a pointer to the guard condition in the next empty spot in the set.
  /// /**
  ///  * This function behaves exactly the same as for subscriptions.
  ///  * \see rcl_wait_set_add_subscription
  ///  */
  int rcl_wait_set_add_guard_condition(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
    ffi.Pointer<ffi.Size> index,
  ) {
    return _rcl_wait_set_add_guard_condition(
      wait_set,
      guard_condition,
      index,
    );
  }

  late final _rcl_wait_set_add_guard_conditionPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_wait_set_t>,
              ffi.Pointer<rcl_guard_condition_t>,
              ffi.Pointer<ffi.Size>)>>('rcl_wait_set_add_guard_condition');
  late final _rcl_wait_set_add_guard_condition =
      _rcl_wait_set_add_guard_conditionPtr.asFunction<
          int Function(ffi.Pointer<rcl_wait_set_t>,
              ffi.Pointer<rcl_guard_condition_t>, ffi.Pointer<ffi.Size>)>();

  /// Store a pointer to the timer in the next empty spot in the set.
  /// /**
  ///  * This function behaves exactly the same as for subscriptions.
  ///  * \see rcl_wait_set_add_subscription
  ///  */
  int rcl_wait_set_add_timer(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Size> index,
  ) {
    return _rcl_wait_set_add_timer(
      wait_set,
      timer,
      index,
    );
  }

  late final _rcl_wait_set_add_timerPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_wait_set_t>,
              ffi.Pointer<rcl_timer_t>,
              ffi.Pointer<ffi.Size>)>>('rcl_wait_set_add_timer');
  late final _rcl_wait_set_add_timer = _rcl_wait_set_add_timerPtr.asFunction<
      int Function(ffi.Pointer<rcl_wait_set_t>, ffi.Pointer<rcl_timer_t>,
          ffi.Pointer<ffi.Size>)>();

  /// Store a pointer to the client in the next empty spot in the set.
  /// /**
  ///  * This function behaves exactly the same as for subscriptions.
  ///  * \see rcl_wait_set_add_subscription
  ///  */
  int rcl_wait_set_add_client(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<ffi.Size> index,
  ) {
    return _rcl_wait_set_add_client(
      wait_set,
      client,
      index,
    );
  }

  late final _rcl_wait_set_add_clientPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_wait_set_t>,
              ffi.Pointer<rcl_client_t>,
              ffi.Pointer<ffi.Size>)>>('rcl_wait_set_add_client');
  late final _rcl_wait_set_add_client = _rcl_wait_set_add_clientPtr.asFunction<
      int Function(ffi.Pointer<rcl_wait_set_t>, ffi.Pointer<rcl_client_t>,
          ffi.Pointer<ffi.Size>)>();

  /// Store a pointer to the service in the next empty spot in the set.
  /// /**
  ///  * This function behaves exactly the same as for subscriptions.
  ///  * \see rcl_wait_set_add_subscription
  ///  */
  int rcl_wait_set_add_service(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<ffi.Size> index,
  ) {
    return _rcl_wait_set_add_service(
      wait_set,
      service,
      index,
    );
  }

  late final _rcl_wait_set_add_servicePtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_wait_set_t>,
              ffi.Pointer<rcl_service_t>,
              ffi.Pointer<ffi.Size>)>>('rcl_wait_set_add_service');
  late final _rcl_wait_set_add_service =
      _rcl_wait_set_add_servicePtr.asFunction<
          int Function(ffi.Pointer<rcl_wait_set_t>, ffi.Pointer<rcl_service_t>,
              ffi.Pointer<ffi.Size>)>();

  /// Store a pointer to the event in the next empty spot in the set.
  /// /**
  ///  * This function behaves exactly the same as for subscriptions.
  ///  * \see rcl_wait_set_add_subscription
  ///  */
  int rcl_wait_set_add_event(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<ffi.Size> index,
  ) {
    return _rcl_wait_set_add_event(
      wait_set,
      event,
      index,
    );
  }

  late final _rcl_wait_set_add_eventPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_wait_set_t>,
              ffi.Pointer<rcl_event_t>,
              ffi.Pointer<ffi.Size>)>>('rcl_wait_set_add_event');
  late final _rcl_wait_set_add_event = _rcl_wait_set_add_eventPtr.asFunction<
      int Function(ffi.Pointer<rcl_wait_set_t>, ffi.Pointer<rcl_event_t>,
          ffi.Pointer<ffi.Size>)>();

  /// Block until the wait set is ready or until the timeout has been exceeded.
  /// /**
  ///  * This function will collect the items in the rcl_wait_set_t and pass them
  ///  * to the underlying rmw_wait function.
  ///  *
  ///  * The items in the wait set will be either left untouched or set to `NULL` after
  ///  * this function returns.
  ///  * Items that are not `NULL` are ready, where ready means different things based
  ///  * on the type of the item.
  ///  * For subscriptions this means there may be messages that can be taken, or
  ///  * perhaps that the state of the subscriptions has changed, in which case
  ///  * rcl_take may succeed but return with taken == false.
  ///  * For guard conditions this means the guard condition was triggered.
  ///  *
  ///  * Expected usage:
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  *
  ///  * // rcl_init() called successfully before here...
  ///  * rcl_node_t node;  // initialize this, see rcl_node_init()
  ///  * rcl_subscription_t sub1;  // initialize this, see rcl_subscription_init()
  ///  * rcl_subscription_t sub2;  // initialize this, see rcl_subscription_init()
  ///  * rcl_guard_condition_t gc1;  // initialize this, see rcl_guard_condition_init()
  ///  * rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();
  ///  * rcl_ret_t ret = rcl_wait_set_init(&wait_set, 2, 1, 0, 0, 0, rcl_get_default_allocator());
  ///  * // ... error handling
  ///  * do {
  ///  *   ret = rcl_wait_set_clear(&wait_set);
  ///  *   // ... error handling
  ///  *   ret = rcl_wait_set_add_subscription(&wait_set, &sub1);
  ///  *   // ... error handling
  ///  *   ret = rcl_wait_set_add_subscription(&wait_set, &sub2);
  ///  *   // ... error handling
  ///  *   ret = rcl_wait_set_add_guard_condition(&wait_set, &gc1);
  ///  *   // ... error handling
  ///  *   ret = rcl_wait(&wait_set, RCL_MS_TO_NS(1000));  // 1000ms == 1s, passed as ns
  ///  *   if (ret == RCL_RET_TIMEOUT) {
  ///  *     continue;
  ///  *   }
  ///  *   for (int i = 0; i < wait_set.size_of_subscriptions; ++i) {
  ///  *     if (wait_set.subscriptions[i]) {
  ///  *       // The subscription is ready...
  ///  *     }
  ///  *   }
  ///  *   for (int i = 0; i < wait_set.size_of_guard_conditions; ++i) {
  ///  *     if (wait_set.guard_conditions[i]) {
  ///  *       // The subscription is ready...
  ///  *     }
  ///  *   }
  ///  * } while(check_some_condition());
  ///  * // ... fini node, and subscriptions and guard conditions...
  ///  * ret = rcl_wait_set_fini(&wait_set);
  ///  * // ... error handling
  ///  * ```
  ///  *
  ///  * The wait set struct must be allocated, initialized, and should have been
  ///  * cleared and then filled with items, e.g. subscriptions and guard conditions.
  ///  * Passing a wait set with no wait-able items in it will fail.
  ///  * `NULL` items in the sets are ignored, e.g. it is valid to have as input:
  ///  *  - `subscriptions[0]` = valid pointer
  ///  *  - `subscriptions[1]` = `NULL`
  ///  *  - `subscriptions[2]` = valid pointer
  ///  *  - `size_of_subscriptions` = 3
  ///  * Passing an uninitialized (zero initialized) wait set struct will fail.
  ///  * Passing a wait set struct with uninitialized memory is undefined behavior.
  ///  *
  ///  * The unit of timeout is nanoseconds.
  ///  * If the timeout is negative then this function will block indefinitely until
  ///  * something in the wait set is valid or it is interrupted.
  ///  * If the timeout is 0 then this function will be non-blocking; checking what's
  ///  * ready now, but not waiting if nothing is ready yet.
  ///  * If the timeout is greater than 0 then this function will return after
  ///  * that period of time has elapsed or the wait set becomes ready, which ever
  ///  * comes first.
  ///  * Passing a timeout struct with uninitialized memory is undefined behavior.
  ///  *
  ///  * This function is thread-safe for unique wait sets with unique contents.
  ///  * This function cannot operate on the same wait set in multiple threads, and
  ///  * the wait sets may not share content.
  ///  * For example, calling rcl_wait() in two threads on two different wait sets
  ///  * that both contain a single, shared guard condition is undefined behavior.
  ///  *
  ///  * \param[inout] wait_set the set of things to be waited on and to be pruned if not ready
  ///  * \param[in] timeout the duration to wait for the wait set to be ready, in nanoseconds
  ///  * \return #RCL_RET_OK something in the wait set became ready, or
  ///  * \return #RCL_RET_INVALID_ARGUMENT if any arguments are invalid, or
  ///  * \return #RCL_RET_WAIT_SET_INVALID if the wait set is zero initialized, or
  ///  * \return #RCL_RET_WAIT_SET_EMPTY if the wait set contains no items, or
  ///  * \return #RCL_RET_TIMEOUT if the timeout expired before something was ready, or
  ///  * \return #RCL_RET_ERROR an unspecified error occur.
  ///  */
  int rcl_wait(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    int timeout,
  ) {
    return _rcl_wait(
      wait_set,
      timeout,
    );
  }

  late final _rcl_waitPtr = _lookup<
      ffi.NativeFunction<
          rcl_ret_t Function(
              ffi.Pointer<rcl_wait_set_t>, ffi.Int64)>>('rcl_wait');
  late final _rcl_wait =
      _rcl_waitPtr.asFunction<int Function(ffi.Pointer<rcl_wait_set_t>, int)>();

  /// Return `true` if the wait set is valid, else `false`.
  /// /**
  ///  * A wait set is invalid if:
  ///  *   - the implementation is `NULL` (rcl_wait_set_init not called or failed)
  ///  *   - the wait set has been finalized with rcl_wait_set_fini
  ///  *
  ///  * Also return `false` if the wait set pointer is `NULL`.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] wait_set the rcl_wait_set_t to be validated
  ///  * \return `true` if the wait_set is valid, otherwise `false`.
  ///  */
  bool rcl_wait_set_is_valid(
    ffi.Pointer<rcl_wait_set_t> wait_set,
  ) {
    return _rcl_wait_set_is_valid(
      wait_set,
    );
  }

  late final _rcl_wait_set_is_validPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<rcl_wait_set_t>)>>(
      'rcl_wait_set_is_valid');
  late final _rcl_wait_set_is_valid = _rcl_wait_set_is_validPtr
      .asFunction<bool Function(ffi.Pointer<rcl_wait_set_t>)>();
}

final class max_align_t extends ffi.Opaque {}

/// Encapsulation of an allocator.
/// /**
///  * The default allocator uses malloc(), free(), calloc(), and realloc().
///  * It can be obtained using rcutils_get_default_allocator().
///  *
///  * The allocator should be trivially copyable.
///  * Meaning that the struct should continue to work after being assignment
///  * copied into a new struct.
///  * Specifically the object pointed to by the state pointer should remain valid
///  * until all uses of the allocator have been made.
///  * Particular care should be taken when giving an allocator to functions like
///  * rcutils_*_init() where it is stored within another object and used later.
///  * Developers should note that, while the fields of a const-qualified allocator
///  * struct cannot be modified, the state of the allocator can be modified.
///  */
final class rcutils_allocator_s extends ffi.Struct {
  /// Allocate memory, given a size and the `state` pointer.
  ///   /** An error should be indicated by returning `NULL`. */
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size size, ffi.Pointer<ffi.Void> state)>> allocate;

  /// Deallocate previously allocated memory, mimicking free().
  ///   /** Also takes the `state` pointer. */
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void> pointer, ffi.Pointer<ffi.Void> state)>>
      deallocate;

  /// Reallocate if possible, otherwise it deallocates and allocates.
  ///   /**
  ///    * Also takes the `state` pointer.
  ///    *
  ///    * If unsupported then do deallocate and then allocate.
  ///    * This should behave as realloc() does, as opposed to posix's
  ///    * [reallocf](https://linux.die.net/man/3/reallocf), i.e. the memory given
  ///    * by pointer will not be free'd automatically if realloc() fails.
  ///    * For reallocf-like behavior use rcutils_reallocf().
  ///    * This function must be able to take an input pointer of `NULL` and succeed.
  ///    */
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> pointer,
              ffi.Size size, ffi.Pointer<ffi.Void> state)>> reallocate;

  /// Allocate memory with all elements set to zero, given a number of elements and their size.
  ///   /** An error should be indicated by returning `NULL`. */
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size number_of_elements,
              ffi.Size size_of_element,
              ffi.Pointer<ffi.Void> state)>> zero_allocate;

  /// Implementation defined state storage.
  ///   /**
  ///    * This is passed as the final parameter to other allocator functions.
  ///    * Note that the contents of the state can be modified even in const-qualified
  ///    * allocator objects.
  ///    */
  external ffi.Pointer<ffi.Void> state;
}

/// Encapsulation of an allocator.
/// /**
///  * The default allocator uses malloc(), free(), calloc(), and realloc().
///  * It can be obtained using rcutils_get_default_allocator().
///  *
///  * The allocator should be trivially copyable.
///  * Meaning that the struct should continue to work after being assignment
///  * copied into a new struct.
///  * Specifically the object pointed to by the state pointer should remain valid
///  * until all uses of the allocator have been made.
///  * Particular care should be taken when giving an allocator to functions like
///  * rcutils_*_init() where it is stored within another object and used later.
///  * Developers should note that, while the fields of a const-qualified allocator
///  * struct cannot be modified, the state of the allocator can be modified.
///  */
typedef rcutils_allocator_t = rcutils_allocator_s;

final class __fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> __val;
}

/// Used to specify if the context can only communicate through localhost.
abstract class rmw_localhost_only_e {
  /// Uses ROS_LOCALHOST_ONLY environment variable.
  static const int RMW_LOCALHOST_ONLY_DEFAULT = 0;

  /// Forces using only localhost.
  static const int RMW_LOCALHOST_ONLY_ENABLED = 1;

  /// Forces disabling localhost only.
  static const int RMW_LOCALHOST_ONLY_DISABLED = 2;
}

abstract class rmw_security_enforcement_policy_e {
  static const int RMW_SECURITY_ENFORCEMENT_PERMISSIVE = 0;
  static const int RMW_SECURITY_ENFORCEMENT_ENFORCE = 1;
}

final class rmw_security_options_s extends ffi.Struct {
  @ffi.Int32()
  external int enforce_security;

  external ffi.Pointer<ffi.Char> security_root_path;
}

typedef rmw_security_options_t = rmw_security_options_s;

/// Return code for rmw functions
typedef rmw_ret_t = ffi.Int32;

final class rmw_init_options_impl_s extends ffi.Opaque {}

/// Options structure used during rmw_init().
final class rmw_init_options_s extends ffi.Struct {
  /// Locally (process local) unique ID that represents this init/shutdown cycle.
  ///   /**
  ///    * This should be set by the caller of `rmw_init()` to a number that is
  ///    * unique within this process.
  ///    * It is designed to be used with `rcl_init()` and `rcl_get_instance_id()`.
  ///    */
  @ffi.Uint64()
  external int instance_id;

  /// Implementation identifier, used to ensure two different implementations are not being mixed.
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// ROS domain id
  @ffi.Size()
  external int domain_id;

  /// Security options
  external rmw_security_options_t security_options;

  /// Enable localhost only
  @ffi.Int32()
  external int localhost_only;

  /// Enclave, name used to find security artifacts in a sros2 keystore.
  external ffi.Pointer<ffi.Char> enclave;

  /// TODO(wjwwood): replace with rmw_allocator_t when that refactor happens
  /// Allocator used during internal allocation of init options, if needed.
  external rcutils_allocator_t allocator;

  /// Implementation defined init options.
  ///   /** May be NULL if there are no implementation defined options. */
  external ffi.Pointer<rmw_init_options_impl_t> impl;
}

/// Implementation defined options structure used during rmw_init().
/// /**
///  * This should be defined by the rmw implementation.
///  */
typedef rmw_init_options_impl_t = rmw_init_options_impl_s;

/// Options structure used during rmw_init().
typedef rmw_init_options_t = rmw_init_options_s;

final class rmw_context_impl_s extends ffi.Opaque {}

/// Initialization context structure which is used to store init specific information.
final class rmw_context_s extends ffi.Struct {
  /// Locally (process local) unique ID that represents this init/shutdown cycle.
  @ffi.Uint64()
  external int instance_id;

  /// Implementation identifier, used to ensure two different implementations are not being mixed.
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// Options used to initialize the context.
  external rmw_init_options_t options;

  /// Domain id that is being used.
  @ffi.Size()
  external int actual_domain_id;

  /// Implementation defined context information.
  ///   /** May be NULL if there is no implementation defined context information. */
  external ffi.Pointer<rmw_context_impl_t> impl;
}

/// Implementation defined context structure returned by rmw_init().
/// /**
///  * This should be defined by the rmw implementation.
///  */
typedef rmw_context_impl_t = rmw_context_impl_s;

/// Initialization context structure which is used to store init specific information.
typedef rmw_context_t = rmw_context_s;

final class __mbstate_t extends ffi.Struct {
  @ffi.Int()
  external int __count;

  external UnnamedUnion1 __value;
}

final class UnnamedUnion1 extends ffi.Union {
  @ffi.UnsignedInt()
  external int __wch;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __wchb;
}

final class _G_fpos_t extends ffi.Struct {
  @__off_t()
  external int __pos;

  external __mbstate_t __state;
}

typedef __off_t = ffi.Long;

final class _G_fpos64_t extends ffi.Struct {
  @__off64_t()
  external int __pos;

  external __mbstate_t __state;
}

typedef __off64_t = ffi.Long;

final class _IO_FILE extends ffi.Struct {
  @ffi.Int()
  external int _flags;

  external ffi.Pointer<ffi.Char> _IO_read_ptr;

  external ffi.Pointer<ffi.Char> _IO_read_end;

  external ffi.Pointer<ffi.Char> _IO_read_base;

  external ffi.Pointer<ffi.Char> _IO_write_base;

  external ffi.Pointer<ffi.Char> _IO_write_ptr;

  external ffi.Pointer<ffi.Char> _IO_write_end;

  external ffi.Pointer<ffi.Char> _IO_buf_base;

  external ffi.Pointer<ffi.Char> _IO_buf_end;

  external ffi.Pointer<ffi.Char> _IO_save_base;

  external ffi.Pointer<ffi.Char> _IO_backup_base;

  external ffi.Pointer<ffi.Char> _IO_save_end;

  external ffi.Pointer<_IO_marker> _markers;

  external ffi.Pointer<_IO_FILE> _chain;

  @ffi.Int()
  external int _fileno;

  @ffi.Int()
  external int _flags2;

  @__off_t()
  external int _old_offset;

  @ffi.UnsignedShort()
  external int _cur_column;

  @ffi.SignedChar()
  external int _vtable_offset;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> _shortbuf;

  external ffi.Pointer<_IO_lock_t> _lock;

  @__off64_t()
  external int _offset;

  external ffi.Pointer<_IO_codecvt> _codecvt;

  external ffi.Pointer<_IO_wide_data> _wide_data;

  external ffi.Pointer<_IO_FILE> _freeres_list;

  external ffi.Pointer<ffi.Void> _freeres_buf;

  @ffi.Size()
  external int __pad5;

  @ffi.Int()
  external int _mode;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Char> _unused2;
}

final class _IO_marker extends ffi.Opaque {}

typedef _IO_lock_t = ffi.Void;

final class _IO_codecvt extends ffi.Opaque {}

final class _IO_wide_data extends ffi.Opaque {}

typedef FILE = _IO_FILE;

final class __va_list_tag extends ffi.Struct {
  @ffi.UnsignedInt()
  external int gp_offset;

  @ffi.UnsignedInt()
  external int fp_offset;

  external ffi.Pointer<ffi.Void> overflow_arg_area;

  external ffi.Pointer<ffi.Void> reg_save_area;
}

typedef __ssize_t = ffi.Long;
typedef fpos_t = __fpos_t;
typedef __fpos_t = _G_fpos_t;

final class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

final class __sigset_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedLong> __val;
}

final class timeval extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__suseconds_t()
  external int tv_usec;
}

typedef __time_t = ffi.Long;
typedef __suseconds_t = ffi.Long;

final class timespec extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__syscall_slong_t()
  external int tv_nsec;
}

typedef __syscall_slong_t = ffi.Long;

final class fd_set extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__fd_mask> __fds_bits;
}

typedef __fd_mask = ffi.Long;

final class __atomic_wide_counter extends ffi.Union {
  @ffi.UnsignedLongLong()
  external int __value64;

  external UnnamedStruct1 __value32;
}

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __low;

  @ffi.UnsignedInt()
  external int __high;
}

final class __pthread_internal_list extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_list> __prev;

  external ffi.Pointer<__pthread_internal_list> __next;
}

final class __pthread_internal_slist extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_slist> __next;
}

final class __pthread_mutex_s extends ffi.Struct {
  @ffi.Int()
  external int __lock;

  @ffi.UnsignedInt()
  external int __count;

  @ffi.Int()
  external int __owner;

  @ffi.UnsignedInt()
  external int __nusers;

  @ffi.Int()
  external int __kind;

  @ffi.Short()
  external int __spins;

  @ffi.Short()
  external int __elision;

  external __pthread_list_t __list;
}

typedef __pthread_list_t = __pthread_internal_list;

final class __pthread_rwlock_arch_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __readers;

  @ffi.UnsignedInt()
  external int __writers;

  @ffi.UnsignedInt()
  external int __wrphase_futex;

  @ffi.UnsignedInt()
  external int __writers_futex;

  @ffi.UnsignedInt()
  external int __pad3;

  @ffi.UnsignedInt()
  external int __pad4;

  @ffi.Int()
  external int __cur_writer;

  @ffi.Int()
  external int __shared;

  @ffi.SignedChar()
  external int __rwelision;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedChar> __pad1;

  @ffi.UnsignedLong()
  external int __pad2;

  @ffi.UnsignedInt()
  external int __flags;
}

final class __pthread_cond_s extends ffi.Struct {
  external __atomic_wide_counter __wseq;

  external __atomic_wide_counter __g1_start;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_refs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_size;

  @ffi.UnsignedInt()
  external int __g1_orig_size;

  @ffi.UnsignedInt()
  external int __wrefs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_signals;
}

final class __once_flag extends ffi.Struct {
  @ffi.Int()
  external int __data;
}

final class pthread_mutexattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

final class pthread_condattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

final class pthread_attr_t extends ffi.Union {
  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_mutex_t extends ffi.Union {
  external __pthread_mutex_s __data;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_cond_t extends ffi.Union {
  external __pthread_cond_s __data;

  @ffi.Array.multi([48])
  external ffi.Array<ffi.Char> __size;

  @ffi.LongLong()
  external int __align;
}

final class pthread_rwlock_t extends ffi.Union {
  external __pthread_rwlock_arch_t __data;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_rwlockattr_t extends ffi.Union {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_barrier_t extends ffi.Union {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_barrierattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

final class random_data extends ffi.Struct {
  external ffi.Pointer<ffi.Int32> fptr;

  external ffi.Pointer<ffi.Int32> rptr;

  external ffi.Pointer<ffi.Int32> state;

  @ffi.Int()
  external int rand_type;

  @ffi.Int()
  external int rand_deg;

  @ffi.Int()
  external int rand_sep;

  external ffi.Pointer<ffi.Int32> end_ptr;
}

final class drand48_data extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __x;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __old_x;

  @ffi.UnsignedShort()
  external int __c;

  @ffi.UnsignedShort()
  external int __init;

  @ffi.UnsignedLongLong()
  external int __a;
}

typedef __compar_fn_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;

final class __locale_struct extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<__locale_data>> __locales;

  external ffi.Pointer<ffi.UnsignedShort> __ctype_b;

  external ffi.Pointer<ffi.Int> __ctype_tolower;

  external ffi.Pointer<ffi.Int> __ctype_toupper;

  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<ffi.Char>> __names;
}

final class __locale_data extends ffi.Opaque {}

typedef locale_t = __locale_t;
typedef __locale_t = ffi.Pointer<__locale_struct>;
typedef int_least64_t = __int_least64_t;
typedef __int_least64_t = __int64_t;
typedef __int64_t = ffi.Long;

/// Struct wrapping a fixed-size c string used for returning the formatted error string.
final class rcutils_error_string_s extends ffi.Struct {
  /// The fixed-size C string used for returning the formatted error string.
  @ffi.Array.multi([1024])
  external ffi.Array<ffi.Char> str;
}

/// Struct which encapsulates the error state set by RCUTILS_SET_ERROR_MSG().
final class rcutils_error_state_s extends ffi.Struct {
  /// User message storage, limited to RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH characters.
  @ffi.Array.multi([768])
  external ffi.Array<ffi.Char> message;

  /// File name, limited to what's left from RCUTILS_ERROR_STATE_MAX_SIZE characters
  /// after subtracting storage for others.
  @ffi.Array.multi([229])
  external ffi.Array<ffi.Char> file;

  /// Line number of error.
  @ffi.Uint64()
  external int line_number;
}

/// The type that holds a return value for an rcutils operation.
typedef rcutils_ret_t = ffi.Int;

/// Struct which encapsulates the error state set by RCUTILS_SET_ERROR_MSG().
typedef rcutils_error_state_t = rcutils_error_state_s;

/// Struct wrapping a fixed-size c string used for returning the formatted error string.
typedef rcutils_error_string_t = rcutils_error_string_s;

final class rcutils_array_list_impl_s extends ffi.Opaque {}

/// The structure holding the metadata for an array list.
final class rcutils_array_list_s extends ffi.Struct {
  /// A pointer to the PIMPL implementation type.
  external ffi.Pointer<rcutils_array_list_impl_s> impl;
}

/// The structure holding the metadata for an array list.
typedef rcutils_array_list_t = rcutils_array_list_s;

/// The structure holding the metadata for a char array.
final class rcutils_char_array_s extends ffi.Struct {
  /// A pointer to the allocated memory for this char array.
  external ffi.Pointer<ffi.Char> buffer;

  /// if this is true, we may safely free/realloc the buffer as needed;
  /// otherwise we will leave the buffer alone and alloc new memory if
  /// more space is needed
  @ffi.Bool()
  external bool owns_buffer;

  /// The length of the data stored in the buffer pointer.
  @ffi.Size()
  external int buffer_length;

  /// The maximum capacity of the buffer pointer.
  @ffi.Size()
  external int buffer_capacity;

  /// The allocator used to allocate and free the data in the pointer.
  external rcutils_allocator_t allocator;
}

/// The structure holding the metadata for a char array.
typedef rcutils_char_array_t = rcutils_char_array_s;

final class rcutils_hash_map_impl_s extends ffi.Opaque {}

/// The structure holding the metadata for a hash map.
final class rcutils_hash_map_s extends ffi.Struct {
  /// A pointer to the PIMPL implementation type.
  external ffi.Pointer<rcutils_hash_map_impl_s> impl;
}

/// The structure holding the metadata for a hash map.
typedef rcutils_hash_map_t = rcutils_hash_map_s;

/// The function signature for a key hashing function.
/// /**
///  * \param[in] key The key that needs to be hashed
///  * \return A hash value for the provided string
///  */
typedef rcutils_hash_map_key_hasher_t
    = ffi.Pointer<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Void>)>>;

/// The function signature for a key comparison function.
/// /**
///  * \param[in] val1 The first value to compare
///  * \param[in] val2 The second value to compare
///  * \return A negative number if val1 < val2, or
///  * \return A positve number if val1 > val2, or
///  * \return Zero if val1 == val2.
///  */
typedef rcutils_hash_map_key_cmp_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;

/// The structure holding the metadata for a string array.
final class rcutils_string_array_s extends ffi.Struct {
  /// The number of strings that can be stored in the string array.
  @ffi.Size()
  external int size;

  /// The allocated memory for the string array.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> data;

  /// The allocator used to allocate and free memory for the string array.
  external rcutils_allocator_t allocator;
}

/// The structure holding the metadata for a string array.
typedef rcutils_string_array_t = rcutils_string_array_s;

final class rcutils_string_map_impl_s extends ffi.Opaque {}

/// The structure holding the metadata for a string map.
final class rcutils_string_map_s extends ffi.Struct {
  /// A pointer to the PIMPL implementation type.
  external ffi.Pointer<rcutils_string_map_impl_s> impl;
}

/// The structure holding the metadata for a string map.
typedef rcutils_string_map_t = rcutils_string_map_s;

/// The structure holding the metadata for a uint8 array.
final class rcutils_uint8_array_s extends ffi.Struct {
  /// The allocated memory for the uint8 array.
  external ffi.Pointer<ffi.Uint8> buffer;

  /// The number of valid elements in the uint8 array.
  @ffi.Size()
  external int buffer_length;

  /// The maximum capacity of the uint8 array.
  @ffi.Size()
  external int buffer_capacity;

  /// The allocator used to allocate and free memory for the uint8 array.
  external rcutils_allocator_t allocator;
}

/// The structure holding the metadata for a uint8 array.
typedef rcutils_uint8_array_t = rcutils_uint8_array_s;

/// A single point in time, measured in nanoseconds since the Unix epoch.
typedef rcutils_time_point_value_t = ffi.Int64;

/// The structure identifying the caller location in the source code.
final class rcutils_log_location_s extends ffi.Struct {
  /// The name of the function containing the log call.
  external ffi.Pointer<ffi.Char> function_name;

  /// The name of the source file containing the log call.
  external ffi.Pointer<ffi.Char> file_name;

  /// The line number containing the log call.
  @ffi.Size()
  external int line_number;
}

/// The severity levels of log messages / loggers.
abstract class RCUTILS_LOG_SEVERITY {
  /// < The unset log level
  static const int RCUTILS_LOG_SEVERITY_UNSET = 0;

  /// < The debug log level
  static const int RCUTILS_LOG_SEVERITY_DEBUG = 10;

  /// < The info log level
  static const int RCUTILS_LOG_SEVERITY_INFO = 20;

  /// < The warn log level
  static const int RCUTILS_LOG_SEVERITY_WARN = 30;

  /// < The error log level
  static const int RCUTILS_LOG_SEVERITY_ERROR = 40;

  /// < The fatal log level
  static const int RCUTILS_LOG_SEVERITY_FATAL = 50;
}

/// The function signature to log messages.
/// /**
///  * \param[in] location The location information about where the log came from
///  * \param[in] severity The severity of the log message expressed as an integer
///  * \param[in] name The name of the logger that this message came from
///  * \param[in] timestamp The time at which the log message was generated
///  * \param[in] format The list of arguments to insert into the formatted log message
///  * \param[in] args The variable argument list
///  */
typedef rcutils_logging_output_handler_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<rcutils_log_location_t>,
            ffi.Int,
            ffi.Pointer<ffi.Char>,
            rcutils_time_point_value_t,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Pointer<__va_list_tag>>)>>;

/// The structure identifying the caller location in the source code.
typedef rcutils_log_location_t = rcutils_log_location_s;

/// QoS Policy Kinds
abstract class rmw_qos_policy_kind_e {
  static const int RMW_QOS_POLICY_INVALID = 1;
  static const int RMW_QOS_POLICY_DURABILITY = 2;
  static const int RMW_QOS_POLICY_DEADLINE = 4;
  static const int RMW_QOS_POLICY_LIVELINESS = 8;
  static const int RMW_QOS_POLICY_RELIABILITY = 16;
  static const int RMW_QOS_POLICY_HISTORY = 32;
  static const int RMW_QOS_POLICY_LIFESPAN = 64;
  static const int RMW_QOS_POLICY_DEPTH = 128;
  static const int RMW_QOS_POLICY_LIVELINESS_LEASE_DURATION = 256;
  static const int RMW_QOS_POLICY_AVOID_ROS_NAMESPACE_CONVENTIONS = 512;
}

final class rmw_qos_incompatible_event_status_s extends ffi.Struct {
  /// Total cumulative number of times the concerned subscription discovered a
  /// publisher for the same topic with an offered QoS that was incompatible
  /// with that requested by the subscription.
  @ffi.Int32()
  external int total_count;

  /// The change in total_count since the last time the status was read.
  @ffi.Int32()
  external int total_count_change;

  /// The Qos Policy Kind of one of the policies that was found to be
  /// incompatible the last time an incompatibility was detected.
  @ffi.Int32()
  external int last_policy_kind;
}

/// QoS Liveliness Changed information provided by a subscription.
final class rmw_liveliness_changed_status_s extends ffi.Struct {
  /// The total number of currently active Publishers which publish to the topic associated with
  /// the Subscription.
  /// This count increases when a newly matched Publisher asserts its liveliness for the first time
  /// or when a Publisher previously considered to be not alive reasserts its liveliness.
  /// The count decreases when a Publisher considered alive fails to assert its liveliness and
  /// becomes not alive, whether because it was deleted normally or for some other reason.
  @ffi.Int32()
  external int alive_count;

  /// The total count of current Publishers which publish to the topic associated with the
  /// Subscription that are no longer asserting their liveliness.
  /// This count increases when a Publisher considered alive fails to assert its liveliness and
  /// becomes not alive for some reason other than the normal deletion of that Publisher.
  /// It decreases when a previously not alive Publisher either reasserts its liveliness or is
  /// deleted normally.
  @ffi.Int32()
  external int not_alive_count;

  /// The change in the alive_count since the status was last read.
  @ffi.Int32()
  external int alive_count_change;

  /// The change in the not_alive_count since the status was last read.
  @ffi.Int32()
  external int not_alive_count_change;
}

/// QoS Liveliness Lost information provided by a publisher.
final class rmw_liveliness_lost_status_s extends ffi.Struct {
  /// Lifetime cumulative number of times that a previously-alive Publisher became not alive due to
  /// a failure to actively signal its liveliness within its offered liveliness period.
  /// This count does not change when an already not alive Publisher simply remains not alive for
  /// another liveliness period.
  @ffi.Int32()
  external int total_count;

  /// The change in total_count since the last time the status was last read.
  @ffi.Int32()
  external int total_count_change;
}

final class rmw_message_lost_status_s extends ffi.Struct {
  /// Total number of messages lost.
  @ffi.Size()
  external int total_count;

  /// Number of messages lost since last callback.
  @ffi.Size()
  external int total_count_change;
}

/// QoS Deadline Missed information provided by a publisher.
final class rmw_offered_deadline_missed_status_s extends ffi.Struct {
  /// Lifetime cumulative number of offered deadline periods elapsed during which a Publisher failed
  /// to provide data.
  /// Missed deadlines accumulate; that is, each deadline period the total_count will be incremented
  /// by one.
  @ffi.Int32()
  external int total_count;

  /// The change in total_count since the last time the status was last read.
  @ffi.Int32()
  external int total_count_change;
}

/// QoS Requested Deadline Missed information provided by a subscription.
final class rmw_requested_deadline_missed_status_s extends ffi.Struct {
  /// Lifetime cumulative number of missed deadlines detected for any instance read by the
  /// subscription.
  /// Missed deadlines accumulate; that is, each deadline period the total_count will be incremented
  /// by one for each instance for which data was not received.
  @ffi.Int32()
  external int total_count;

  /// The incremental number of deadlines detected since the status was read.
  @ffi.Int32()
  external int total_count_change;
}

final class rmw_subscription_content_filter_options_s extends ffi.Struct {
  /// Specify the criteria to select the data samples of interest.
  ///
  /// It is similar to the WHERE part of an SQL clause.
  external ffi.Pointer<ffi.Char> filter_expression;

  /// Give values to the tokens placeholder ‘parameters’ (i.e., "%n" tokens begin from 0) in the
  /// filter_expression. The number of supplied parameters must fit with the requested values.
  ///
  /// It can be NULL if there is no "%n" tokens placeholder in filter_expression.
  /// The maximum index number must be smaller than 100.
  external rcutils_string_array_t expression_parameters;
}

typedef rmw_subscription_content_filter_options_t
    = rmw_subscription_content_filter_options_s;

/// A struct representing a duration or relative time in RMW - does not encode an origin.
final class rmw_time_s extends ffi.Struct {
  /// Seconds component
  @ffi.Uint64()
  external int sec;

  /// Nanoseconds component
  @ffi.Uint64()
  external int nsec;
}

/// A struct representing a duration or relative time in RMW - does not encode an origin.
typedef rmw_time_t = rmw_time_s;
typedef rmw_duration_t = rcutils_duration_value_t;

/// A duration of time, measured in nanoseconds.
typedef rcutils_duration_value_t = ffi.Int64;

/// Structure which encapsulates an rmw node
final class rmw_node_s extends ffi.Struct {
  /// Name of the rmw implementation
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// Type erased pointer to this node's data
  external ffi.Pointer<ffi.Void> data;

  /// A concise name of this rmw node for identification
  external ffi.Pointer<ffi.Char> name;

  /// The namespace of this rmw node
  external ffi.Pointer<ffi.Char> namespace_;

  /// Context information about node's init specific information
  external ffi.Pointer<rmw_context_t> context;
}

/// Endpoint enumeration type
abstract class rmw_endpoint_type_e {
  /// Endpoint type has not yet been set
  static const int RMW_ENDPOINT_INVALID = 0;

  /// Creates and publishes messages to the ROS topic
  static const int RMW_ENDPOINT_PUBLISHER = 1;

  /// Listens for and receives messages from a topic
  static const int RMW_ENDPOINT_SUBSCRIPTION = 2;
}

/// Unique network flow endpoints requirement enumeration
abstract class rmw_unique_network_flow_endpoints_requirement_e {
  /// Unique network flow endpoints not required
  static const int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED = 0;

  /// Unique network flow endpoins strictly required.
  /// Error if not provided by RMW implementation.
  static const int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_STRICTLY_REQUIRED = 1;

  /// Unique network flow endpoints optionally required.
  /// No error if not provided RMW implementation.
  static const int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_OPTIONALLY_REQUIRED = 2;

  /// Unique network flow endpoints requirement decided by system.
  static const int RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_SYSTEM_DEFAULT = 3;
}

/// Options that can be used to configure the creation of a publisher in rmw.
final class rmw_publisher_options_s extends ffi.Struct {
  /// Used to pass rmw implementation specific resources during publisher creation.
  ///   /**
  ///    * This field is type erased (rather than forward declared) because it will
  ///    * usually be a non-owned reference to an language specific object, e.g.
  ///    * C++ it may be a polymorphic class that only the rmw implementation can use.
  ///    *
  ///    * The resource pointed to here needs to outlive this options structure, and
  ///    * any rmw_publisher objects that are created using it, as they copy this
  ///    * structure and may use this payload throughout their lifetime.
  ///    */
  external ffi.Pointer<ffi.Void> rmw_specific_publisher_payload;

  /// Require middleware to generate unique network flow endpoints.
  ///   /**
  ///    * Unique network flow endpoints are required to differentiate the QoS provided by
  ///    * networks for flows between publishers and subscribers in communicating
  ///    * nodes.
  ///    * Default value is RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED.
  ///    */
  @ffi.Int32()
  external int require_unique_network_flow_endpoints;
}

/// Structure which encapsulates an rmw publisher
final class rmw_publisher_s extends ffi.Struct {
  /// Name of the rmw implementation
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// Type erased pointer to this publisher's data
  external ffi.Pointer<ffi.Void> data;

  /// The name of the ROS topic this publisher publishes to
  external ffi.Pointer<ffi.Char> topic_name;

  /// Publisher options.
  ///   /**
  ///    * The options structure passed to rmw_create_publisher() should be
  ///    * assigned to this field by the rmw implementation.
  ///    * The fields should not be modified after creation, but
  ///    * the contents of the options structure may or may not be const, i.e.
  ///    * shallow const-ness.
  ///    * This field is not marked const to avoid any const casting during setup.
  ///    */
  external rmw_publisher_options_t options;

  /// Indicate whether this publisher supports loaning messages
  @ffi.Bool()
  external bool can_loan_messages;
}

/// Options that can be used to configure the creation of a publisher in rmw.
typedef rmw_publisher_options_t = rmw_publisher_options_s;

/// Options that can be used to configure the creation of a subscription in rmw.
final class rmw_subscription_options_s extends ffi.Struct {
  /// Used to pass rmw implementation specific resources during subscription creation.
  ///   /**
  ///    * All the same details and restrictions of this field in
  ///    * rmw_publisher_options_t apply to this struct as well.
  ///    *
  ///    * \sa rmw_publisher_options_t.rmw_specific_publisher_payload
  ///    */
  external ffi.Pointer<ffi.Void> rmw_specific_subscription_payload;

  /// If true then the middleware should not deliver data from local publishers.
  ///   /**
  ///    * This setting is most often used when data should only be received from
  ///    * remote nodes, especially to avoid "double delivery" when both intra- and
  ///    * inter- process communication is taking place.
  ///    *
  ///    * \todo(wjwwood): nail this down when participant mapping is sorted out.
  ///    *   See: https://github.com/ros2/design/pull/250
  ///    *
  ///    * The definition of local is somewhat vague at the moment.
  ///    * Right now it means local to the node, and that definition works best, but
  ///    * may become more complicated when/if participants map to a context instead.
  ///    */
  @ffi.Bool()
  external bool ignore_local_publications;

  /// Require middleware to generate unique network flow endpoints.
  ///   /**
  ///    * Unique network flow endpoints are required to differentiate the QoS provided by
  ///    * networks for flows between publishers and subscribers in communicating
  ///    * nodes.
  ///    * Default value is RMW_UNIQUE_NETWORK_FLOW_ENDPOINTS_NOT_REQUIRED.
  ///    */
  @ffi.Int32()
  external int require_unique_network_flow_endpoints;

  /// Used to create a content filter options during subscription creation.
  external ffi.Pointer<rmw_subscription_content_filter_options_t>
      content_filter_options;
}

final class rmw_subscription_s extends ffi.Struct {
  /// Name of the rmw implementation
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// Type erased pointer to this subscription
  external ffi.Pointer<ffi.Void> data;

  /// Name of the ros topic this subscription listens to
  external ffi.Pointer<ffi.Char> topic_name;

  /// Subscription options.
  ///   /**
  ///    * The options structure passed to rmw_create_subscription() should be
  ///    * assigned to this field by the rmw implementation.
  ///    * The fields should not be modified after creation, but
  ///    * the contents of the options structure may or may not be const, i.e.
  ///    * shallow const-ness.
  ///    * This field is not marked const to avoid any const casting during setup.
  ///    */
  external rmw_subscription_options_t options;

  /// Indicates whether this subscription can loan messages
  @ffi.Bool()
  external bool can_loan_messages;

  /// Indicates whether content filtered topic of this subscription is enabled
  @ffi.Bool()
  external bool is_cft_enabled;
}

/// Options that can be used to configure the creation of a subscription in rmw.
typedef rmw_subscription_options_t = rmw_subscription_options_s;

/// A handle to an rmw service
final class rmw_service_s extends ffi.Struct {
  /// The name of the rmw implementation
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// Type erased pointer to this service
  external ffi.Pointer<ffi.Void> data;

  /// The name of this service as exposed to the ros graph
  external ffi.Pointer<ffi.Char> service_name;
}

/// A handle to an rmw service client
final class rmw_client_s extends ffi.Struct {
  /// The name of the rmw implementation
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// Type erased pointer to this service client
  external ffi.Pointer<ffi.Void> data;

  /// The name of this service as exposed to the ros graph
  external ffi.Pointer<ffi.Char> service_name;
}

/// Handle for an rmw guard condition
final class rmw_guard_condition_s extends ffi.Struct {
  /// The name of the rmw implementation
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// Type erased pointer to this guard condition
  external ffi.Pointer<ffi.Void> data;

  /// rmw context associated with this guard condition
  external ffi.Pointer<rmw_context_t> context;
}

/// Allocation of memory for an rmw publisher
final class rmw_publisher_allocation_s extends ffi.Struct {
  /// The name of the rmw implementation
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// Type erased pointer to this allocation
  external ffi.Pointer<ffi.Void> data;
}

/// Allocation of memory for an rmw subscription
final class rmw_subscription_allocation_s extends ffi.Struct {
  /// The name of the rmw implementation
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// Type erased pointer to this allocation
  external ffi.Pointer<ffi.Void> data;
}

/// Array of subscriber handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific subscriptions.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of subscriptions represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
final class rmw_subscriptions_s extends ffi.Struct {
  /// The number of subscribers represented by the array.
  @ffi.Size()
  external int subscriber_count;

  /// Pointer to an array of void * pointers of subscriptions.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> subscribers;
}

/// Array of service handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific services.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of services represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
final class rmw_services_s extends ffi.Struct {
  /// The number of services represented by the array.
  @ffi.Size()
  external int service_count;

  /// Pointer to an array of void * pointers of services.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> services;
}

/// Array of client handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific clients.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of clients represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
final class rmw_clients_s extends ffi.Struct {
  /// The number of clients represented by the array.
  @ffi.Size()
  external int client_count;

  /// Pointer to an array of void * pointers of clients.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> clients;
}

final class rmw_events_s extends ffi.Struct {
  /// The number of events represented by the array.
  @ffi.Size()
  external int event_count;

  /// Pointer to an array of void * pointers of events.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> events;
}

/// Array of guard condition handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific guard conditions.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of guard conditions represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
final class rmw_guard_conditions_s extends ffi.Struct {
  /// The number of guard conditions represented by the array.
  @ffi.Size()
  external int guard_condition_count;

  /// Pointer to an array of void * pointers of guard conditions.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> guard_conditions;
}

/// Container for guard conditions to be waited on
final class rmw_wait_set_s extends ffi.Struct {
  /// The name of the rmw implementation
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// The guard condition to be waited on
  external ffi.Pointer<rmw_guard_conditions_t> guard_conditions;

  /// Type erased pointer to this wait set's data
  external ffi.Pointer<ffi.Void> data;
}

/// Array of guard condition handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific guard conditions.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of guard conditions represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
typedef rmw_guard_conditions_t = rmw_guard_conditions_s;

/// An rmw service request identifier
final class rmw_request_id_s extends ffi.Struct {
  /// The guid of the writer associated with this request
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Int8> writer_guid;

  /// Sequence number of this service
  @ffi.Int64()
  external int sequence_number;
}

/// Meta-data for a service-related take.
final class rmw_service_info_s extends ffi.Struct {
  @rmw_time_point_value_t()
  external int source_timestamp;

  @rmw_time_point_value_t()
  external int received_timestamp;

  external rmw_request_id_t request_id;
}

typedef rmw_time_point_value_t = rcutils_time_point_value_t;

/// An rmw service request identifier
typedef rmw_request_id_t = rmw_request_id_s;

abstract class rmw_qos_reliability_policy_e {
  /// Implementation specific default
  static const int RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT = 0;

  /// Guarantee that samples are delivered, may retry multiple times.
  static const int RMW_QOS_POLICY_RELIABILITY_RELIABLE = 1;

  /// Attempt to deliver samples, but some may be lost if the network is not robust
  static const int RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT = 2;

  /// Reliability policy has not yet been set
  static const int RMW_QOS_POLICY_RELIABILITY_UNKNOWN = 3;
}

/// QoS history enumerations describing how samples endure
abstract class rmw_qos_history_policy_e {
  /// Implementation default for history policy
  static const int RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT = 0;

  /// Only store up to a maximum number of samples, dropping oldest once max is exceeded
  static const int RMW_QOS_POLICY_HISTORY_KEEP_LAST = 1;

  /// Store all samples, subject to resource limits
  static const int RMW_QOS_POLICY_HISTORY_KEEP_ALL = 2;

  /// History policy has not yet been set
  static const int RMW_QOS_POLICY_HISTORY_UNKNOWN = 3;
}

/// QoS durability enumerations describing how samples persist
abstract class rmw_qos_durability_policy_e {
  /// Impplementation specific default
  static const int RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT = 0;

  /// The rmw publisher is responsible for persisting samples for “late-joining” subscribers
  static const int RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL = 1;

  /// Samples are not persistent
  static const int RMW_QOS_POLICY_DURABILITY_VOLATILE = 2;

  /// Durability policy has not yet been set
  static const int RMW_QOS_POLICY_DURABILITY_UNKNOWN = 3;
}

/// QoS liveliness enumerations that describe a publisher's reporting policy for its alive status.
/// For a subscriber, these are its requirements for its topic's publishers.
/// Suppress syntax errors, as cppcheck does not seem to handle enumerator attributes.
/// cppcheck-suppress syntaxError
abstract class rmw_qos_liveliness_policy_e {
  /// Implementation specific default
  static const int RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT = 0;

  /// The signal that establishes a Topic is alive comes from the ROS rmw layer.
  static const int RMW_QOS_POLICY_LIVELINESS_AUTOMATIC = 1;
  static const int RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE = 2;

  /// The signal that establishes a Topic is alive is at the Topic level. Only publishing a message
  /// on the Topic or an explicit signal from the application to assert liveliness on the Topic
  /// will mark the Topic as being alive.
  /// Using `3` for backwards compatibility.
  static const int RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC = 3;

  /// Liveliness policy has not yet been set
  static const int RMW_QOS_POLICY_LIVELINESS_UNKNOWN = 4;
}

/// ROS MiddleWare quality of service profile.
final class rmw_qos_profile_s extends ffi.Struct {
  @ffi.Int32()
  external int history;

  /// Size of the message queue.
  @ffi.Size()
  external int depth;

  /// Reliabiilty QoS policy setting
  @ffi.Int32()
  external int reliability;

  /// Durability QoS policy setting
  @ffi.Int32()
  external int durability;

  /// The period at which messages are expected to be sent/received
  ///   /**
  ///     * RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,
  ///     *   which may or may not be infinite.
  ///     * RMW_DURATION_INFINITE explicitly states that messages never miss a deadline expectation.
  ///     */
  external rmw_time_s deadline;

  /// The age at which messages are considered expired and no longer valid
  ///   /**
  ///     * RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,
  ///     *   which may or may not be infinite.
  ///     * RMW_DURATION_INFINITE explicitly states that messages do not expire.
  ///     */
  external rmw_time_s lifespan;

  /// Liveliness QoS policy setting
  @ffi.Int32()
  external int liveliness;

  /// The time within which the RMW node or publisher must show that it is alive
  ///   /**
  ///     * RMW_DURATION_UNSPEFICIED will use the RMW implementation's default value,
  ///     *   which may or may not be infinite.
  ///     * RMW_DURATION_INFINITE explicitly states that liveliness is not enforced.
  ///     */
  external rmw_time_s liveliness_lease_duration;

  /// If true, any ROS specific namespacing conventions will be circumvented.
  ///   /**
  ///    * In the case of DDS and topics, for example, this means the typical
  ///    * ROS specific prefix of `rt` would not be applied as described here:
  ///    *
  ///    *   http://design.ros2.org/articles/topic_and_service_names.html#ros-specific-namespace-prefix
  ///    *
  ///    * This might be useful when trying to directly connect a native DDS topic
  ///    * with a ROS 2 topic.
  ///    */
  @ffi.Bool()
  external bool avoid_ros_namespace_conventions;
}

/// ROS graph ID of the topic
final class rmw_gid_s extends ffi.Struct {
  /// Name of the rmw implementation
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// Bype data Gid value
  @ffi.Array.multi([24])
  external ffi.Array<ffi.Uint8> data;
}

/// Information describing an rmw message
final class rmw_message_info_s extends ffi.Struct {
  /// Time when the message was published by the publisher.
  ///   /**
  ///    * The exact point at which the timestamp is taken is not specified, but
  ///    * it should be taken consistently at the same point in the
  ///    * publishing process each time.
  ///    */
  @rmw_time_point_value_t()
  external int source_timestamp;

  /// Time when the message was received by the subscription.
  ///   /**
  ///    * The exact point at which the timestamp is taken is not specified, but
  ///    * it should be taken consistently at the same point in the
  ///    * process of receiving a message each time.
  ///    */
  @rmw_time_point_value_t()
  external int received_timestamp;

  /// Sequence number of the received message set by the publisher.
  ///   /**
  ///    * This sequence number is set by the publisher and therefore uniquely identifies
  ///    * a message when combined with the publisher GID.
  ///    * For long running applications, the sequence number might wrap around at some point.
  ///    *
  ///    * If the rmw implementation doesn't support sequence numbers, its value will be
  ///    * RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED.
  ///    *
  ///    * Requirements:
  ///    *
  ///    * If `psn1` and `psn2` are the publication sequence numbers obtained by
  ///    * calls to `rmw_take*()`, where `psn1` was obtained in a call that happened before `psn2` and both
  ///    * sequence numbers are from the same publisher (i.e. also same publisher gid), then:
  ///    *
  ///    * - psn2 > psn1 (except in the case of a wrap around)
  ///    * - `psn2 - psn1 - 1` is the number of messages the publisher sent in the middle of both
  ///    *   received messages.
  ///    *   Those might have already been taken by other `rmw_take*()` calls that happened in between or lost.
  ///    *   `psn2 - psn1 - 1 = 0` if and only if the messages were sent by the publisher consecutively.
  ///    */
  @ffi.Uint64()
  external int publication_sequence_number;

  /// Sequence number of the received message set by the subscription.
  ///   /**
  ///    * This sequence number is set by the subscription regardless of which
  ///    * publisher sent the message.
  ///    * For long running applications, the sequence number might wrap around at some point.
  ///    *
  ///    * If the rmw implementation doesn't support sequence numbers, its value will be
  ///    * RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED.
  ///    *
  ///    * Requirements:
  ///    *
  ///    * If `rsn1` and `rsn2` are the reception sequence numbers obtained by
  ///    * calls to `rmw_take*()`, where `rsn1` was obtained in a call that happened before `rsn2`, then:
  ///    *
  ///    * - rsn2 > rsn1 (except in the case of a wrap around)
  ///    * - `rsn2 = rsn1 + 1` if and only if both `rmw_take*()` calls happened consecutively.
  ///    */
  @ffi.Uint64()
  external int reception_sequence_number;

  /// Global unique identifier of the publisher that sent the message.
  ///   /**
  ///    * The identifier uniquely identifies the publisher for the local context, but
  ///    * it will not necessarily be the same identifier given in other contexts or processes
  ///    * for the same publisher.
  ///    * Therefore the identifier will uniquely identify the publisher within your application
  ///    * but may disagree about the identifier for that publisher when compared to another
  ///    * application.
  ///    * Even with this limitation, when combined with the publisher sequence number it can
  ///    * uniquely identify a message within your local context.
  ///    * Publisher GIDs generated by the rmw implementation could collide at some point, in which
  ///    * case it is not possible to distinguish which publisher sent the message.
  ///    * The details of how GIDs are generated are rmw implementation dependent.
  ///    *
  ///    * It is possible the the rmw implementation needs to reuse a publisher GID,
  ///    * due to running out of unique identifiers or some other constraint, in which case
  ///    * the rmw implementation may document what happens in that case, but that
  ///    * behavior is not defined here.
  ///    * However, this should be avoided, if at all possible, by the rmw implementation,
  ///    * and should be unlikely to happen in practice.
  ///    *
  ///    * \todo In the future we want this to uniquely identify the publisher globally across
  ///    *   contexts, processes, and machines.
  ///    */
  external rmw_gid_t publisher_gid;

  /// Whether this message is from intra_process communication or not
  @ffi.Bool()
  external bool from_intra_process;
}

/// ROS graph ID of the topic
typedef rmw_gid_t = rmw_gid_s;

/// Information describing an rmw message
typedef rmw_message_info_t = rmw_message_info_s;

/// Type mapping of rcutils log severity types to rmw specific types.
abstract class rmw_log_severity_t {
  /// Debug log severity, for pedantic messaging
  static const int RMW_LOG_SEVERITY_DEBUG = 10;

  /// Informational log severity, for reporting expected but not overwhelming information
  static const int RMW_LOG_SEVERITY_INFO = 20;

  /// Warning log severity, for reporting recoverable issues
  static const int RMW_LOG_SEVERITY_WARN = 30;

  /// Error log severity, for reporting uncoverable issues
  static const int RMW_LOG_SEVERITY_ERROR = 40;

  /// Fatal log severity, for reporting issue causing imminent shutdown
  static const int RMW_LOG_SEVERITY_FATAL = 50;
}

/// A logger item to specify a name and a log level.
final class rcl_logger_setting_s extends ffi.Struct {
  /// Name for the logger.
  external ffi.Pointer<ffi.Char> name;

  /// Minimum log level severity of the logger.
  @ffi.Int32()
  external int level;
}

/// Hold default logger level and other logger setting.
final class rcl_log_levels_s extends ffi.Struct {
  /// Minimum default logger level severity.
  @ffi.Int32()
  external int default_logger_level;

  /// Array of logger setting.
  external ffi.Pointer<rcl_logger_setting_t> logger_settings;

  /// Number of logger settings.
  @ffi.Size()
  external int num_logger_settings;

  /// Capacity of logger settings.
  @ffi.Size()
  external int capacity_logger_settings;

  /// Allocator used to allocate objects in this struct.
  external rcl_allocator_t allocator;
}

/// A logger item to specify a name and a log level.
typedef rcl_logger_setting_t = rcl_logger_setting_s;

/// Encapsulation of an allocator.
/// /**
///  * \sa rcutils_allocator_t
///  */
typedef rcl_allocator_t = rcutils_allocator_t;

/// Hold default logger level and other logger setting.
typedef rcl_log_levels_t = rcl_log_levels_s;

/// The type that holds an rcl return code.
typedef rcl_ret_t = rmw_ret_t;

/// Array of bool values
/// /*
///  * \typedef rcl_bool_array_t
///  */
final class rcl_bool_array_s extends ffi.Struct {
  /// Array with bool values
  external ffi.Pointer<ffi.Bool> values;

  /// Number of values in the array
  @ffi.Size()
  external int size;
}

/// Array of int64_t values
/// /*
///  * \typedef rcl_int64_array_t
///  */
final class rcl_int64_array_s extends ffi.Struct {
  /// Array with int64 values
  external ffi.Pointer<ffi.Int64> values;

  /// Number of values in the array
  @ffi.Size()
  external int size;
}

/// Array of double values
/// /*
///  * \typedef rcl_double_array_t
///  */
final class rcl_double_array_s extends ffi.Struct {
  /// Array with double values
  external ffi.Pointer<ffi.Double> values;

  /// Number of values in the array
  @ffi.Size()
  external int size;
}

/// Array of byte values
/// /*
///  * \typedef rcl_byte_array_t
///  */
final class rcl_byte_array_s extends ffi.Struct {
  /// Array with uint8_t values
  external ffi.Pointer<ffi.Uint8> values;

  /// Number of values in the array
  @ffi.Size()
  external int size;
}

/// variant_t stores the value of a parameter
/// /*
///  * Only one pointer in this struct will store the value
///  * \typedef rcl_variant_t
///  */
final class rcl_variant_s extends ffi.Struct {
  /// < If bool, gets stored here
  external ffi.Pointer<ffi.Bool> bool_value;

  /// < If integer, gets stored here
  external ffi.Pointer<ffi.Int64> integer_value;

  /// < If double, gets stored here
  external ffi.Pointer<ffi.Double> double_value;

  /// < If string, gets stored here
  external ffi.Pointer<ffi.Char> string_value;

  /// < If array of bytes
  external ffi.Pointer<rcl_byte_array_t> byte_array_value;

  /// < If array of bool's
  external ffi.Pointer<rcl_bool_array_t> bool_array_value;

  /// < If array of integers
  external ffi.Pointer<rcl_int64_array_t> integer_array_value;

  /// < If array of doubles
  external ffi.Pointer<rcl_double_array_t> double_array_value;

  /// < If array of strings
  external ffi.Pointer<rcutils_string_array_t> string_array_value;
}

/// Array of byte values
/// /*
///  * \typedef rcl_byte_array_t
///  */
typedef rcl_byte_array_t = rcl_byte_array_s;

/// Array of bool values
/// /*
///  * \typedef rcl_bool_array_t
///  */
typedef rcl_bool_array_t = rcl_bool_array_s;

/// Array of int64_t values
/// /*
///  * \typedef rcl_int64_array_t
///  */
typedef rcl_int64_array_t = rcl_int64_array_s;

/// Array of double values
/// /*
///  * \typedef rcl_double_array_t
///  */
typedef rcl_double_array_t = rcl_double_array_s;

/// node_params_t stores all the parameters(key:value) of a single node
/// /*
/// * \typedef rcl_node_params_t
/// */
final class rcl_node_params_s extends ffi.Struct {
  /// < Array of parameter names (keys)
  external ffi.Pointer<ffi.Pointer<ffi.Char>> parameter_names;

  /// < Array of coressponding parameter values
  external ffi.Pointer<rcl_variant_t> parameter_values;

  /// < Number of parameters in the node
  @ffi.Size()
  external int num_params;

  /// < Capacity of parameters in the node
  @ffi.Size()
  external int capacity_params;
}

/// variant_t stores the value of a parameter
/// /*
///  * Only one pointer in this struct will store the value
///  * \typedef rcl_variant_t
///  */
typedef rcl_variant_t = rcl_variant_s;

/// stores all the parameters of all nodes of a process
/// /*
/// * \typedef rcl_params_t
/// */
final class rcl_params_s extends ffi.Struct {
  /// < List of names of the node
  external ffi.Pointer<ffi.Pointer<ffi.Char>> node_names;

  /// <  Array of parameters
  external ffi.Pointer<rcl_node_params_t> params;

  /// < Number of nodes
  @ffi.Size()
  external int num_nodes;

  /// < Capacity of nodes
  @ffi.Size()
  external int capacity_nodes;

  /// < Allocator used
  external rcutils_allocator_t allocator;
}

/// node_params_t stores all the parameters(key:value) of a single node
/// /*
/// * \typedef rcl_node_params_t
/// */
typedef rcl_node_params_t = rcl_node_params_s;

final class rcl_arguments_impl_s extends ffi.Opaque {}

/// Hold output of parsing command line arguments.
final class rcl_arguments_s extends ffi.Struct {
  /// Private implementation pointer.
  external ffi.Pointer<rcl_arguments_impl_t> impl;
}

typedef rcl_arguments_impl_t = rcl_arguments_impl_s;

/// Hold output of parsing command line arguments.
typedef rcl_arguments_t = rcl_arguments_s;

/// stores all the parameters of all nodes of a process
/// /*
/// * \typedef rcl_params_t
/// */
typedef rcl_params_t = rcl_params_s;

final class rcl_init_options_impl_s extends ffi.Opaque {}

/// Encapsulation of init options and implementation defined init options.
final class rcl_init_options_s extends ffi.Struct {
  /// Implementation specific pointer.
  external ffi.Pointer<rcl_init_options_impl_t> impl;
}

typedef rcl_init_options_impl_t = rcl_init_options_impl_s;

/// Encapsulation of init options and implementation defined init options.
typedef rcl_init_options_t = rcl_init_options_s;

final class rcl_context_impl_s extends ffi.Opaque {}

/// Encapsulates the non-global state of an init/shutdown cycle.
/// /**
///  * The context is used in the creation of top level entities like nodes and
///  * guard conditions, as well as to shutdown a specific instance of init.
///  *
///  * Here is a diagram of a typical context's lifecycle:
///  *
///  * ```
///  *    +---------------+
///  *    |               |
///  * +--> uninitialized +---> rcl_get_zero_initialized_context() +
///  * |  |               |                                        |
///  * |  +---------------+                                        |
///  * |                                                           |
///  * |           +-----------------------------------------------+
///  * |           |
///  * |  +--------v---------+                +-----------------------+
///  * |  |                  |                |                       |
///  * |  | zero-initialized +-> rcl_init() +-> initialized and valid +-> rcl_shutdown() +
///  * |  |                  |                |                       |                  |
///  * |  +------------------+                +-----------------------+                  |
///  * |                                                                                 |
///  * |               +-----------------------------------------------------------------+
///  * |               |
///  * |  +------------v------------+
///  * |  |                         |
///  * |  | initialized but invalid +---> finalize all entities, then rcl_context_fini() +
///  * |  |                         |                                                    |
///  * |  +-------------------------+                                                    |
///  * |                                                                                 |
///  * +---------------------------------------------------------------------------------+
///  * ```
///  *
///  * A declared but not defined rcl_context_t instance is considered to be
///  * "uninitialized", and passing an uninitialized context to any functions will
///  * result in undefined behavior.
///  * Some functions, like rcl_init() require the context instance to be
///  * zero initialized (all members set to "zero" state) before use.
///  *
///  * Zero initialization of an rcl_context_t should be done with
///  * rcl_get_zero_initialized_context(), which ensures the context is in a safe
///  * state for initialization with rcl_init().
///  *
///  * Initialization of an rcl_context_t should be done with rcl_init(), after
///  * which the context is considered both initialized and valid.
///  * After initialization it can be used in the creation of other entities like
///  * nodes and guard conditions.
///  *
///  * At any time the context can be invalidated by calling rcl_shutdown() on
///  * the rcl_context_t, after which the context is still initialized but now
///  * invalid.
///  *
///  * Invalidation indicates to other entities that the context was shutdown, but
///  * is still accessible for use during cleanup of themselves.
///  *
///  * After being invalidated, and after all of the entities which used it have
///  * been finalized, the context should be finalized with rcl_context_fini().
///  *
///  * Finalizing the context while entities which have copies of it have not yet
///  * been finalized is undefined behavior.
///  * Therefore, the context's lifetime (between calls to rcl_init() and
///  * rcl_context_fini()) should exceed the lifetime of all entities which use
///  * it directly (e.g. nodes and guard conditions) or indirectly (e.g.
///  * subscriptions and topics).
///  */
final class rcl_context_s extends ffi.Struct {
  /// Global arguments for all nodes which share this context.
  ///   /** Typically generated by the parsing of argc/argv in rcl_init(). */
  external rcl_arguments_t global_arguments;

  /// Implementation specific pointer.
  external ffi.Pointer<rcl_context_impl_t> impl;

  /// @endcond
  /// Private storage for instance ID atomic.
  ///   /**
  ///    * Accessing the instance id should be done using the function
  ///    * rcl_context_get_instance_id() because the instance id's type is an
  ///    * atomic and needs to be accessed properly to ensure safety.
  ///    *
  ///    * The instance id should not be changed manually - doing so is undefined
  ///    * behavior.
  ///    *
  ///    * The instance id cannot be protected within the `impl` pointer's type
  ///    * because it needs to be accessible even when the context is zero
  ///    * initialized and therefore `impl` is `NULL`.
  ///    * Specifically, storing the instance id in the `impl` would introduce a
  ///    * race condition between accessing it and finalizing the context.
  ///    * Additionally, C11 atomics (i.e. "stdatomic.h") cannot be used directly
  ///    * here in the case that this header is included into a C++ program.
  ///    * See this paper for an effort to make this possible in the future:
  ///    *   http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0943r1.html
  ///    */
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint8> instance_id_storage;
}

typedef rcl_context_impl_t = rcl_context_impl_s;

/// Encapsulates the non-global state of an init/shutdown cycle.
/// /**
///  * The context is used in the creation of top level entities like nodes and
///  * guard conditions, as well as to shutdown a specific instance of init.
///  *
///  * Here is a diagram of a typical context's lifecycle:
///  *
///  * ```
///  *    +---------------+
///  *    |               |
///  * +--> uninitialized +---> rcl_get_zero_initialized_context() +
///  * |  |               |                                        |
///  * |  +---------------+                                        |
///  * |                                                           |
///  * |           +-----------------------------------------------+
///  * |           |
///  * |  +--------v---------+                +-----------------------+
///  * |  |                  |                |                       |
///  * |  | zero-initialized +-> rcl_init() +-> initialized and valid +-> rcl_shutdown() +
///  * |  |                  |                |                       |                  |
///  * |  +------------------+                +-----------------------+                  |
///  * |                                                                                 |
///  * |               +-----------------------------------------------------------------+
///  * |               |
///  * |  +------------v------------+
///  * |  |                         |
///  * |  | initialized but invalid +---> finalize all entities, then rcl_context_fini() +
///  * |  |                         |                                                    |
///  * |  +-------------------------+                                                    |
///  * |                                                                                 |
///  * +---------------------------------------------------------------------------------+
///  * ```
///  *
///  * A declared but not defined rcl_context_t instance is considered to be
///  * "uninitialized", and passing an uninitialized context to any functions will
///  * result in undefined behavior.
///  * Some functions, like rcl_init() require the context instance to be
///  * zero initialized (all members set to "zero" state) before use.
///  *
///  * Zero initialization of an rcl_context_t should be done with
///  * rcl_get_zero_initialized_context(), which ensures the context is in a safe
///  * state for initialization with rcl_init().
///  *
///  * Initialization of an rcl_context_t should be done with rcl_init(), after
///  * which the context is considered both initialized and valid.
///  * After initialization it can be used in the creation of other entities like
///  * nodes and guard conditions.
///  *
///  * At any time the context can be invalidated by calling rcl_shutdown() on
///  * the rcl_context_t, after which the context is still initialized but now
///  * invalid.
///  *
///  * Invalidation indicates to other entities that the context was shutdown, but
///  * is still accessible for use during cleanup of themselves.
///  *
///  * After being invalidated, and after all of the entities which used it have
///  * been finalized, the context should be finalized with rcl_context_fini().
///  *
///  * Finalizing the context while entities which have copies of it have not yet
///  * been finalized is undefined behavior.
///  * Therefore, the context's lifetime (between calls to rcl_init() and
///  * rcl_context_fini()) should exceed the lifetime of all entities which use
///  * it directly (e.g. nodes and guard conditions) or indirectly (e.g.
///  * subscriptions and topics).
///  */
typedef rcl_context_t = rcl_context_s;

/// A unique ID per context instance.
typedef rcl_context_instance_id_t = ffi.Uint64;

final class rcl_guard_condition_impl_s extends ffi.Opaque {}

/// Handle for a rcl guard condition.
final class rcl_guard_condition_s extends ffi.Struct {
  /// Context associated with this guard condition.
  external ffi.Pointer<rcl_context_t> context;

  /// Pointer to the guard condition implementation
  external ffi.Pointer<rcl_guard_condition_impl_t> impl;
}

/// Internal rcl guard condition implementation struct.
typedef rcl_guard_condition_impl_t = rcl_guard_condition_impl_s;

/// Options available for a rcl guard condition.
final class rcl_guard_condition_options_s extends ffi.Struct {
  /// Custom allocator for the guard condition, used for internal allocations.
  external rcl_allocator_t allocator;
}

/// Handle for a rcl guard condition.
typedef rcl_guard_condition_t = rcl_guard_condition_s;

/// Options available for a rcl guard condition.
typedef rcl_guard_condition_options_t = rcl_guard_condition_options_s;

/// Handle for an rmw guard condition
typedef rmw_guard_condition_t = rmw_guard_condition_s;

/// Structure which encapsulates the options for creating a rcl_node_t.
final class rcl_node_options_s extends ffi.Struct {
  /// Custom allocator used for internal allocations.
  external rcl_allocator_t allocator;

  /// If false then only use arguments in this struct, otherwise use global arguments also.
  @ffi.Bool()
  external bool use_global_arguments;

  /// Command line arguments that apply only to this node.
  external rcl_arguments_t arguments;

  /// Flag to enable rosout for this node
  @ffi.Bool()
  external bool enable_rosout;

  /// Middleware quality of service settings for /rosout.
  external rmw_qos_profile_t rosout_qos;
}

/// ROS MiddleWare quality of service profile.
typedef rmw_qos_profile_t = rmw_qos_profile_s;

/// Structure which encapsulates the options for creating a rcl_node_t.
typedef rcl_node_options_t = rcl_node_options_s;

final class rcl_node_impl_s extends ffi.Opaque {}

/// Structure which encapsulates a ROS Node.
final class rcl_node_s extends ffi.Struct {
  /// Context associated with this node.
  external ffi.Pointer<rcl_context_t> context;

  /// Private implementation pointer.
  external ffi.Pointer<rcl_node_impl_t> impl;
}

typedef rcl_node_impl_t = rcl_node_impl_s;

/// Structure which encapsulates a ROS Node.
typedef rcl_node_t = rcl_node_s;

/// Structure which encapsulates an rmw node
typedef rmw_node_t = rmw_node_s;

/// Contains rosidl message type support data
final class rosidl_message_type_support_t extends ffi.Struct {
  /// String identifier for the type_support.
  external ffi.Pointer<ffi.Char> typesupport_identifier;

  /// Pointer to the message type support library
  external ffi.Pointer<ffi.Void> data;

  /// Pointer to the message type support handler function
  external rosidl_message_typesupport_handle_function func;
}

typedef rosidl_message_typesupport_handle_function = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<rosidl_message_type_support_t> Function(
            ffi.Pointer<rosidl_message_type_support_t>,
            ffi.Pointer<ffi.Char>)>>;

/// Time source type, used to indicate the source of a time measurement.
/// /**
///  * RCL_ROS_TIME will report the latest value reported by a ROS time source, or
///  * if a ROS time source is not active it reports the same as RCL_SYSTEM_TIME.
///  * For more information about ROS time sources, refer to the design document:
///  * http://design.ros2.org/articles/clock_and_time.html
///  *
///  * RCL_SYSTEM_TIME reports the same value as the system clock.
///  *
///  * RCL_STEADY_TIME reports a value from a monotonically increasing clock.
///  */
abstract class rcl_clock_type_e {
  /// Clock uninitialized
  static const int RCL_CLOCK_UNINITIALIZED = 0;

  /// Use ROS time
  static const int RCL_ROS_TIME = 1;

  /// Use system time
  static const int RCL_SYSTEM_TIME = 2;

  /// Use a steady clock time
  static const int RCL_STEADY_TIME = 3;
}

/// A duration of time, measured in nanoseconds and its source.
final class rcl_duration_s extends ffi.Struct {
  /// Duration in nanoseconds and its source.
  @rcl_duration_value_t()
  external int nanoseconds;
}

/// A duration of time, measured in nanoseconds.
typedef rcl_duration_value_t = rcutils_duration_value_t;

/// Enumeration to describe the type of time jump.
abstract class rcl_clock_change_e {
  /// The source before and after the jump is ROS_TIME.
  static const int RCL_ROS_TIME_NO_CHANGE = 1;

  /// The source switched to ROS_TIME from SYSTEM_TIME.
  static const int RCL_ROS_TIME_ACTIVATED = 2;

  /// The source switched to SYSTEM_TIME from ROS_TIME.
  static const int RCL_ROS_TIME_DEACTIVATED = 3;

  /// The source before and after the jump is SYSTEM_TIME.
  static const int RCL_SYSTEM_TIME_NO_CHANGE = 4;
}

/// Struct to describe a jump in time.
final class rcl_time_jump_s extends ffi.Struct {
  /// Indicate whether or not the source of time changed.
  @ffi.Int32()
  external int clock_change;

  /// The new time minus the last time before the jump.
  external rcl_duration_t delta;
}

/// A duration of time, measured in nanoseconds and its source.
typedef rcl_duration_t = rcl_duration_s;

/// Describe the prerequisites for calling a time jump callback.
final class rcl_jump_threshold_s extends ffi.Struct {
  /// True to call callback when the clock type changes.
  @ffi.Bool()
  external bool on_clock_change;

  /// A positive duration indicating the minimum jump forwards to be considered exceeded, or zero
  /// to disable.
  external rcl_duration_t min_forward;

  /// A negative duration indicating the minimum jump backwards to be considered exceeded, or zero
  /// to disable.
  external rcl_duration_t min_backward;
}

/// Struct to describe an added callback.
final class rcl_jump_callback_info_s extends ffi.Struct {
  /// Callback to fucntion.
  external rcl_jump_callback_t callback;

  /// Threshold to decide when to call the callback.
  external rcl_jump_threshold_t threshold;

  /// Pointer passed to the callback.
  external ffi.Pointer<ffi.Void> user_data;
}

/// Signature of a time jump callback.
/// \param[in] time_jump A description of the jump in time.
/// \param[in] before_jump Every jump callback is called twice: once before the clock changes and
/// once after. This is true the first call and false the second.
/// \param[in] user_data A pointer given at callback registration which is passed to the callback.
typedef rcl_jump_callback_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<rcl_time_jump_t> time_jump,
            ffi.Bool before_jump, ffi.Pointer<ffi.Void> user_data)>>;

/// Struct to describe a jump in time.
typedef rcl_time_jump_t = rcl_time_jump_s;

/// Describe the prerequisites for calling a time jump callback.
typedef rcl_jump_threshold_t = rcl_jump_threshold_s;

/// Encapsulation of a time source.
final class rcl_clock_s extends ffi.Struct {
  /// Clock type
  @ffi.Int32()
  external int type;

  /// An array of added jump callbacks.
  external ffi.Pointer<rcl_jump_callback_info_t> jump_callbacks;

  /// Number of callbacks in jump_callbacks.
  @ffi.Size()
  external int num_jump_callbacks;

  /// Pointer to get_now function
  external ffi.Pointer<
      ffi.NativeFunction<
          rcl_ret_t Function(ffi.Pointer<ffi.Void> data,
              ffi.Pointer<rcl_time_point_value_t> now)>> get_now;

  /// void (*set_now) (rcl_time_point_value_t);
  /// Clock storage
  external ffi.Pointer<ffi.Void> data;

  /// Custom allocator used for internal allocations.
  external rcl_allocator_t allocator;
}

/// Struct to describe an added callback.
typedef rcl_jump_callback_info_t = rcl_jump_callback_info_s;

/// A single point in time, measured in nanoseconds since the Unix epoch.
typedef rcl_time_point_value_t = rcutils_time_point_value_t;

/// A single point in time, measured in nanoseconds, the reference point is based on the source.
final class rcl_time_point_s extends ffi.Struct {
  /// Nanoseconds of the point in time
  @rcl_time_point_value_t()
  external int nanoseconds;

  /// Clock type of the point in time
  @ffi.Int32()
  external int clock_type;
}

/// Encapsulation of a time source.
typedef rcl_clock_t = rcl_clock_s;

/// A single point in time, measured in nanoseconds, the reference point is based on the source.
typedef rcl_time_point_t = rcl_time_point_s;

final class rcl_publisher_impl_s extends ffi.Opaque {}

/// Structure which encapsulates a ROS Publisher.
final class rcl_publisher_s extends ffi.Struct {
  /// Pointer to the publisher implementation
  external ffi.Pointer<rcl_publisher_impl_t> impl;
}

/// Internal rcl publisher implementation struct.
typedef rcl_publisher_impl_t = rcl_publisher_impl_s;

/// Options available for a rcl publisher.
final class rcl_publisher_options_s extends ffi.Struct {
  /// Middleware quality of service settings for the publisher.
  external rmw_qos_profile_t qos;

  /// Custom allocator for the publisher, used for incidental allocations.
  ///   /** For default behavior (malloc/free), use: rcl_get_default_allocator() */
  external rcl_allocator_t allocator;

  /// rmw specific publisher options, e.g. the rmw implementation specific payload.
  external rmw_publisher_options_t rmw_publisher_options;
}

/// Structure which encapsulates a ROS Publisher.
typedef rcl_publisher_t = rcl_publisher_s;

/// Options available for a rcl publisher.
typedef rcl_publisher_options_t = rcl_publisher_options_s;

/// Allocation of memory for an rmw publisher
typedef rmw_publisher_allocation_t = rmw_publisher_allocation_s;

/// typedef for rmw_serialized_message_t;
typedef rcl_serialized_message_t = rmw_serialized_message_t;

/// \brief Serialized message as a string of bytes.
///
/// It includes (but it is not limited to) the following members:
/// \e \c buffer the reference to internal storage, as a pointer
/// \e \c buffer_length the size of stored contents, as an unsigned integer
/// \e \c buffer_capacity the capacity of internal storage, as an unsigned integer
/// /
/// /* For now this is a simple aliasing from a serialized message to a uint8 array.
/// However, in future developments this serialized message can become something
/// more complex and is therefore aliased.
typedef rmw_serialized_message_t = rcutils_uint8_array_t;

/// Structure which encapsulates an rmw publisher
typedef rmw_publisher_t = rmw_publisher_s;

/// Structure to hold a sequence of ROS messages.
final class rmw_message_sequence_s extends ffi.Struct {
  /// Array of pointers to ROS messages.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> data;

  /// The number of valid entries in `data`.
  @ffi.Size()
  external int size;

  /// The total allocated capacity of the data array.
  @ffi.Size()
  external int capacity;

  /// The allocator used to allocate the data array.
  external ffi.Pointer<rcutils_allocator_t> allocator;
}

/// Structure to hold a sequence of message infos.
final class rmw_message_info_sequence_s extends ffi.Struct {
  /// Array of message info.
  external ffi.Pointer<rmw_message_info_t> data;

  /// The number of valid entries in data.
  @ffi.Size()
  external int size;

  /// The total allocated capacity of the data array.
  @ffi.Size()
  external int capacity;

  /// The allocator used to allocate the data array.
  external ffi.Pointer<rcutils_allocator_t> allocator;
}

/// Structure to hold a sequence of ROS messages.
typedef rmw_message_sequence_t = rmw_message_sequence_s;

/// Structure to hold a sequence of message infos.
typedef rmw_message_info_sequence_t = rmw_message_info_sequence_s;

final class rcl_subscription_impl_s extends ffi.Opaque {}

/// Structure which encapsulates a ROS Subscription.
final class rcl_subscription_s extends ffi.Struct {
  /// Pointer to the subscription implementation
  external ffi.Pointer<rcl_subscription_impl_t> impl;
}

/// Internal rcl implementation struct.
typedef rcl_subscription_impl_t = rcl_subscription_impl_s;

/// Options available for a rcl subscription.
final class rcl_subscription_options_s extends ffi.Struct {
  /// Middleware quality of service settings for the subscription.
  external rmw_qos_profile_t qos;

  /// Custom allocator for the subscription, used for incidental allocations.
  ///   /** For default behavior (malloc/free), see: rcl_get_default_allocator() */
  external rcl_allocator_t allocator;

  /// rmw specific subscription options, e.g. the rmw implementation specific payload.
  external rmw_subscription_options_t rmw_subscription_options;
}

final class rcl_subscription_content_filter_options_s extends ffi.Struct {
  external rmw_subscription_content_filter_options_t
      rmw_subscription_content_filter_options;
}

/// Structure which encapsulates a ROS Subscription.
typedef rcl_subscription_t = rcl_subscription_s;

/// Options available for a rcl subscription.
typedef rcl_subscription_options_t = rcl_subscription_options_s;
typedef rcl_subscription_content_filter_options_t
    = rcl_subscription_content_filter_options_s;

/// Allocation of memory for an rmw subscription
typedef rmw_subscription_allocation_t = rmw_subscription_allocation_s;
typedef rmw_subscription_t = rmw_subscription_s;
typedef rcl_event_callback_t = rmw_event_callback_t;

/// Common event callback type signature.
/// /**
///  * Event callbacks of this type can be called in various scenarios, e.g.
///  * data becomes available on a subscription, a QoS event has occurred, or
///  * something similar.
///  *
///  * The user_data argument is given by the user when registering the callback,
///  * and is given back to the callback each time so it can have associated,
///  * user-defined state.
///  *
///  * The number_of_events argument indicates the number of events since the
///  * callback was called.
///  * This is most often 1, but can be > 1 when events occur before the callback
///  * is registered.
///  * It should never be 0.
///  *
///  * \sa rmw_subscription_set_on_new_message_callback()
///  * \sa rmw_service_set_on_new_request_callback()
///  * \sa rmw_client_set_on_new_response_callback()
///  * \sa rmw_event_set_callback()
///  */
typedef rmw_event_callback_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void> user_data, ffi.Size number_of_events)>>;

/// Contains rosidl service type support data
final class rosidl_service_type_support_t extends ffi.Struct {
  /// String identifier for the type_support.
  external ffi.Pointer<ffi.Char> typesupport_identifier;

  /// Pointer to the service type support library
  external ffi.Pointer<ffi.Void> data;

  /// Pointer to the service type support handler function
  external rosidl_service_typesupport_handle_function func;
}

typedef rosidl_service_typesupport_handle_function = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<rosidl_service_type_support_t> Function(
            ffi.Pointer<rosidl_service_type_support_t>,
            ffi.Pointer<ffi.Char>)>>;

final class rcl_client_impl_s extends ffi.Opaque {}

/// Structure which encapsulates a ROS Client.
final class rcl_client_s extends ffi.Struct {
  /// Pointer to the client implementation
  external ffi.Pointer<rcl_client_impl_t> impl;
}

/// Internal rcl client implementation struct.
typedef rcl_client_impl_t = rcl_client_impl_s;

/// Options available for a rcl_client_t.
final class rcl_client_options_s extends ffi.Struct {
  /// Middleware quality of service settings for the client.
  external rmw_qos_profile_t qos;

  /// Custom allocator for the client, used for incidental allocations.
  ///   /** For default behavior (malloc/free), use: rcl_get_default_allocator() */
  external rcl_allocator_t allocator;
}

/// Structure which encapsulates a ROS Client.
typedef rcl_client_t = rcl_client_s;

/// Options available for a rcl_client_t.
typedef rcl_client_options_t = rcl_client_options_s;

/// Meta-data for a service-related take.
typedef rmw_service_info_t = rmw_service_info_s;

/// A handle to an rmw service client
typedef rmw_client_t = rmw_client_s;

final class rcl_service_impl_s extends ffi.Opaque {}

/// Structure which encapsulates a ROS Service.
final class rcl_service_s extends ffi.Struct {
  /// Pointer to the service implementation
  external ffi.Pointer<rcl_service_impl_t> impl;
}

/// Internal rcl implementation struct.
typedef rcl_service_impl_t = rcl_service_impl_s;

/// Options available for a rcl service.
final class rcl_service_options_s extends ffi.Struct {
  /// Middleware quality of service settings for the service.
  external rmw_qos_profile_t qos;

  /// Custom allocator for the service, used for incidental allocations.
  ///   /** For default behavior (malloc/free), see: rcl_get_default_allocator() */
  external rcl_allocator_t allocator;
}

/// Structure which encapsulates a ROS Service.
typedef rcl_service_t = rcl_service_s;

/// Options available for a rcl service.
typedef rcl_service_options_t = rcl_service_options_s;

/// A handle to an rmw service
typedef rmw_service_t = rmw_service_s;

final class rosidl_runtime_c__Sequence__bound extends ffi.Struct {
  /// String identifier for the type_support.
  external ffi.Pointer<ffi.Char> typesupport_identifier;

  /// Pointer to type support handle function
  external ffi.Pointer<ffi.Void> data;

  external rosidl_runtime_c__bound_handle_function func;
}

typedef rosidl_runtime_c__bound_handle_function = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<rosidl_runtime_c__Sequence__bound> Function(
            ffi.Pointer<rosidl_runtime_c__Sequence__bound>,
            ffi.Pointer<ffi.Char>)>>;

/// Define publisher/subscription events
abstract class rmw_event_type_e {
  /// subscription events
  static const int RMW_EVENT_LIVELINESS_CHANGED = 0;
  static const int RMW_EVENT_REQUESTED_DEADLINE_MISSED = 1;
  static const int RMW_EVENT_REQUESTED_QOS_INCOMPATIBLE = 2;
  static const int RMW_EVENT_MESSAGE_LOST = 3;

  /// publisher events
  static const int RMW_EVENT_LIVELINESS_LOST = 4;
  static const int RMW_EVENT_OFFERED_DEADLINE_MISSED = 5;
  static const int RMW_EVENT_OFFERED_QOS_INCOMPATIBLE = 6;

  /// sentinel value
  static const int RMW_EVENT_INVALID = 7;
}

/// Encapsulate the RMW event implementation, data, and type.
final class rmw_event_s extends ffi.Struct {
  /// Implementation identifier, used to ensure two different implementations are not being mixed.
  external ffi.Pointer<ffi.Char> implementation_identifier;

  /// Data specific to this event type from either the publisher or subscriber.
  external ffi.Pointer<ffi.Void> data;

  /// The event type that occurred.
  @ffi.Int32()
  external int event_type;
}

/// Encapsulate the RMW event implementation, data, and type.
typedef rmw_event_t = rmw_event_s;

abstract class rmw_qos_compatibility_type_e {
  /// QoS policies are compatible
  static const int RMW_QOS_COMPATIBILITY_OK = 0;

  /// QoS policies may not be compatible
  static const int RMW_QOS_COMPATIBILITY_WARNING = 1;

  /// QoS policies are not compatible
  static const int RMW_QOS_COMPATIBILITY_ERROR = 2;
}

/// Container for guard conditions to be waited on
typedef rmw_wait_set_t = rmw_wait_set_s;

/// Array of subscriber handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific subscriptions.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of subscriptions represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
typedef rmw_subscriptions_t = rmw_subscriptions_s;

/// Array of service handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific services.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of services represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
typedef rmw_services_t = rmw_services_s;

/// Array of client handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific clients.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of clients represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
typedef rmw_clients_t = rmw_clients_s;
typedef rmw_events_t = rmw_events_s;

final class rcl_timer_impl_s extends ffi.Opaque {}

/// Structure which encapsulates a ROS Timer.
final class rcl_timer_s extends ffi.Struct {
  /// Private implementation pointer.
  external ffi.Pointer<rcl_timer_impl_t> impl;
}

typedef rcl_timer_impl_t = rcl_timer_impl_s;

/// Structure which encapsulates a ROS Timer.
typedef rcl_timer_t = rcl_timer_s;

/// User callback signature for timers.
/// /**
///  * The first argument the callback gets is a pointer to the timer.
///  * This can be used to cancel the timer, query the time until the next
///  * timer callback, exchange the callback with a different one, etc.
///  *
///  * The only caveat is that the function rcl_timer_get_time_since_last_call()
///  * will return the time since just before this callback was called, not the
///  * previous call.
///  * Therefore the second argument given is the time since the previous callback
///  * was called, because that information is no longer accessible via the timer.
///  * The time since the last callback call is given in nanoseconds.
///  */
typedef rcl_timer_callback_t = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<rcl_timer_t>, ffi.Int64)>>;

/// Enumeration of all of the publisher events that may fire.
abstract class rcl_publisher_event_type_e {
  static const int RCL_PUBLISHER_OFFERED_DEADLINE_MISSED = 0;
  static const int RCL_PUBLISHER_LIVELINESS_LOST = 1;
  static const int RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS = 2;
}

/// Enumeration of all of the subscription events that may fire.
abstract class rcl_subscription_event_type_e {
  static const int RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED = 0;
  static const int RCL_SUBSCRIPTION_LIVELINESS_CHANGED = 1;
  static const int RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS = 2;
  static const int RCL_SUBSCRIPTION_MESSAGE_LOST = 3;
}

final class rcl_event_impl_s extends ffi.Opaque {}

/// Structure which encapsulates a ROS QoS event handle.
final class rcl_event_s extends ffi.Struct {
  /// Pointer to the event implementation
  external ffi.Pointer<rcl_event_impl_t> impl;
}

/// Internal rcl implementation struct.
typedef rcl_event_impl_t = rcl_event_impl_s;

/// Structure which encapsulates a ROS QoS event handle.
typedef rcl_event_t = rcl_event_s;

final class rcl_wait_set_impl_s extends ffi.Opaque {}

/// Container for subscription's, guard condition's, etc to be waited on.
final class rcl_wait_set_s extends ffi.Struct {
  /// Storage for subscription pointers.
  external ffi.Pointer<ffi.Pointer<rcl_subscription_t>> subscriptions;

  /// Number of subscriptions
  @ffi.Size()
  external int size_of_subscriptions;

  /// Storage for guard condition pointers.
  external ffi.Pointer<ffi.Pointer<rcl_guard_condition_t>> guard_conditions;

  /// Number of guard_conditions
  @ffi.Size()
  external int size_of_guard_conditions;

  /// Storage for timer pointers.
  external ffi.Pointer<ffi.Pointer<rcl_timer_t>> timers;

  /// Number of timers
  @ffi.Size()
  external int size_of_timers;

  /// Storage for client pointers.
  external ffi.Pointer<ffi.Pointer<rcl_client_t>> clients;

  /// Number of clients
  @ffi.Size()
  external int size_of_clients;

  /// Storage for service pointers.
  external ffi.Pointer<ffi.Pointer<rcl_service_t>> services;

  /// Number of services
  @ffi.Size()
  external int size_of_services;

  /// Storage for event pointers.
  external ffi.Pointer<ffi.Pointer<rcl_event_t>> events;

  /// Number of events
  @ffi.Size()
  external int size_of_events;

  /// Implementation specific storage.
  external ffi.Pointer<rcl_wait_set_impl_t> impl;
}

typedef rcl_wait_set_impl_t = rcl_wait_set_impl_s;

/// Container for subscription's, guard condition's, etc to be waited on.
typedef rcl_wait_set_t = rcl_wait_set_s;

final class rosidl_runtime_c__float__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Float> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__double__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Double> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__long_double__Sequence extends ffi.Opaque {}

final class rosidl_runtime_c__char__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.SignedChar> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__wchar__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Uint16> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__boolean__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Bool> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__octet__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__uint8__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__int8__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__uint16__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Uint16> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__int16__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Int16> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__uint32__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Uint32> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__int32__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Int32> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__uint64__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Uint64> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__int64__Sequence extends ffi.Struct {
  external ffi.Pointer<ffi.Int64> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

/// An array of 8-bit characters terminated by a null byte.
final class rosidl_runtime_c__String extends ffi.Struct {
  /// The pointer to the first character, the sequence ends with a null byte.
  external ffi.Pointer<ffi.Char> data;

  /// The length of the string (excluding the null byte).
  @ffi.Size()
  external int size;

  /// The capacity represents the number of allocated bytes (including the null byte).
  @ffi.Size()
  external int capacity;
}

final class rosidl_runtime_c__String__Sequence extends ffi.Struct {
  external ffi.Pointer<rosidl_runtime_c__String> data;

  @ffi.Size()
  external int size;

  @ffi.Size()
  external int capacity;
}

const int RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT = 0;

const int true1 = 1;

const int false1 = 0;

const int __bool_true_false_are_defined = 1;

const int NULL = 0;

const int RCUTILS_RET_OK = 0;

const int RCUTILS_RET_WARN = 1;

const int RCUTILS_RET_ERROR = 2;

const int RCUTILS_RET_BAD_ALLOC = 10;

const int RCUTILS_RET_INVALID_ARGUMENT = 11;

const int RCUTILS_RET_NOT_ENOUGH_SPACE = 12;

const int RCUTILS_RET_NOT_INITIALIZED = 13;

const int RCUTILS_RET_NOT_FOUND = 14;

const int RCUTILS_RET_STRING_MAP_ALREADY_INIT = 30;

const int RCUTILS_RET_STRING_MAP_INVALID = 31;

const int RCUTILS_RET_STRING_KEY_NOT_FOUND = 32;

const int RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID = 40;

const int RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID = 41;

const int RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES = 50;

const int _STDINT_H = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __TIMESIZE = 64;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 31;

const int _SYS_CDEFS_H = 1;

const int __glibc_c99_flexarr_available = 1;

const int __HAVE_GENERIC_SELECTION = 0;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int _BITS_TYPES_H = 1;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int _BITS_WCHAR_H = 1;

const int __WCHAR_MAX = 2147483647;

const int __WCHAR_MIN = -2147483648;

const int _BITS_STDINT_INTN_H = 1;

const int _BITS_STDINT_UINTN_H = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const int RMW_DEFAULT_DOMAIN_ID = -1;

const int RMW_RET_OK = 0;

const int RMW_RET_ERROR = 1;

const int RMW_RET_TIMEOUT = 2;

const int RMW_RET_UNSUPPORTED = 3;

const int RMW_RET_BAD_ALLOC = 10;

const int RMW_RET_INVALID_ARGUMENT = 11;

const int RMW_RET_INCORRECT_RMW_IMPLEMENTATION = 12;

const int RMW_RET_NODE_NAME_NON_EXISTENT = 203;

const int __GNUC_VA_LIST = 1;

const int _STDIO_H = 1;

const int _____fpos_t_defined = 1;

const int ____mbstate_t_defined = 1;

const int _____fpos64_t_defined = 1;

const int ____FILE_defined = 1;

const int __FILE_defined = 1;

const int __struct_FILE_defined = 1;

const int _IO_EOF_SEEN = 16;

const int _IO_ERR_SEEN = 32;

const int _IO_USER_LOCK = 32768;

const int _IOFBF = 0;

const int _IOLBF = 1;

const int _IONBF = 2;

const int BUFSIZ = 8192;

const int EOF = -1;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const String P_tmpdir = '/tmp';

const int _BITS_STDIO_LIM_H = 1;

const int L_tmpnam = 20;

const int TMP_MAX = 238328;

const int FILENAME_MAX = 4096;

const int L_ctermid = 9;

const int FOPEN_MAX = 16;

const int __HAVE_FLOAT128 = 0;

const int __HAVE_DISTINCT_FLOAT128 = 0;

const int __HAVE_FLOAT64X = 1;

const int __HAVE_FLOAT64X_LONG_DOUBLE = 1;

const int __HAVE_FLOAT16 = 0;

const int __HAVE_FLOAT32 = 1;

const int __HAVE_FLOAT64 = 1;

const int __HAVE_FLOAT32X = 1;

const int __HAVE_FLOAT128X = 0;

const int __HAVE_DISTINCT_FLOAT16 = 0;

const int __HAVE_DISTINCT_FLOAT32 = 0;

const int __HAVE_DISTINCT_FLOAT64 = 0;

const int __HAVE_DISTINCT_FLOAT32X = 0;

const int __HAVE_DISTINCT_FLOAT64X = 0;

const int __HAVE_DISTINCT_FLOAT128X = 0;

const int __HAVE_FLOAT128_UNLIKE_LDBL = 0;

const int __HAVE_FLOATN_NOT_TYPEDEF = 0;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int _ASSERT_H = 1;

const int _STDLIB_H = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WSTOPPED = 2;

const int WEXITED = 4;

const int WCONTINUED = 8;

const int WNOWAIT = 16777216;

const int __WNOTHREAD = 536870912;

const int __WALL = 1073741824;

const int __WCLONE = 2147483648;

const int __W_CONTINUED = 65535;

const int __WCOREFLAG = 128;

const int __ldiv_t_defined = 1;

const int __lldiv_t_defined = 1;

const int RAND_MAX = 2147483647;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int _SYS_TYPES_H = 1;

const int __clock_t_defined = 1;

const int __clockid_t_defined = 1;

const int __time_t_defined = 1;

const int __timer_t_defined = 1;

const int __BIT_TYPES_DEFINED__ = 1;

const int _ENDIAN_H = 1;

const int _BITS_ENDIAN_H = 1;

const int __LITTLE_ENDIAN = 1234;

const int __BIG_ENDIAN = 4321;

const int __PDP_ENDIAN = 3412;

const int _BITS_ENDIANNESS_H = 1;

const int __BYTE_ORDER = 1234;

const int __FLOAT_WORD_ORDER = 1234;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int _BITS_BYTESWAP_H = 1;

const int _BITS_UINTN_IDENTITY_H = 1;

const int _SYS_SELECT_H = 1;

const int __sigset_t_defined = 1;

const int _SIGSET_NWORDS = 16;

const int __timeval_defined = 1;

const int _STRUCT_TIMESPEC = 1;

const int __NFDBITS = 64;

const int FD_SETSIZE = 1024;

const int NFDBITS = 64;

const int _BITS_PTHREADTYPES_COMMON_H = 1;

const int _THREAD_SHARED_TYPES_H = 1;

const int _BITS_PTHREADTYPES_ARCH_H = 1;

const int __SIZEOF_PTHREAD_MUTEX_T = 40;

const int __SIZEOF_PTHREAD_ATTR_T = 56;

const int __SIZEOF_PTHREAD_RWLOCK_T = 56;

const int __SIZEOF_PTHREAD_BARRIER_T = 32;

const int __SIZEOF_PTHREAD_MUTEXATTR_T = 4;

const int __SIZEOF_PTHREAD_COND_T = 48;

const int __SIZEOF_PTHREAD_CONDATTR_T = 4;

const int __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;

const int __SIZEOF_PTHREAD_BARRIERATTR_T = 4;

const int _THREAD_MUTEX_INTERNAL_H = 1;

const int __PTHREAD_MUTEX_HAVE_PREV = 1;

const int __PTHREAD_RWLOCK_ELISION_EXTRA = 0;

const int __have_pthread_attr_t = 1;

const int _ALLOCA_H = 1;

const int _STRING_H = 1;

const int _BITS_TYPES_LOCALE_T_H = 1;

const int _BITS_TYPES___LOCALE_T_H = 1;

const int _STRINGS_H = 1;

const int RCUTILS_FAULT_INJECTION_NEVER_FAIL = -1;

const int RCUTILS_FAULT_INJECTION_FAIL_NOW = 0;

const int RCUTILS_ERROR_STATE_LINE_NUMBER_STR_MAX_LENGTH = 20;

const int RCUTILS_ERROR_FORMATTING_CHARACTERS = 6;

const int RCUTILS_ERROR_MESSAGE_MAX_LENGTH = 1024;

const int RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH = 768;

const int RCUTILS_ERROR_STATE_FILE_MAX_LENGTH = 229;

const String RCUTILS_LOGGING_SEPARATOR_STRING = '.';

const int RCUTILS_DEFAULT_LOGGER_DEFAULT_LEVEL = 20;

const int RMW_GID_STORAGE_SIZE = 24;

const String RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE_DEPRECATED_MSG =
    'RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE is deprecated. Use RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC if manually asserted liveliness is needed.';

const int RMW_MESSAGE_INFO_SEQUENCE_NUMBER_UNSUPPORTED = -1;

const int RCL_RET_OK = 0;

const int RCL_RET_ERROR = 1;

const int RCL_RET_TIMEOUT = 2;

const int RCL_RET_BAD_ALLOC = 10;

const int RCL_RET_INVALID_ARGUMENT = 11;

const int RCL_RET_UNSUPPORTED = 3;

const int RCL_RET_ALREADY_INIT = 100;

const int RCL_RET_NOT_INIT = 101;

const int RCL_RET_MISMATCHED_RMW_ID = 102;

const int RCL_RET_TOPIC_NAME_INVALID = 103;

const int RCL_RET_SERVICE_NAME_INVALID = 104;

const int RCL_RET_UNKNOWN_SUBSTITUTION = 105;

const int RCL_RET_ALREADY_SHUTDOWN = 106;

const int RCL_RET_NODE_INVALID = 200;

const int RCL_RET_NODE_INVALID_NAME = 201;

const int RCL_RET_NODE_INVALID_NAMESPACE = 202;

const int RCL_RET_NODE_NAME_NON_EXISTENT = 203;

const int RCL_RET_PUBLISHER_INVALID = 300;

const int RCL_RET_SUBSCRIPTION_INVALID = 400;

const int RCL_RET_SUBSCRIPTION_TAKE_FAILED = 401;

const int RCL_RET_CLIENT_INVALID = 500;

const int RCL_RET_CLIENT_TAKE_FAILED = 501;

const int RCL_RET_SERVICE_INVALID = 600;

const int RCL_RET_SERVICE_TAKE_FAILED = 601;

const int RCL_RET_TIMER_INVALID = 800;

const int RCL_RET_TIMER_CANCELED = 801;

const int RCL_RET_WAIT_SET_INVALID = 900;

const int RCL_RET_WAIT_SET_EMPTY = 901;

const int RCL_RET_WAIT_SET_FULL = 902;

const int RCL_RET_INVALID_REMAP_RULE = 1001;

const int RCL_RET_WRONG_LEXEME = 1002;

const int RCL_RET_INVALID_ROS_ARGS = 1003;

const int RCL_RET_INVALID_PARAM_RULE = 1010;

const int RCL_RET_INVALID_LOG_LEVEL_RULE = 1020;

const int RCL_RET_EVENT_INVALID = 2000;

const int RCL_RET_EVENT_TAKE_FAILED = 2001;

const int RCL_RET_LIFECYCLE_STATE_REGISTERED = 3000;

const int RCL_RET_LIFECYCLE_STATE_NOT_REGISTERED = 3001;

const String RCL_ROS_ARGS_FLAG = '--ros-args';

const String RCL_ROS_ARGS_EXPLICIT_END_TOKEN = '--';

const String RCL_PARAM_FLAG = '--param';

const String RCL_SHORT_PARAM_FLAG = '-p';

const String RCL_PARAM_FILE_FLAG = '--params-file';

const String RCL_REMAP_FLAG = '--remap';

const String RCL_SHORT_REMAP_FLAG = '-r';

const String RCL_ENCLAVE_FLAG = '--enclave';

const String RCL_SHORT_ENCLAVE_FLAG = '-e';

const String RCL_LOG_LEVEL_FLAG = '--log-level';

const String RCL_EXTERNAL_LOG_CONFIG_FLAG = '--log-config-file';

const String RCL_LOG_STDOUT_FLAG_SUFFIX = 'stdout-logs';

const String RCL_LOG_ROSOUT_FLAG_SUFFIX = 'rosout-logs';

const String RCL_LOG_EXT_LIB_FLAG_SUFFIX = 'external-lib-logs';

const int __alignas_is_defined = 1;

const int __alignof_is_defined = 1;

const int RCL_CONTEXT_ATOMIC_INSTANCE_ID_STORAGE_SIZE = 8;

const int RCL_DEFAULT_DOMAIN_ID = -1;

const int RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID = -1;
